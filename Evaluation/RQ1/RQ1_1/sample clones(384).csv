function1 code,function2 code,function1 FEN,function2 FEN,label1,label2,label
"  function mulSafe(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
       return 0;
     }
     uint256 c = a * b;
     assert(c / a == b);
     return c;
   }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x3c1b1abf64a441bc106e055cdc89ba4ca005993e/HGToken.sol:SafeMath:mulSafe(uint256,uint256)","0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:SafeMath:mul(uint256,uint256)",4,4,1
"     function allowance(address _owner, address _spender) constant returns (uint256 remaining)
     {
        return allowed[_owner][_spender];
     }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x3ce072b9ec58bd88e350cbd17537c9190fc67b2b/BIZToken.sol:BIZToken:allowance(address,address)","0x5b43d6ac79bc4b89ca1f9cfd5b76f7355aae2781/ACIFToken.sol:StandardToken:allowance(address,address)",5,5,1
"    function acupuncturecoin(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function LBL (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x8a95e5488153724d5bfd37a17b0608c8d7d31202/acupuncturecoin.sol:acupuncturecoin:acupuncturecoin(uint256,string,string)","0x5eab901c61b4c4775349e6bb6e78ce3f4d496b0d/LBL.sol:LBL:LBL(uint256,string,string)",4,4,1
"    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x8c2dd6875edaf3118f1c565d0f9a087fcb87d579/MeiTuanToken.sol:MeiTuanToken:transfer(address,uint256)","0x4aae3a2da70c499797edf4a4139b68454ec07883/JOUL3SToken.sol:JOUL3SToken:transfer(address,uint256)",5,5,1
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      assert(b <= a);
      return a - b;
    }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x3a7a5ba347928dfc8a748b5e55558d5fee84a2a9/MPToken.sol:SafeMath:sub(uint256,uint256)","0x6b9d422cc05029d1324fc5b007aff49e2ab54882/CnytCoin.sol:SafeMath:sub(uint256,uint256)",4,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","0x4a908fa1623bb7142fefb82838550a0381838bef/Altn.sol:AltnBasic:transfer(address,uint256)","0x3decf246a76a8c264a7d589779ee1d5f5f2170af/VisualChain.sol:BasicToken:transfer(address,uint256)",4,4,1
"    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
","function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:Ownable:transferOwnership(address),0x6b62f8458fbecc2ed07021c823a1ebb537641ffb/KickSportsManager.sol:Ownable:transferOwnership(address),5,5,1
"	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(a <= c);
		return c;
	}
","    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x2fB96a6CA0e940eD219e9386210e6CF299295FFE/GermaineIfuduPrivateSale.sol:SafeMath:add(uint256,uint256)","0x00ec053f75a8189ef0763c88e483be4da40522ef/UBOToken.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x6c558a4976e751391fb73dd61fa6a72c318d80b5/BitQ.sol:BitQ:allowance(address,address)","0x1f1777bff69a8e5c880c9ebb79c9b94fe9883321/DarenHui.sol:DarenHui:allowance(address,address)",5,5,1
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:StandardToken:increaseApproval(address,uint256)","0x7a3846ee59d2a02e3e91362bd3545c88d029a238/EtherBB.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6c437ddf9397be0708d13e6b063fb564fa8cbf5d/BigDickClub.sol:StandardToken:approve(address,uint256)","0x7cef08c8324c74bb12c18b775034ced5186ed0df/StarTravelLane.sol:StandardToken:approve(address,uint256)",4,4,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x8a9ec3aa052946071fa87d7a5ead90d17108d905/BunnyToken.sol:BunnyToken:approve(address,uint256)","0x1db7f8171d82f9fc009f207cd80dd00a54b77560/OllisCoin.sol:OllisCoin:approve(address,uint256)",5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","0x02ebe0ce3ac0ada772a5831cf3a6742a84ee22f5/BFMToken.sol:BasicToken:transfer(address,uint256)","0x8a619b19e85e264770eb67dbdbcaf0daa9158a6c/OD1Coin.sol:BasicToken:transfer(address,uint256)",4,4,1
"	function approve(address _spender, uint256 _value) returns (bool success) {
	    allowed[msg.sender][_spender] = _value;
	    Approval(msg.sender, _spender, _value);
	    return true;
	}
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x3b253defe296877ad467eaca7bfb60937bd7c457/GSD.sol:GSD:approve(address,uint256)","0x0dc44fb8cfb88cd58628846cdcefff4089d9ac7e/oddular.sol:StandardToken:approve(address,uint256)",5,5,1
"    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6dc5880bad03f0eeb6e6b60954074cd3739563d0/AssetMoira.sol:ERC20Token:allowance(address,address)","0x7b46aa8f02b7d7d51fb355f8b0aec5a02d44baa3/TestCoin.sol:StandardToken:allowance(address,address)",5,5,1
"  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
","     function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
     }
",0x0dffe2e82d6175bc5cb2ef4ef0f67939ecfdbe3e/EplusCoinToken.sol:StandardToken:balanceOf(address),0x5c227eb319c24249df66d0c5879515aa59787471/BitAlpha.sol:BitAlpha:balanceOf(address),5,5,1
"     modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x0cd103a98a13025871d006793bd4ab69fdf34d74/CorvusToken.sol:CorvusToken:onlyOwner(),0x4c129783B42833220ad57d48548f871189009d3f/HoQuBurner.sol:Ownable:onlyOwner(),5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x6cd694d5a9c71cd811922e3cb314f44afe25a48c/TJCUToken.sol:TJCUToken:approve(address,uint256)","0x1fdd9abafd1013518bac51af0346585b810fc1c4/Meridian.sol:ERC20Token:approve(address,uint256)",5,5,1
"    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x6a70a37379601a7220df2444b51cc34a1a7b0cc4/CABoxToken.sol:Ownable:transferOwnership(address),0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:Ownable:transferOwnership(address),5,5,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function div(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a / b;
        return c;
    }
","0x1a66e09f7dccc10eae46e27cfa6b8d44a50df1e7/PRASMToken.sol:SafeMath:div(uint256,uint256)","0x5Cd8d674e6E8CF2c0124A9215a849d6eb52962e4/NLEURO.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function balanceOf(address _owner) view public returns (uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x0fca8fdb0fb115a33baadec6e7a141ffc1bc7d5a/DevCash.sol:DevCash:balanceOf(address),0x06f0b31fa75d6a4f689fa0f4225f1811ae4a7e7d/TokenSaleAfterSplit.sol:ControlledToken:balanceOf(address),4,5,1
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6f2057f83c05378f22a15b72a424367cb40abc1b/TokenCSR.sol:StandardToken:approve(address,uint256)","0x5ABC07D28DCC3B60a164d57e4E3981a090c5d6De/BOMBBA.sol:BOMBBA:approve(address,uint256)",4,4,1
"    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
","  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x3a7a5ba347928dfc8a748b5e55558d5fee84a2a9/MPToken.sol:Ownable:transferOwnership(address),0x1d8f5b2bd72a7db787e4f42cce6be8474389353d/EthRoi.sol:Ownable:transferOwnership(address),4,4,1
"     function approve(address _spender, uint256 _value) returns (bool success) {
          allowed[msg.sender][_spender] = _value;
          Approval(msg.sender, _spender, _value);

          return true;
     }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x1b3b1aa7b91bd483e6dcd3f7560494345d102550/MNTP.sol:StdToken:approve(address,uint256)","0x7b41f87b09677986fa5ed10519d3ad8ef559648d/MoccaCoin.sol:StandardToken:approve(address,uint256)",5,5,1
"    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","    function add(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        require(c >= a);

    }
","0x5da1ae58900514cbae8b03a05bd2e8e71de7e6a1/AOT.sol:SafeMath:add(uint256,uint256)","0x0df610d4229bcd5e149eec3e806a9afe74f5d63f/HVAToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x1efc4dfd580df95426a0f04848870bd8cb5a338e/AcademyToken.sol:AcademyToken:transferFrom(address,address,uint256)","0x3cbaf1d511adf5098511b5c5b39e1f1b506c1afe/XRT.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);
      require(allowance[_from][msg.sender] >= _value);

      balanceOf[_from] -= _value;
      balanceOf[_to] += _value;
      allowance[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    }
","	function transferFrom(address from, address to, uint256 value)
		public
		returns (bool success)
	{
		require(value <= balanceOf[from]);
		require(value <= allowance[from][msg.sender]);

		balanceOf[from] -= value;
		balanceOf[to] += value;
		allowance[from][msg.sender] -= value;
		emit Transfer(from, to, value);
		return true;
	}
","0x0e285934fa1370b014fd5c639cf9eb03433af238/AbxyjoyCoin.sol:AbxyjoyCoin:transferFrom(address,address,uint256)","0x4e6998f0131c1fde3f36d1660d84c5c1a7c4ee26/BNP_PARIBAS_301201.sol:BNP_PARIBAS_301201:transferFrom(address,address,uint256)",4,4,1
"  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }
","  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }
",0x0af44e2784637218dd1d32a322d44e603a8f0c6a/MatryxToken.sol:ReleasableToken:releaseTokenTransfer(),0x5de3e294ca2a0aba67df4610015d8e21cb8c8987/CrowdsaleTokenExt.sol:ReleasableToken:releaseTokenTransfer(),5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","0x3a6ad3b097a5623fcea2eb490c921654ee9630ac/EYHToken.sol:BasicToken:transfer(address,uint256)","0x3E1d5A855aD9D948373aE68e4fe1f094612b1322/HyperQuantToken.sol:BasicToken:transfer(address,uint256)",5,5,1
"    function owned() {
        owner = msg.sender;
    }
","    function owned() public {
        owner = msg.sender;
    }
",0x4b855725bb816b7e2b3e67bcffe0436b407675ae/SimpleRegistrar.sol:owned:owned(),0x5d406656272da7c83966be544910732c4a547f86/ELearningCoinERC.sol:owned:owned(),5,5,1
"  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1f060991e27634cdc449776ed9771e6f8cce6dd0/CoinSmarttICO.sol:StandardToken:decreaseApproval(address,uint256)","0x1aD8e98a828D8c460e994F279E35fbE4cf213bA6/CommitGoodToken.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"  function Ownable() {
    owner = msg.sender;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x0e3785b2ecb235ad8f225331259eacc89f864877/MinexoDigital.sol:Ownable:Ownable(),0x1dc3fc96b218b4ac9d36193f3325d949f9ed3a26/ETYCToken.sol:Ownable:Ownable(),5,5,1
"  function allowance(address _owner, address _spender) public view returns (uint256) {
     return allowed[_owner][_spender];
   }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x0cf004e9634cf978ed4cce28349bf9514609d5e7/StandardToken.sol:StandardToken:allowance(address,address)","0x0B117cd026EeC3af86eBEdA40B6b25eED1662E60/UBlockChain.sol:UBlockChain:allowance(address,address)",5,5,1
"	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
		c = a + b;
		assert(c >= a);
		return c;
	}
","  function add(uint256 a, uint256 b) constant public returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x6acd16200a2a046bf207d1b263202ec1a75a7d51/dappVolumeHearts.sol:SafeMath:add(uint256,uint256)","0x4ddb111812363e92d41e31fc3bfeee33fc7dba27/CABCoin.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) returns(bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","   function transfer(address _to, uint256 _value) public returns (bool) {
    ico_balances[msg.sender] = ico_balances[msg.sender].sub(_value);
    ico_balances[_to] = ico_balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","0x7e562bff582b6c56757ebf53e4807f8e75b6d31d/Dashx.sol:Dashx:transfer(address,uint256)","0x2d4c0a94ecc29513972b302ea143aa6e0412fcde/BasisIco.sol:BasisIco:transfer(address,uint256)",4,4,1
"   function balanceOf(address _owner) public view returns (uint256 balance) {
      return balances[_owner];
   }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x6d68003c0452632a87381c42091fc94ceb047fd1/Duckcoin.sol:ERC20Token:balanceOf(address),0x04cc783b450b8d11f3c7d00dd03fdf7fb51fe9f2/FilmscoinToken.sol:BasicToken:balanceOf(address),5,5,1
"  modifier whenPaused() {
    require(paused);
    _;
  }
","  modifier whenPaused() {
    require(paused);
    _;
  }
",0x8c1f5174ac847520a9859f6dccd59a1c28b75021/HNYToken.sol:Pausable:whenPaused(),0x7b606bc8ce7ba370b14bf5b43d1987cbaadc8d6d/DunkPayToken.sol:Pausable:whenPaused(),5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x5AD02e427Db5257169dD8e8997DC335cBA2fE65c/KDTToken.sol:KDTToken:approveAndCall(address,uint256,bytes)","0x6ef1cdb9aaa7d7ca0deea9b542a7cf3dada7c996/YunbeiToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)",5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","0x4ca68c8ecb94acbc736bcb4119fd76aa5170b226/StupidCoin.sol:SafeMath:div(uint256,uint256)","0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success){
         allowed[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);
         return true;
    }
","0x7a03664e23ecf1951b0a1f32d9a2be52631533f4/BritainGlobalCurrencyToken.sol:BritainGlobalCurrencyToken:approve(address,uint256)","0x7ce88ceed1015ecebaed624459dd97435e77157b/ATCToken.sol:ATCToken:approve(address,uint256)",5,5,1
"    function owned() public {
        owner = msg.sender;
    }
","    function Owned() public {
        owner = msg.sender;
    }
",0x0bab6f620063cbb684c06877957f89f1bb10616f/SmartIndustrialToken.sol:owned:owned(),0x7ddb9cd43313a9af3494a7030aba5293f94cfecd/ttToken.sol:Owned:Owned(),4,4,1
"    function div(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a / b;
        return c;
    }
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x0e783f74942e8bacbed3b48a7ec0830b3236edc9/CLEMON.sol:SafeMath:div(uint256,uint256)","0x001ea8150f4965195e10e5b5568047e1555a6dcd/SenseProtocol.sol:SafeMath:div(uint256,uint256)",5,5,1
" modifier onlyOwner() {
   require(msg.sender == owner);
   _;
 }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd/TokenLoot.sol:Ownable:onlyOwner(),0x4a152dd76d1919779190feea11edd06c00fed4e0/TttestaryToken.sol:Ownable:onlyOwner(),5,5,1
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowance[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x7d5404ea3344745f80d039c28efbe44742935593/Arascacoin.sol:Arascacoin:allowance(address,address)","0x6b414584f7dd3750a0d61b4b8692242a7debee06/XGoldToken.sol:StandardToken:allowance(address,address)",4,4,1
"  function sub(uint _a, uint _b) internal pure returns (uint) {
    assert(_b <= _a);
    return _a - _b;
  }
","  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }
","0x7d4d05abcadbdbf877c5cd5eb9dac6ddaa17ff89/BECCToken.sol:SafeMath:sub(uint256,uint256)","0x3dd2ecaa49df3306c1332d2b858dfe8268314a5c/DigiassetzToken.sol:SafeMath:sub(uint256,uint256)",5,5,1
"    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x5fb9a342ac544ce400a7ef82ec26e731670276e9/BUXCOINMONEYCONTRACT.sol:SafeMath:safeMul(uint256,uint256)","0x3ac8e1b28fea1a86d6e6033870c9ec29beeb43aa/THETOKEN.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x2b319ebea4ce46899171803956093d31830da508/Shakedown0x.sol:SafeMath:safeMul(uint256,uint256)","0x2Bd9370e22498B3A08771d5eA5Bda84b2c45A43a/SafeMathLibExt.sol:SafeMathLibExt:times(uint256,uint256)",2,3,1
"  function transferOwnership(address newOwner) onlyOwner public {
    pendingOwner = newOwner;
  }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x0dD1C99aC9BC48A1d482878ECC8B9760Aa1e8De2/InToken.sol:Claimable:transferOwnership(address),0x4c4d0a4a307bb9ccbd3e70adf5382ac980865d86/PreHELIX.sol:Owned:transferOwnership(address),4,4,1
"  function Ownable() public {
      owner = msg.sender;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x2bb362a97f2bbb87af4cfe4faa6e3f049a5e364f/DoctorChainToken.sol:Ownable:Ownable(),0x1a7cc52ca652ac5df72a7fa4b131cb9312dd3423/MagnusCoin.sol:Ownable:Ownable(),5,5,1
"  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x2b022ba25bc7be712dd8e62a5937da54003cdea9/DogCoinCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)","0x1f8b657d1008798842edf8ea80b135ca723295a1/Spacoin.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
","  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
",0x3E1d5A855aD9D948373aE68e4fe1f094612b1322/HyperQuantToken.sol:Ownable:_transferOwnership(address),0x5b78fd6f5e8ea497534dd205e58daa51d26eded2/BITXDistributionTools.sol:Ownable:_transferOwnership(address),5,5,1
"    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x7a00f353c4117f28fe50a1c2a43856b73cc60e4d/PO8Token.sol:KTBaseToken:decreaseApproval(address,uint256)","0x5ed786a050c866703e16ad621b9259553a1188a9/ERONIUM.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function allowance(
        address _owner,
        address _spender
    )
        public
        view
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
","  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
","0x2a47f802064caf5a5e78ee193723dc2c7cfc06e9/Moolyacoin.sol:StandardToken:allowance(address,address)","0x0d941d0379Bc5Cb2A610a9b0f02Ec6fA4a387dC8/Teza.sol:StandardToken:allowance(address,address)",5,5,1
"    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }
","    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }
",0x7d01989c920ff8c45916195317381bb6a62352d1/BalanceReader.sol:Presale:onlyOwner(),0x6f4024e5549bFDA253d0997AdB228BFEAAC9B204/WavesEthereumSwap.sol:WavesBitcoinToken:onlyOwner(),5,5,1
"   function Owned() public
   {
      owner = msg.sender;
   }
","    function Owned() public {
        owner = msg.sender;
    }
",0x6d68003c0452632a87381c42091fc94ceb047fd1/Duckcoin.sol:Owned:Owned(),0x6b8c3eaa82353ec89a96942708e3d9dc87db6a34/BancorConverterUpgrader.sol:Owned:Owned(),5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x3d8945dcfc11627a6a762f203be3b1b14db36c4c/WHAToken.sol:TokenERC20:_transfer(address,address,uint256)","0x6e77c68404cb4b86b1cf7ae4ade8d260b4f9d5ce/UlordToken.sol:UlordToken:_transfer(address,address,uint256)",5,5,1
"    function add(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","0x8A6fD40ac04DBfC289AFEb05B101fB57944aD89C/InspireCoin.sol:SafeMath:add(uint256,uint256)","0x8aed6360f228a232cecfa86c64e9aff507aa84a6/GladiatorToken.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowances[_owner][_spender];
    }
","  function allowance(address _owner, address _spender) constant
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }
","0x07c9995acfe02968d71694a2a9edf9b8095d66b4/DMC.sol:DMC:allowance(address,address)","0x2e59c87e9349242063793761780550374a3146cf/THORToken.sol:AbstractToken:allowance(address,address)",5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;assert(c >= a);return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x2d2ac19de4a1105bfa284aab74aa1ab8f19e87ab/Studio.sol:SafeMath:add(uint256,uint256)","0x7b06ad092541635cf83a1ff03daf713269d94a15/IouRootsPresaleToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
",0x3a6b457fbc2c2a26d7f0067d92f741dfa26069d6/GOCOIN.sol:Ownable:transferOwnership(address),0x1Db10d198C2D66A8767e7aDde7FA5E5Bf2D57604/CrowdsalePhase1.sol:Ownable:transferOwnership(address),4,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    return a - b;
  }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x7ab329fadec5da9664e7d22040f9bfe8f2d93516/KismetPanda.sol:SafeMath:sub(uint256,uint256)","0x4f27053f32eda8af84956437bc00e5ffa7003287/ThriveToken.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
","0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:AndhraToken:approve(address,uint256)","0x1c4f85e3e58afbf488998c92c6b920715daf5af7/CodexStandardToken.sol:CodexStandardToken:approve(address,uint256)",4,4,1
"    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
","    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
",0x8b3d0703b30a6c2eb8b88a479648391186e4cc8f/FIGHTMONEY.sol:FIGHTMONEY:finishMinting(),0x8acd341e4c0f1c329ae33cb4eaac39e3c1f2c210/INMCOIN.sol:INMCOIN:finishMinting(),5,5,1
"      function totalSupply() public view returns (uint256) {
        return totalSupply_;
      }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x3f8d47619d132577260fd6db8d665d0a9d37c579/DAOToken.sol:BasicToken:totalSupply(),0x3d1fb9e4fe508d27f9d47c903f3ad3a47de8dcf8/AATokenPrivatesale.sol:BasicToken:totalSupply(),5,5,1
"    function balanceOf(address _owner) constant returns(uint256 balance) {

        return balances[_owner];

    }
","  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x0e7549a23e27a47b5c8f6d5138194c35cc3e2919/FreeCatalugnaCoin.sol:FreeCatalugnaCoin:balanceOf(address),0x1a7b00404b755ff80126f1d66a90f5aedded25da/MulTraToken.sol:BasicToken:balanceOf(address),5,5,1
"  function add(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:SafeMath:add(uint256,uint256)","0x1dc4c69736741873913a4330d3d3b8aff92c8eb2/MYC.sol:SafeMath:add(uint256,uint256)",5,5,1
"    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x1e378cdf48cd6faa3fc8e0bc0dbe02446969e46d/GEONToken.sol:Owned:onlyOwner(),0x3d1fb9e4fe508d27f9d47c903f3ad3a47de8dcf8/AATokenPrivatesale.sol:Ownable:onlyOwner(),5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x1f0d98ea3f51e20aa60d9d1f600c1142d4c21b8e/wedding.sol:wedding:transferFrom(address,address,uint256)","0x2e5fdddf58e8deda84211639d52119ceb0925871/TGMtoken.sol:TGMtoken:transferFrom(address,address,uint256)",5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
",0x7a8bbfcccb6b80579d5965aa8d4a4b2294ac166e/mkethToken.sol:TokenERC20:burn(uint256),0x7CF2e4469d48F3e414dF46cdd41A0E7286a7AFb0/PHDToken.sol:PHDToken:burn(uint256),5,5,1
"   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      if (a == 0) {
         return 0;
      }

      uint256 r = a * b;

      require(r / a == b);

      return r;
   }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x4A6e45Fd2F0F807e41800dBDe1679fe83d6Adaa6/ERC20Batch.sol:Math:mul(uint256,uint256)","0x3cbaf1d511adf5098511b5c5b39e1f1b506c1afe/XRT.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
","0x6fc2a418d752e4b26dc372ccd766696f9c462e30/HTG.sol:HTG:burnFrom(address,uint256)","0x5a8010f1ed9051ba5b5bf3f0f9d4c00223aba80b/NAIRADIGITALTETHER.sol:NAIRADIGITALTETHER:burnFrom(address,uint256)",4,4,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","0x5b3534a4fb3d870afea64f7c84b14825a679eb2e/SmartCripto.sol:BasicToken:transfer(address,uint256)","0x6fd1b41e9ffc477c6801a26f6f36de48746bee74/MainframeTokenDistribution.sol:BasicToken:transfer(address,uint256)",4,4,1
"    function sub(uint256 a, uint256 b) internal   returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x5d0e1a73ec9f0c5c13d43f8315674855ed2b3d4e/ERC20Token.sol:SafeMath:sub(uint256,uint256)","0x7da80ae9b8068a935d3bc942ec07a6e2b0199ae9/FOXtoken.sol:SafeMath:sub(uint256,uint256)",5,5,1
"	function allowance(address _owner, address _spender) constant returns (uint remaining) {
		return allowed[_owner][_spender];
	}
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1ce667f4318c5dbc9a0911b19d0d489cf7a81431/Rusal_cds_20221212_XIV.sol:Rusal_cds_20221212_XIV:allowance(address,address)","0x2fd80b9ac084b3d54ce302607ef403dfb18202c8/BitsumCash.sol:StandardToken:allowance(address,address)",4,4,1
"    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }
","  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }
",0x2c875e5ea4706b1978a41b59edf2d3af31d60e70/WavesEthereumSwap.sol:IncentCoffeeToken:onlyOwner(),0x2d6669c810bf1444d2e5e7f4cfc56a4c10cf7a2a/HYIPToken.sol:HYIPToken:onlyOwner(),5,5,1
"    function Bothereum(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x4f4e31d054d0328613deaa104f0a93d999742c27/Bothereum.sol:Bothereum:Bothereum(uint256,string,string)","0x4c4d11f7ec61d0cff19a80bb513695bf12177398/MicroMeGameCoin.sol:TokenERC20:TokenERC20(uint256,string,string)",4,4,1
"     function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x2c1180e2818069e5a9f911e636fb8f3db5106a9f/ERH.sol:StandardToken:balanceOf(address),0x1e7ec4f134432766bacbfbeb54c897458e58ac75/logisticstoken.sol:StandardToken:balanceOf(address),5,5,1
"    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }
","    function mul(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x7fbc0343f7a0bcd58c9dda254ec95642636d6333/SunriseCoin.sol:SafeMath:safeMult(uint256,uint256)","0x0df2f1b53ea0479952845f11d56efab3cd4eed97/LitecoinClassic.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:SafeMath:sub(uint256,uint256)","0x6D531BCe8755694aaF2E157747063Fcd917DEd7c/liyk002Token.sol:SafeMath:sub(uint256,uint256)",4,5,1
"  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
","  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
",0x4ef6ea200f5b5fe49421c03cb7690abedca5d685/OpiriaCrowdsale.sol:MintableToken:finishMinting(),0x0aa21ee67da833a203223e6d7fc04d3a119dcd95/CrowdsaleContract.sol:MintableToken:finishMinting(),1,3,1
"	function owned() public {
		owner = msg.sender;
	}
","    function Owned() public {
        owner = msg.sender;
    }
",0x1dfa4bb783b3aeea55b712b4acb4b7dd1a8fe928/ZodiaqPrivateTokenSale.sol:owned:owned(),0x8b6fec2a4f011ea1de89ff1d24a36efac15f04f4/Computer.sol:Owned:Owned(),4,4,1
"  function mul(uint256 a, uint256 b) constant public returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256)
  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x4ddb111812363e92d41e31fc3bfeee33fc7dba27/CABCoin.sol:SafeMath:mul(uint256,uint256)","0x1d464ac5e046e5fe280c9588edf8eb681b07008f/GMB.sol:safeMath:mul(uint256,uint256)",5,5,1
"    function balanceOf(address _owner) public view returns (uint balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x7b7b239e7fc2b4680f5cf469ecb968bd94bb38aa/CoSoundToken.sol:StandardToken:balanceOf(address),0x4e3bcc324af823460c07fa6998ee5caa418a67bf/AsiaCoin.sol:StandardToken:balanceOf(address),4,4,1
"	function approve(address spender, uint256 value)
		public
		returns (bool success)
	{
		allowance[msg.sender][spender] = value;
		emit Approval(msg.sender, spender, value);
		return true;
	}
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x7ec99babdda53507db164f643d9a8058095689bc/VOC_ethchf_393477_20180614.sol:VOC_ethchf_393477_20180614:approve(address,uint256)","0x3f35f8a62b67da6464e25895bff896004cbcc7a8/TuttoSulNeroToken.sol:StandardToken:approve(address,uint256)",1,3,1
"    function BlockChainZB(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function ICT(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x7c540fd1f0da5dab21024de3f3748625ac022a98/BlockChainZB.sol:BlockChainZB:BlockChainZB(uint256,string,string)","0x03ab65aa0a900e4df97ed8f3b316a261cef5affc/ICT.sol:ICT:ICT(uint256,string,string)",4,4,1
"  function approve(address _spender, uint256 _value) lockAffected returns (bool success) {
    allowances[msg.sender][_spender] = _value;        // Set allowance
    Approval(msg.sender, _spender, _value);           // Raise Approval event
    return true;
  }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x01b3ec4aae1b8729529beb4965f27d008788b0eb/DPPToken.sol:Token:approve(address,uint256)","0x01bd70a0cc118bca4c70624286488e8f3d78a10f/BitBill.sol:StandardToken:approve(address,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) {
        super.transfer(_to, _value);
    }
","  function transfer(
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transfer(_to, _value);
  }
","0x3a75a04e520252879589b8330b2f6832a1e63767/GiftFactory.sol:GiftToken:transfer(address,uint256)","0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:PausableToken:transfer(address,uint256)",4,4,1
"  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x0bc13a7b70f671122966dc2585e93217eb26cbac/TIM5.sol:SafeMath:safeMul(uint256,uint256)","0x6eB45f4775a353855D7af3252f10178A91610Fc1/Horiz0n.sol:SafeMath:mul(uint256,uint256)",1,1,0
"     function balanceOf(address _owner) constant returns (uint256 balance) {
         return balances[_owner];
     }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x1e8cc3c765c4adb887f2886b2fa0c7ea5ee5b5ba/MTB.sol:MTB:balanceOf(address),0x6d7f2957f4d485c6bf5f543f725d3405cb3afa94/Icoin.sol:StandardToken:balanceOf(address),5,5,1
"	function balanceOf(address _owner) constant returns (uint balance) {
		return balances[_owner];
	}
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x1b135b544f0a122b3426ef1f2c52cbf5fe4df2ff/Rusal_CIP_IV_20180621.sol:Rusal_CIP_IV_20180621:balanceOf(address),0x4d9412b6c12b2e2bf0da15416b71f33c846e635b/BIGLUV.sol:ERC23BasicToken:balanceOf(address),4,4,1
"    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }
",0x6ed8c49228397cbd0b62db04beaf0b7e9a4da93a/ETVRToken.sol:StandardToken:balanceOf(address),0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:balanceOf(address),5,5,1
"    function Owned() public {
        owner = msg.sender;
    }
","    function owned() public {
        owner = msg.sender;
    }
",0x1E5E3FD857aE39E2f05DCE9DB651a4929e6BFe2c/RocketFuelToken.sol:Owned:Owned(),0x4e6b294e9cbe702f76a34949cf1674961211e5fc/MSXAdvanced.sol:owned:owned(),4,4,1
"    	    modifier onlyOwner {
    	        require(owner == msg.sender);
    	        _;
    	    }
","    modifier onlyOwner {
        require(msg.sender == owner); _;
    }
",0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e/PerfectCoinControl.sol:owned:onlyOwner(),0x4c2e198cf5ee4ca4d6e9e0c1b2b954f9101c7fc1/GFCToken.sol:owned:onlyOwner(),5,5,1
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
",0x5b68a0d3e80020a54e85cdd457bc4ad8c49d8056/OctaBlock.sol:OctaBlock:withdrawForeignTokens(address),0x2cc40acbdd5c20273a0567b260b820aa21102291/Pheonix.sol:Pheonix:withdrawForeignTokens(address),5,5,1
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x7a3a93891a6f407fa8af8a6b3f3663571fba5646/MacQueenToken.sol:MacQueenToken:onlyOwner(),0x5fd9b734f0b75eecfea960985174837182782914/SEKCapitalToken.sol:Ownable:onlyOwner(),5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x3d3ed0a4f0af930955806b34367e7c64a0e1c84a/ASStokenICO.sol:ASStoken:approve(address,uint256)","0x7f0f620dbad4517de25f037bb3e81d144cbf5079/Rivercoin.sol:StandardToken:approve(address,uint256)",5,5,1
"  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x6fd1dada61f2d210a1e4e47b672f73bc851862f9/EestyCoinToken.sol:BasicToken:balanceOf(address),0x4bd52bbf57618e9ef39bc369537e36f0a841dd50/PigChain.sol:StandardToken:balanceOf(address),5,5,1
"    function approve(address _spender, uint256 _value) public returns(bool) {
        allowances[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x8c191e7ba46b733819992d4AdddEf6a2fa45a864/LSC.sol:LSC:approve(address,uint256)","0x6c541450d0942c99e043e9df791414b34637a8e1/IagonToken.sol:StandardToken:approve(address,uint256)",4,4,1
"    function allowance(address _owner, address _spender)
    view public returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x3b23b5ea839de0e1c761ddd89818f96025b7c0d3/UCASH.sol:UCASH:allowance(address,address)","0x3d12d60d6dc999adbe3c9eecfbd626004e7f2350/FMGHEALTHCARE.sol:FMGStandardToken:allowance(address,address)",5,5,1
"    function decreaseApproval(address _spender, uint256 _subtractedValue) whenNotPaused public returns (bool) {
        uint256 oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x3ea949ab64b8828981e1c4777d922ab96ec1ab05/GSENetwork.sol:StandardToken:decreaseApproval(address,uint256)","0x06dafc2a5fe47fcc9f37b5f91c0c2bd1cf2a9a4c/FlypCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x4a4293817ab21469b2430e8d5e169d9904233af3/MGUToken.sol:MGUToken:approve(address,uint256)","0x6cae9ba490d4ecced907b7bc311b81b266a8020e/DRAKE.sol:DRAKE:approve(address,uint256)",5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
      assert(x >= y);
      uint256 z = x - y;
      return z;
    }
","0x1f0480a66883de97d2b054929252aae8f664c15c/NePay.sol:SafeMath:add(uint256,uint256)","0x0D8775F648430679A709E98d2b0Cb6250d2887EF/BAToken.sol:SafeMath:safeSubtract(uint256,uint256)",4,4,1
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x3c1999d19401469693cb8d8acd14fd3aec34dd15/GoogleChainToken.sol:Ownable:transferOwnership(address),0x521ce45db5b39bd758afb43e5c10ce1d72730c84/RAMToken.sol:Ownable:transferOwnership(address),4,4,1
"	function balanceOf(address _owner) constant returns (uint256 balance) {
	    return balances[_owner];
	}
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x6a27778baa415f9086ba0703c7a9c6cde0d46f2b/XtremcoinToken.sol:XtremcoinToken:balanceOf(address),0x4a220e6096b25eadb88358cb44068a3248254675/StandardToken.sol:BasicToken:balanceOf(address),5,5,1
"	function sub(uint256 a, uint256 b) internal constant returns (uint256) {
		assert(b <= a);
		return a - b;
	}
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x1Ebc56Ecc8Dfe6da43b86C39eFe9388ceb8c7C50/TestToken.sol:SafeMath:sub(uint256,uint256)","0x6dea22360fc88bf22e8393c20f520c78ea6edbad/ByThePeople.sol:SafeMath:sub(uint256,uint256)",5,5,1
"  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {
    require(_beneficiary != address(0));
    require(_cliff <= _duration);
    beneficiary = _beneficiary;
    revocable = _revocable;
    duration = _duration;
    cliff = _start.add(_cliff);
    start = _start;
  }
","  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {
    require(_beneficiary != address(0));
    require(_cliff <= _duration);

    beneficiary = _beneficiary;
    revocable = _revocable;
    duration = _duration;
    cliff = _start.add(_cliff);
    start = _start;
  }
","0x06d191c4bc47138d5d79eb881deea86c93e6603b/ShortVesting.sol:TokenVesting:TokenVesting(address,uint256,uint256,uint256,bool)","0x1d4ccc31dab6ea20f461d329a0562c1c58412515/TalaoToken.sol:TokenVesting:TokenVesting(address,uint256,uint256,uint256,bool)",5,5,1
"    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
      public
      returns (bool)
    {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(transfersEnabled);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","0x2f5e078353e781ef9a9b17c2e8e30d3652d6cb83/GoldenUnionCrowdsale.sol:StandardToken:transferFrom(address,address,uint256)","0x6cfba3c7b4c944bdc9442c91d67d35d7c27fa430/OrphanToken.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
	return allowed[_owner][_spender];

}
","0x0be8d3261cd699fc5ae124b3f8d38d568fd461b5/Etx.sol:Etx:allowance(address,address)","0x3edd235c3e840c1f29286b2e39370a255c7b6fdb/CMBToken.sol:CMBToken:allowance(address,address)",5,5,1
"  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0d30598f68e75574a6285f62eb5d7658bd62bd8b/SCAVOToken.sol:StandardToken:increaseApproval(address,uint256)","0x5b2fba919f7ccd6db0edc58adbc785c189c4ee1c/DBCC.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) {
        _transfer(msg.sender, _to, _value);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x0a2a94Ded0b8C9cB3BD4Ec2ef86eeEE637A4Db7C/EthConnect.sol:EthConnect:transfer(address,uint256)","0x6a291d52cdb5c2afc575b0d98fe79bc2d7b08f34/DPToken.sol:DPToken:transfer(address,uint256)",5,5,1
" function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x7f585b9130c64e9e9f470b618a7badd03d79ca7e/CR7Coin.sol:StandardToken:approve(address,uint256)","0x2f7b4b11001e3c8c544ec00a129b4afd90a662cf/XpressPresale.sol:StandardToken:approve(address,uint256)",5,5,1
"    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
","    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
","0x1b69cd0f0ef8f13e13e32328dc1db9e1128ea358/Evernal.sol:SafeMath:min256(uint256,uint256)","0x01b840bc3f9243733d5ae3f3ca61ca0587073bf4/GNCCrowdsale.sol:SafeMath:min256(uint256,uint256)",5,5,1
"	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
		return allowed[_owner][_spender];
	}
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x3af803136acf303075bf7374e0e5f5b500b6162b/METADOLLAR.sol:METADOLLAR:allowance(address,address)","0x0ec6bbb00e3df05b1ef99dd87a4c14db9966fc7b/FansCoin.sol:FANSStandardToken:allowance(address,address)",5,5,1
"    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        owner = newOwner;
    }
","  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
",0x5a5b5018f1423bdaeb281144412f763a379806c6/TestCrypteriumToken.sol:Ownable:transferOwnership(address),0x6c5208924c5b302f756a79776a8b2918a041ad4d/Airdropper.sol:Ownable:transferOwnership(address),4,4,1
"    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
",0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c/TrekChain.sol:TrekChain:balanceOf(address),0x0ccf3426755c88f85445e325f6f0f413e3375b49/AifiToken.sol:BasicToken:balanceOf(address),5,5,1
"    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
",0x7c3e0b97c050b32fc1127096537b6c77230d21fe/RoyalPanties.sol:owned:transferOwnership(address),0x5d61ea81c6142afb4c101e55c08f938ddd7c46e8/Dashicoin.sol:owned:transferOwnership(address),5,5,1
"	modifier	onlyOwner	() {
		require(msg.sender ==		owner	);
		_;
	}
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:onlyOwner(),0x3e41e76d7b7cb54365317c7e7f1f411d59744922/FixedSupplyToken.sol:Owned:onlyOwner(),5,5,1
"    modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x2ef06079656f2ab9034b6252978c44104b7b2cc1/OOST.sol:Ownable:onlyOwner(),0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:Ownable:onlyOwner(),5,5,1
"   function approve (address _spender, uint256 _value) returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    emit Approval (msg.sender, _spender, _value);
    return true;
  }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5b47180e5f07fb5e10f86761df0c34ce952c6974/VICToken.sol:AbstractToken:approve(address,uint256)","0x02fb7aefda436d5632e796ef49a607e4e3cdd342/SeleniumRichChain.sol:StandardToken:approve(address,uint256)",4,4,1
"	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
		return allowed[_owner][_spender];
	}
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6bd992c2f23cf9ae324f76614ec2ac5541008601/TradeNetCoin.sol:StandardToken:allowance(address,address)","0x4b7f293387ad7f77184875f00a758d2ad5245ec2/PayIreward.sol:StandardToken:allowance(address,address)",5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
	uint256 c = a + b;
	assert(c >= a);
	return c;
  }
","  function add(uint a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:SafeMath:add(uint256,uint256)","0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8/Bitsense.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x1c50b392c0327b80332d0a83a7efc0303e77afbd/KdogToken.sol:StandardToken:balanceOf(address),0x5ce146bd472fc026d227731282ec095597ac26a3/MAGMA.sol:StandardToken:balanceOf(address),5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","0x2e5fdddf58e8deda84211639d52119ceb0925871/TGMtoken.sol:TGMtoken:transfer(address,uint256)","0x0e32d4c9581ebffbdf5d920cc2252f379b88d562/MetadollarCrw.sol:MetadollarCrw:transfer(address,uint256)",5,5,1
"  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x5cdca0827af110c8958efcf737789a23380aa269/SCALAToken.sol:StandardToken:allowance(address,address)","0x6a85f717aaa16a9050858be9415eb213dfc1957a/XpressToken.sol:StandardToken:allowance(address,address)",5,5,1
"    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x1ea976a4abbdbcc67d9b4fd6d5dba23618fb52fd/Aecium.sol:SafeMath:sub(uint256,uint256)","0x4b5da69c6289bd71d643710d0a63bd4867808451/PaoToken.sol:SafeMath:sub(uint256,uint256)",4,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
	// assert(b > 0); // Solidity automatically throws when dividing by 0
	uint256 c = a / b;
	// assert(a == b * c + a % b); // There is no case in which this doesn't hold
	return c;
  }
","    function div(uint256 a, uint256 b) internal returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:SafeMath:div(uint256,uint256)","0x7df61c9ceb2cc77213554ebf90cafe7258b4d094/MoonLotteryToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function BEB(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address holder
        )  public{
        balanceOf[holder] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
		owner = msg.sender;
    }
","    function Quadum(
    uint256 initialSupply,
    string tokenName,
    uint8 decimalUnits,
    string tokenSymbol
    ) {
        balanceOf[msg.sender] = initialSupply;
        // Give the creator all initial tokens
        totalSupply = initialSupply;
        // Update total supply
        name = tokenName;
        // Set the name for display purposes
        symbol = tokenSymbol;
        // Set the symbol for display purposes
        decimals = decimalUnits;
        // Amount of decimals for display purposes

        owner=msg.sender;
    }
","0x3fc39066ba6e199514ce2ad6abf45b8ab4a83599/BEB.sol:BEB:BEB(uint256,string,uint8,string,address)","0x7fdb1095f5e126dc7b0d9084997ff32ce69de23e/Quadum.sol:Quadum:Quadum(uint256,string,uint8,string)",4,4,1
"    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","0x2e9f2a3c66ffd47163b362987765fd8857b1f3f9/AZTToken.sol:AZTToken:mintToken(address,uint256)","0x4a0b4540317d156d89a8465041569ad68102d6cd/TTC.sol:TTC:mintToken(address,uint256)",5,5,1
"    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b; require(a == 0 || c / a == b); }
","  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x0bef619cf38cf0c22967289b8419720fbd1db9f7/AENToken.sol:SafeMath:mul(uint256,uint256)","0x3dd2ecaa49df3306c1332d2b858dfe8268314a5c/DigiassetzToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {

        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;

        } else {

            return false;

        }

    }
","    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x0e05e9dafba305198c9f1b7b5de0da98b4d4da87/ThreadToken.sol:StandardToken:transfer(address,uint256)","0x0d7613cd6b6681928ade30c4fd3ebcc2c2f68621/BAHT.sol:StandardToken:transfer(address,uint256)",5,5,1
"    function Ownable() {
        owner = msg.sender;
    }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x4b4e611823702285fd526d7a8a3b0aa99ab2dbcd/HDLToken.sol:Ownable:Ownable(),0x0e98db51010dd1ade14dd3fb164e218805fdba1b/TetherToken.sol:Ownable:Ownable(),5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
    //if token supply was not limited then we would prevent wrap:
    //if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to])
    if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && _value > 0) {
      balances[_from] -= _value;
      balances[_to] += _value;
      approvals[_from][msg.sender] -= _value;
      TransferEvent(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }
","0x0b7c88344be0fbd1eb765d33c89f234ca1b87063/Coinnec.sol:StandardToken:transferFrom(address,address,uint256)","0x0edde4b6f91dbd2efd075ace85ec2e52d0696d44/BurnableToken.sol:BurnableToken:transferFrom(address,address,uint256)",4,4,1
"    function balanceOf(address _owner) constant returns (uint256 balance)
    {
        return balances[_owner];
    }
","  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x7f1f1e95b243708aa29cfba53e13d45e28356d2b/Megawttcoin.sol:ERC20Token:balanceOf(address),0x1bffa323d25ce1b2709d4d346b3a4670faa948c7/StarsICO.sol:BasicToken:balanceOf(address),5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x3f17af8d4e950ecce6f24bfaf0e43a56d8fb3491/PrayersTokenICO.sol:PrayersTokenICO:allowance(address,address)","0x1b5ed05690a6b04533f09185afe03ff2371835c2/RainbowUnicoin.sol:RainbowUnicoin:allowance(address,address)",5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x5ab793e36070f0fac928ea15826b0c1bc5365119/YUKI.sol:YUKI:approve(address,uint256)","0x4d73a6a5698990a01b6e526b73fceb0efbbfd159/FAFA.sol:FAFA:approve(address,uint256)",1,2,1
"    function allowance(address _owner, address _spender) constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x3cf6f11a4940dd8bf2e6eea46e30d8f76fa84daf/TonCoin.sol:StandardToken:allowance(address,address)","0x2bccafd4b16b404eeb359a56cf97b7a755833160/GDX.sol:StandardToken:allowance(address,address)",4,4,1
"        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x1b09cd594ddeaa336564dd24fe6ef43688f27c62/Crystals.sol:owned:onlyOwner(),0x4a0b4540317d156d89a8465041569ad68102d6cd/TTC.sol:owned:onlyOwner(),5,5,1
"  modifier whenNotPaused() {
      require(!paused);
    _;
  }
","    modifier whenNotPaused() {
        require(!paused);
        _;
    }
",0x06c9b941f1895e89ec7459975a71d29f2f1456ba/DatumTokenDistributor.sol:Pausable:whenNotPaused(),0x7F5a7A6A25E06dDc94901cF596f9234f7D190BED/TokenImpl.sol:Pausable:whenNotPaused(),5,5,1
"	function transfer(address _to, uint256 _value) public {
		_transfer(msg.sender, _to, _value);
	}
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x1a55ae1553e5f41966fd8a204422e379713d1d24/VVToken.sol:VVToken:transfer(address,uint256)","0x6acdcf901d98a13448b2801cc661433956d68008/DatGirl.sol:DatGirl:transfer(address,uint256)",5,5,1
"  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x2a47e3c69deaae8dbdc5ee272d1a3c0f9853dcbd/MoyToken.sol:StandardToken:decreaseApproval(address,uint256)","0x04cd5f369825c0b2ae1e7a6e8559734f6080fbb5/MobiCoin.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {
        uint256 z = _x * _y;
        assert(_x == 0 || z / _x == _y);
        return z;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","0x5bb5b32cb114c7f558a3f5b0933dcfa74be9611a/KickcityCrowdsale.sol:Utils:safeMul(uint256,uint256)","0x8b8aaf37e44e87cc1285a822c767104b28dc0d58/AirDropContract.sol:SafeMath:mul(uint256,uint256)",4,4,1
"	modifier onlyOwner
	{
		require(msg.sender == owner);
		_;
	}
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x4b85c711a3ae361c965bd3e606bd64b307346512/Gamblica.sol:owned:onlyOwner(),0x1a85180ce3012e7715b913dd585afdf1a10f3025/PajCoin223.sol:Ownable:onlyOwner(),5,5,1
"    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6e0327f5e4f3a97123e8bda6e4ef063d32a96e9a/B_Com.sol:B_CommerceCoin:allowance(address,address)","0x6f1e8ceeda88dc15f00ee36533d932f88b9bd40e/Elemental.sol:ElementalToken:allowance(address,address)",5,5,1
"  function balanceOf(address _owner) constant public returns (uint256 balance) {
    return balances[_owner];
  }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
",0x7e8bae58a61805858186d6ff869c36a8162db3c0/TBCoin.sol:StandardToken:balanceOf(address),0x7c333b69021b3ad9288d3b0083f9bd27c6d4680a/TokenImpl.sol:BasicToken:balanceOf(address),5,5,1
"      modifier onlyOwner() {
        require(msg.sender == owner);
        _;
      }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x3f8d47619d132577260fd6db8d665d0a9d37c579/DAOToken.sol:Ownable:onlyOwner(),0x3fe8a1cdbb598f2c9169fd0a216607b4dcb09888/LamdenTau.sol:Ownable:onlyOwner(),5,5,1
"	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
		require(_to != address(0));
		require(_value <= balances[_from]);
		require(_value <= allowed[_from][msg.sender]);

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		Transfer(_from, _to, _value);
		return true;
	}
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x01ff50f8b7f74e4f00580d9596cd3d0d6d6e326f/BftToken.sol:StandardToken:transferFrom(address,address,uint256)","0x2dace13a49efa79dc528d3eb9c98a3c3b0feb61b/NamaheToken.sol:StandardToken:transferFrom(address,address,uint256)",5,5,1
"  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x5a1052df3453f4ea214bcde955dac14c3ffb7057/WZCoinToken.sol:StandardToken:allowance(address,address)","0x6b279f9ef6047a21052b5563fd249fe0fdaa7e58/TokenImpl.sol:StandardToken:allowance(address,address)",5,5,1
"  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
","    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
",0x4c567c3363cc42c5a42c6d8bf01503fd1d0b91cd/ElementhToken.sol:MintableToken:finishMinting(),0x0a78dc8fe765ab979df1fb202bef47166647696c/KUYOOToken.sol:MintableToken:finishMinting(),5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if (!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) {throw;}
        return true;
    }
","0x5ab1454b60ef27712e5a413214375ce4529a26d5/AglassCommunityLearning.sol:AglassCommunityLearning:approveAndCall(address,uint256,bytes)","0x4a3bf69d05de3dad67ca8f2ff4cff4f482b714b4/BieberToken.sol:BieberToken:approveAndCall(address,uint256,bytes)",4,4,1
" function transferOwnership(address newOwner) public onlyOwner {
   require(newOwner != address(0));
   emit OwnershipTransferred(owner, newOwner);
   owner = newOwner;
 }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd/TokenLoot.sol:Ownable:transferOwnership(address),0x4a1c2a1cc36afd0f343be1fbc53a14354c488f7f/currencycoin.sol:Ownable:transferOwnership(address),4,4,1
"function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);

balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
return true;
}
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x7cd1b0d0b8b52969fa0ea961cec7c6ec5e06ddb6/BlueHillMining.sol:StandardToken:transferFrom(address,address,uint256)","0x4cdee773fd90f91e98b7d33db5c12376deee3b08/NEBC.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    owner = newOwner;
  }
",0x4eb57a7a1b210835b4b1a05b74c3c25f27b4b385/PrivatePlacement.sol:Ownable:transferOwnership(address),0x7d44f43c4c1d4f3e2db9a0aa1af4305b6608a130/ColorsMain.sol:Ownable:transferOwnership(address),5,5,1
"	modifier onlyOwner{
		require(msg.sender == owner);
		_;
	}
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993/ProfytPro.sol:Owned:onlyOwner(),0x6d6f2b17f909c5307d5567126e002f2d7bef1e2f/AFROIN.sol:Owned:onlyOwner(),5,5,1
"     modifier onlyOwner {
         require(msg.sender == owner);
         _;
     }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x1ddfbb6b12e12d8a5cd439406d9db9903efe017e/WFchainToken.sol:Owned:onlyOwner(),0x3af70f8772fadd33b18eb1bdf9475ea727817391/ReferToken.sol:Ownable:onlyOwner(),5,5,1
"    function Owned() public {
        Owner = msg.sender;
    }
","function Owned() public {
owner = msg.sender;
 }
",0x3b2ea02e38af82d5b0874125f045c55c3e907677/BEAT.sol:Owned:Owned(),0x6f65dd1f39650a7c11e0d4cdbec183a17e7a71ce/BALVINDER.sol:Owned:Owned(),4,4,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:StandardToken:allowance(address,address)","0x7ab4aac9cbe01e4553b2018204c8ddfe864aaa12/A2UToken.sol:StandardToken:allowance(address,address)",5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval (msg.sender, _spender, _value);
        return true;
    }
","	function approve(address _spender, uint _value) returns (bool success) {
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
	}
","0x2c3b9d47f9a80507e93c9401eb22e111672604a3/JCoinz.sol:JCoinz:approve(address,uint256)","0x1dccbb30991632907f59530b3e10d86ad71973f9/Rusal_TCI_VI_20181220.sol:Rusal_TCI_VI_20181220:approve(address,uint256)",4,4,1
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = (
        allowed[msg.sender][_spender].add(_addedValue));
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0a9e4971e17b1aeb8273d412fdae9a566b98bb70/SEMToken.sol:StandardToken:increaseApproval(address,uint256)","0x6be61833FC4381990e82D7D4a9F4c9B3F67eA941/HTB.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"	function approve(address _spender, uint _value) returns (bool success) {
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
	}
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x3f9705be93b5cd5e7ba81764bb45effb61b3b7f9/EuroSibEnergo_TCI_VI_20181220.sol:EuroSibEnergo_TCI_VI_20181220:approve(address,uint256)","0x1dc3fc96b218b4ac9d36193f3325d949f9ed3a26/ETYCToken.sol:StandardToken:approve(address,uint256)",4,4,1
"  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x3d3583a1532c16f589026852461d56cef74e5cc2/AccountLevels.sol:SafeMath:safeMul(uint256,uint256)","0x3c75226555fc496168d48b88df83b95f16771f37/DroplexToken.sol:SafeMath:safeMul(uint256,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x2f78b42438696c2feb4c5fcc316b23972c5045b2/MongoCoin.sol:StandardToken:transfer(address,uint256)","0x1a63138ba26440baeb7adfa96bad94ee483005bb/LATokenMinter.sol:StandardToken:transfer(address,uint256)",4,4,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x2b83d02bc05d224025c1244889e708a2dd0bad47/GLXToken.sol:GLXToken:approve(address,uint256)","0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:AndhraToken:approve(address,uint256)",4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        require(_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","0x7f62ffa6b311b5cedec75e198b0d2f0ed3acf3a0/EROSCOIN.sol:EROSCOIN:approveAndCall(address,uint256,bytes)","0x0cb5e8d11e1b57feecf846335d99ed8267e60098/DEFACTO.sol:DEFACTO:approveAndCall(address,uint256,bytes)",4,4,1
"  function div(uint256 a, uint256 b) constant public returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }
","0x4ddb111812363e92d41e31fc3bfeee33fc7dba27/CABCoin.sol:SafeMath:div(uint256,uint256)","0x7a7f2a4550841258a516d71a90c28c97a529a66a/Omnic.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x2c176aa3691ef507ff63bac477024593b1f05d1f/AvtcToken.sol:SafeMath:safeDiv(uint256,uint256)","0x4ee697e33d72bce48c2170bfc009d801933fcb10/BOND.sol:SafeMath:safeDiv(uint256,uint256)",5,5,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x1a231df765d0f7674f55d20d022bcb38da794501/NovaChain.sol:SafeMath:div(uint256,uint256)","0x3f1049f556cf2d0b0c9552823e722a363bc76f0d/OBOCOIN.sol:SafeMath:div(uint256,uint256)",5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x5fed01f08b6c17c3d985481dc8f8e5c1105a60d1/AAToken.sol:StandardToken:decreaseApproval(address,uint256)","0x7d3d1185ac96a0e5b5260511a73a9e1695d7eae7/HabibiCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
","0x2dc0170450e66af2d3f5c56aa0b20ec4a254902e/MyAdvancedToken.sol:MyAdvancedToken:freezeAccount(address,bool)","0x6dceb0027a9e92ddfccc09a00d0779d3c1e2a8b7/NetkillerAdvancedToken.sol:NetkillerAdvancedToken:freezeAccount(address,bool)",4,4,1
"  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1ED779c9BdFBAc63445846e0f0C75A983a5916E6/BetOnCryptToken.sol:StandardToken:allowance(address,address)","0x7af254faa2c4cda1b829f1efb067c580e97792fe/Blizzard.sol:StandardToken:allowance(address,address)",5,5,1
"     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
       return allowed[_owner][_spender];
     }
","  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","0x5be015eb0be828742b1e9ff9f784ea51e540b6e8/LooksCoin.sol:StandardToken:allowance(address,address)","0x4a65fe2a50882e2411c6d177583f8a00eee2c95a/FRNCoin.sol:StandardToken:allowance(address,address)",4,4,1
"    function approve(address _spender, uint256 _value) public returns (bool) {
        //NOTE: To prevent attack vectors like the one discussed here:
        //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729,
        //clients SHOULD make sure to create user interfaces in such a way
        //that they set the allowance first to 0 before setting it to another value for the same spender.

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3/BWCToken.sol:BWCToken:approve(address,uint256)","0x8a619b19e85e264770eb67dbdbcaf0daa9158a6c/OD1Coin.sol:StandardToken:approve(address,uint256)",5,5,1
"  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x4eefc1fc753fc09bf78dc19291372ab5efa23356/GEM.sol:SafeMath:sub(uint256,uint256)","0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:SafeMath:sub(uint256,uint256)",5,5,1
"  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
","  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:StandardToken:balanceOf(address),0x4b3fd993d62ea03614a597d1b658f74a3fbcfaa8/Oduwa.sol:BasicToken:balanceOf(address),4,4,1
"    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x2a47f802064caf5a5e78ee193723dc2c7cfc06e9/Moolyacoin.sol:BasicToken:totalSupply(),0x6cc1a7ccff4bb1164df06ff1c44a256de5214fb9/U24Y.sol:BasicToken:totalSupply(),5,5,1
"    modifier onlyOwner() {
      require(msg.sender == owner);
      _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x5d41106d9088f968f6fdc376bec83451420c356f/Fish.sol:owned:onlyOwner(),0x3b07a0f3a9dee1144532fca548bf31afaeba0290/OSNToken.sol:Ownable:onlyOwner(),5,5,1
"	function balanceOf(address _owner) constant returns (uint balance) {
		return balances[_owner];
	}
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x0adcae90088fae1007555733b4d3d63f24f4a2a3/Whales.sol:ERC20Standard:balanceOf(address),0x1cff439e724fa1690d5b346ddedb3ed55013aad4/GBIT.sol:StandardToken:balanceOf(address),4,4,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x04a5122698adf47ae0cdd0a10274742797684d44/StudentHelper.sol:Ownable:onlyOwner(),0x3a3629390cef79b01fc4090abb26818d1759aefc/Datastore.sol:Ownable:onlyOwner(),5,5,1
"	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a / b;
		return c;
	}
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x05D3fc6C7265A4e9223273E905866d4CdAff057f/BitboseICO.sol:SafeMath:div(uint256,uint256)","0x5ea08f55f6924f110905c08a7a5db88ba64af803/INVToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"  function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
    require(_spender != address(this));

    super.increaseApproval(_spender, _addedValue);

    // solium-disable-next-line security/no-call-value
    require(_spender.call.value(msg.value)(_data));

    return true;
  }
","  function increaseApprovalAndCall(
    address _spender,
    uint _addedValue,
    bytes _data
  )
    public
    payable
    returns (bool)
  {
    require(_spender != address(this));

    super.increaseApproval(_spender, _addedValue);

    // solium-disable-next-line security/no-call-value
    require(_spender.call.value(msg.value)(_data));

    return true;
  }
","0x2f55045439c0361ac971686e06d5b698952f89c1/EDUCrowdsale.sol:ERC827Token:increaseApprovalAndCall(address,uint256,bytes)","0x5b78fd6f5e8ea497534dd205e58daa51d26eded2/BITXDistributionTools.sol:ERC827Token:increaseApprovalAndCall(address,uint256,bytes)",5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x1a63138ba26440baeb7adfa96bad94ee483005bb/LATokenMinter.sol:StandardToken:transfer(address,uint256)","0x7f121d4ec6c2c07eb6bc7989d91d2d4ff654c068/CoinMeet.sol:StandardToken:transfer(address,uint256)",5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b <= a);
		return a - b;
	}
","0x1dC211ED642733Da8BADeEd7d529E9b67295593b/ergo.sol:SafeMath:sub(uint256,uint256)","0x6acd16200a2a046bf207d1b263202ec1a75a7d51/dappVolumeHearts.sol:SafeMath:sub(uint256,uint256)",5,5,1
"    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x0ee6071bc209c19161f6d17f8597d762b4d30806/CFL.sol:Ownable:transferOwnership(address),0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:Academicon:transferOwnership(address),5,5,1
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x02c06fb43f418e142666e4a80526d23cd2eae367/NooToken.sol:BasicToken:balanceOf(address),0x2ee3b3804f695355ddc4f8e1c54654416d7ee95a/Blocform.sol:BasicToken:balanceOf(address),5,5,1
"  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
","  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
","0x0b5cba1bc5ec084e82fadc4e2c3a43a94660b6c4/GlobalBusinessSystem.sol:ReleasableToken:setTransferAgent(address,bool)","0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:ReleasableToken:setTransferAgent(address,bool)",5,5,1
"    function allowance(address _owner, address _spender) external view returns (uint256) {
        return allowed[_owner][_spender];
    }
","  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
","0x0a8c316420f8d27812beae70faa42f0522c868b1/WAVEliteToken.sol:WAVEliteToken:allowance(address,address)","0x6f2057f83c05378f22a15b72a424367cb40abc1b/TokenCSR.sol:StandardToken:allowance(address,address)",5,5,1
"    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x5caae332dd0a17827052de681f6f2155e00394f0/SharkToken.sol:SafeMath:div(uint256,uint256)","0x5ab14c104ba2771fd2a6ec6f616da1ad41d5b8a7/JincorToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
","    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","0x07b68Fa5Dfe8c0B23f044F4FF504e7b475e86b56/OceanScapeCoin.sol:OceanScapeCoinAdv:freezeAccount(address,bool)","0x6c6ff5213433510c91c65787dcf604bb2dc37c19/x32323.sol:x32323:freezeAccount(address,bool)",4,4,1
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    if ((a == 0) || (c / a == b)) {
      return c;
    }
    revert();
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x2BdcD9AE2bE26d3324eF75BcF64B3cc246302754/EtalonTokenPresale.sol:SafeMath:mul(uint256,uint256)","0x5f59f4828d5d3501f1ce87539589436f1023a617/KittyMeetsWorld.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x6ed8c49228397cbd0b62db04beaf0b7e9a4da93a/ETVRToken.sol:StandardToken:increaseApproval(address,uint256)","0x5df451ed892a40030078b887d0a4febde4c8f0a9/OrganTree.sol:StandardToken:increaseApproval(address,uint256)",5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","0x4f1d24f8d60b1f8872abbd409e6bfaa54d7a9f40/CTCToken.sol:StandardToken:increaseApproval(address,uint256)","0x6f80d952ee3ccd5eb1630e3a26f74f0e178f7e91/RicoToken.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x6b3b198577e9a1e96ef681ee60e551845dd4ea79/Detonator.sol:Detonator:onlyOwner(),0x4ee18f80c4c6e1e7ecb32f2fb6393486924679ac/Etheriumhit.sol:Ownable:onlyOwner(),5,5,1
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x2c745664fb4e9528fb32487d834e4aacfff1f027/BitexToken.sol:Ownable:transferOwnership(address),0x5e1cdd970e60dce16ced2645f5fb71cfd22080cf/TokenPaymentGateway.sol:Ownable:transferOwnership(address),4,4,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","  function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
    allowed[msg.sender][spender] = tokens;
    emit Approval(msg.sender, spender, tokens);
    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
    return true;
  }
","0x4ec0a558bc3c0f640119fb2944d98de805a26803/MIS.sol:MIS:approveAndCall(address,uint256,bytes)","0x5bbd34e9f11f673d60c90abbf8256ec85aaba2df/CareKoreaToken.sol:CareKoreaToken:approveAndCall(address,uint256,bytes)",4,4,1
"    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x6c52b059348d5ba7ec0959389163fe0634b85b04/LhsToken.sol:LhsToken:balanceOf(address),0x1Aa699889C0D9bADe50391D314cce3EA4a5285CE/FlatEarthProof.sol:StandardToken:balanceOf(address),5,5,1
"    function mul(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x06d8bA8Da81A60AB4254fd04c34e3F8D38e5CB71/EthereumRed.sol:SafeMath:mul(uint256,uint256)","0x0af44e2784637218dd1d32a322d44e603a8f0c6a/MatryxToken.sol:SafeMath:mul(uint256,uint256)",5,5,1
"   function approve(address _spender, uint256 _value) public returns (bool) {
     allowed[msg.sender][_spender] = _value;
     Approval(msg.sender, _spender, _value);
     return true;
   }
","	function approve(address spender, uint256 value)
		public
		returns (bool success)
	{
		allowance[msg.sender][spender] = value;
		emit Approval(msg.sender, spender, value);
		return true;
	}
","0x4E75BA0F03f62De979169f776951f911942be10A/STLToken.sol:STLToken:approve(address,uint256)","0x4ed88a8ebc9fd22fc0233500b7ef11e9aedfa665/RusalCdsTok20221212V.sol:RusalCdsTok20221212V:approve(address,uint256)",2,2,1
"	modifier	onlyOwner	() {
		require(msg.sender ==		owner	);
		_;
	}
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x1b135b544f0a122b3426ef1f2c52cbf5fe4df2ff/Rusal_CIP_IV_20180621.sol:Ownable:onlyOwner(),0x05d3f719b45866da98059436a4baa33596bf2ad0/ArnaToken.sol:Ownable:onlyOwner(),5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;   } else { return false; } }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x2d22594a442d6e6d5e96119e6361979a473098e3/GXY.sol:StandardToken:transfer(address,uint256)","0x5fb05fffe4be327ab88dacd6ee61e60ddc8958ae/BlackGarlic.sol:StandardToken:transfer(address,uint256)",5,5,1
"    function TPIToken () public {
        balanceOf[msg.sender] = totalSupply;
    }
","    function XDToken(
    ) public {
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
    }
",0x8c8ccb81d436b0f3017664441c39cbefbd64650f/TPIToken.sol:TPIToken:TPIToken(),0x5F9d86fa0454fFD6a59cCc485e689B0a832313DB/XDToken.sol:XDToken:XDToken(),4,4,1
"    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1c4f85e7bbddf3ee92e2999c63a7b85d64d57663/MultiToken.sol:MultiToken:decreaseApproval(address,uint256)","0x7c35b9cab8657623e3fd499ae3e00554fa05ce84/TTMToken.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"    function decreaseApproval(
        address _spender,
        uint _subtractedValue
    )
      public
      returns (bool)
    {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][spender];
        if (subtractedValue > oldValue) {
            allowed[msg.sender][spender] = 0;
        } else {
            allowed[msg.sender][spender] = oldValue.sub(subtractedValue);
        }
        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
        return true;
    }
","0x2f5e078353e781ef9a9b17c2e8e30d3652d6cb83/GoldenUnionCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)","0x1c2de9c9fd19a4de38d8bf2b98369c45ccf09048/CityLifePlusToken.sol:CityLifePlusToken:decreaseApproval(address,uint256)",4,4,1
"	function balanceOf(address _owner) public constant returns (uint balance) {
		return balances[_owner];
	}
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x1Ebc56Ecc8Dfe6da43b86C39eFe9388ceb8c7C50/TestToken.sol:ERC20Token:balanceOf(address),0x6df2f312355e6a500d501a0b7613aeac62d6408e/sBitcoin.sol:StandardToken:balanceOf(address),4,4,1
"    modifier whenNotPaused() {
        require(!paused);
        _;
    }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x5dbd2e33f4aceeefba9d7d542913ba3e82216b7b/MonsterCore.sol:MonsterAccessControl:whenNotPaused(),0x7ca5a1730d94c813905c5c31b6fd27131a8869ff/EVXTestToken.sol:Pausable:whenNotPaused(),5,5,1
"    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","0x5d385bedbc17a34c005f868a2103aa906c38d5da/Ixellion.sol:SafeMath:safeSub(uint256,uint256)","0x2d7d873f68d9ab1c13836c86d2cc2e929d072922/HedgeCoinCapitalToken.sol:SafeMath:safeSub(uint256,uint256)",5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:ERC20Token:approve(address,uint256)","0x6A5cc07F2d61E3480b0CD80d2f9246b35f2109F4/VirtualRealityChain.sol:StandardToken:approve(address,uint256)",5,5,1
"      function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
      }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:SafeMath:add(uint256,uint256)","0x4d829f8c92a6691c56300d020c9e0db984cfe2ba/CoinCrowdToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function allowance(address _owner, address _spender) constant public returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x6e939629f97cdadf6d6d2f3f1d675383e0046039/DatumTokenDistributor.sol:StandardToken:allowance(address,address)","0x1f67f06f949a912973ee75086f56b5d2478987b0/ERC20token.sol:ERC20token:allowance(address,address)",4,4,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4d73a6a5698990a01b6e526b73fceb0efbbfd159/FAFA.sol:FAFA:increaseApproval(address,uint256)","0x7f44d8a9db0b5a368d7ac9d69c93c1c8a3698fc1/BITMONEY.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        //Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5/DYLC_ERC20Token.sol:DYLC_ERC20Token:approve(address,uint256)","0x6b963f7b38980f5fbbd129fe98059eb2144076a7/BLV.sol:BLV:approve(address,uint256)",5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","0x0e21117d1895f3af48a03b29411eb2e60116ad41/RxI.sol:RxI:approveAndCall(address,uint256,bytes)","0x5db4b520284049d7dcb21c6317664190791bb8e5/TangentStake.sol:Tangent:approveAndCall(address,uint256,bytes)",4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x5fe56bfa37217bd8a2879c15c85ed7a894edf5a6/esportz.sol:esportz:approveAndCall(address,uint256,bytes)","0x5c757f693aa2e4aff5664e23a6b0c06a0bb3727a/Wran.sol:Wran:approveAndCall(address,uint256,bytes)",5,5,1
"    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x0ecdc69ca6e2e7e12bb344a67b04ff471b6089e7/KillerWhale.sol:SafeMath:div(uint256,uint256)","0x4b2cc07661c7b69a4707277647727aa8898ffbde/BBT.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x2D784562eB7538cC5e5dd5dE880d2A1cc241C1bD/DobrocoinContract.sol:Token:approve(address,uint256)","0x7a7f7dd9c4acd198617c72f54623bdb0c1dff343/VIONC.sol:StandardToken:approve(address,uint256)",2,1,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
          return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","0x2a5294b5d15c582eb33b9dae0e271d9003d26826/BTMC.sol:SafeMath:mul(uint256,uint256)","0x7c62752173591de60ed72cfcfc41ca55aa3d87d6/ETUex.sol:SafeMath:mul(uint256,uint256)",5,5,1
"  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","0x6d5d2755d75d816085a70d0ec5ec7c57eea2015f/SISApreSale.sol:Math:add(uint256,uint256)","0x5c8118fc0237697422ced89a448dce2c8e34b4ef/LTHToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function mul(uint256 a, uint256 b) pure internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x8A3c54EFf8EBB861C9C6AD066CBB9Da08E9A8cDF/LCBrixTokenCrowdsale.sol:SafeMath:mul(uint256,uint256)","0x0b9253b9f0fb51f5416807e6ba31db1e593e179a/IPM.sol:SafeMath:mul(uint256,uint256)",5,5,1
"	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c >= a);
		return c;
	}
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x6d908a2ef63aeac21cb2b5c3d32a145f14144b38/VernamCrowdSaleToken.sol:SafeMath:add(uint256,uint256)","0x0c70a9533baa76344c13ac32a035694a54d0459e/SummerGreen.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x1eecc8cf51995f2b2de7a8f9c1d225462523c246/BitAppleToken.sol:SafeMath:mul(uint256,uint256)","0x001ea8150f4965195e10e5b5568047e1555a6dcd/SenseProtocol.sol:SafeMath:mul(uint256,uint256)",5,5,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x0c5876bc9765ee15fc3378100c070453186db8f3/RobotCoinSeller.sol:Ownable:onlyOwner(),0x3c1b1abf64a441bc106e055cdc89ba4ca005993e/HGToken.sol:Owned:onlyOwner(),5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x6ad199991b7c702f455740d68b9ae70634948a0a/Sukaya.sol:StandardToken:allowance(address,address)","0x1df6eadc2e1e9f4cbb2d94369210d8f1b790ee19/PinnacleToken.sol:PinnacleToken:allowance(address,address)",5,5,1
"	modifier onlyOwner {
    	require(msg.sender == owner);
    	_;
  	}
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Controller:onlyOwner(),0x6b193e107a773967bd821bcf8218f3548cfa2503/PossContract.sol:Owned:onlyOwner(),5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approve(address _spender, uint256 _value) moreThanZero(_value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x5d034d0d0d98fb76192ef2ef27e197fcfd9386ec/AGC.sol:TokenERC20:approve(address,uint256)","0x01d28329619796bae733e849696f80a764422700/BaseTokenSale.sol:Token:approve(address,uint256)",4,4,1
"  function GigaToken() public {
   // * (10 ** uint256(decimals));

    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
","    function CPToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
",0x07df7f1d19b766ff8bfed2b5018fe0601333ed38/GigaToken.sol:GigaToken:GigaToken(),0x3a1e93708cf93d8d9b7a50d9df17e623bb0e907e/CPToken.sol:CPToken:CPToken(),4,4,1
"    modifier onlyOwner{
        require(msg.sender == owner);
        _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x2f846758e479ee7e0bd87cea5b9f8f3e314c6bd9/FixBet76.sol:FixBet76:onlyOwner(),0x3d5d7275e11fa3f0b04145f723bc531313f2a344/TuurntCrowdsale.sol:Ownable:onlyOwner(),5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x6ea3ba628a73d22e924924df3661843e53e5c3aa/TestToken.sol:StandardToken:transferFrom(address,address,uint256)","0x03ec7bb59be036870ef696a2abf124f496d6735a/SancojTokenContract.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x5e70d48f207c52b981e476cb70bc39ad6570c2e1/BitProCoinX.sol:StandardToken:transferFrom(address,address,uint256)","0x6da3095a47d813a13860402638d362bdb9375f6b/LademiA.sol:StandardToken:transferFrom(address,address,uint256)",5,5,1
"    function Carrot(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x5e7d863CcE445cfA89D297929159344e75F77017/Carrot.sol:Carrot:Carrot(uint256,string,string)","0x4d9deb2adce853df52d8567f535b864905f23372/VAToken.sol:TokenERC20:TokenERC20(uint256,string,string)",4,4,1
"  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x1f54638b7737193ffd86c19ec51907a7c41755d8/SolaToken.sol:SafeMath:mul(uint256,uint256)","0x0ecdc69ca6e2e7e12bb344a67b04ff471b6089e7/KillerWhale.sol:SafeMath:mul(uint256,uint256)",4,4,1
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x7cd1b0d0b8b52969fa0ea961cec7c6ec5e06ddb6/BlueHillMining.sol:SafeMath:sub(uint256,uint256)","0x1fe4149affec9eaae713ba54c06303e67734bd39/CashTelex.sol:SafeMath:sub(uint256,uint256)",5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5/PiToken.sol:WilliamJones:freezeAccount(address,bool)","0x8b9d4a796c55a28e65eb276d7ec016f5cd6a4116/GreenEnergyToken.sol:GreenEnergyTokenERC20:freezeAccount(address,bool)",5,5,1
"    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x7fa2f70bd4c4120fdd539ebd55c04118ba336b9e/AFTKToken.sol:SafeMath:add(uint256,uint256)","0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:SafeMath:add(uint256,uint256)",5,5,1
"  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
","  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x1b7f9de410d5ba09fd26ce133fdf59515e0bf728/THETOKEN.sol:BasicToken:balanceOf(address),0x05c7065d644096a4e4c3fe24af86e36de021074b/LendConnect.sol:SafeBasicToken:balanceOf(address),4,4,1
"    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
","function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
     return allowed[_owner][_spender];
}
","0x4b174bc0b7581587448e75691d0b101b90d5ee66/ChipotleCdsTok20221205I.sol:ChipotleCdsTok20221205I:allowance(address,address)","0x4c8c52d8cc106b71cee9a3417711a5b93a3fbef6/CTNToken.sol:CTNToken:allowance(address,address)",4,4,1
"  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x8af311bcfcb0f7cccb729f1459328667d06b3c57/BSPCP.sol:SafeMath:sub(uint256,uint256)","0x1ccc29f9ced9d1a5ce81a7262eac8fcd7eca5788/Ants.sol:SaferMath:sub(uint256,uint256)",5,5,1
"  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x2abd74b67ebb1cb9dbe6ec222e92dad2f7fee194/FCT.sol:StandardToken:decreaseApproval(address,uint256)","0x3fe8a1cdbb598f2c9169fd0a216607b4dcb09888/LamdenTau.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","    function max256(uint256 a, uint256 b) internal constant returns (uint256) {
        return a >= b ? a : b;
    }
","0x5a30b9d5df526e3ff1517497a8fae401fb28a712/MintableToken.sol:SafeMath:max256(uint256,uint256)","0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:SafeMath:max256(uint256,uint256)",5,5,1
"    function Ownable() public {
        owner = msg.sender;
    }
","  function Ownable() {
    owner = msg.sender;
  }
",0x0bd344cade9a06d1798140023f56fb0f56d48afe/Token2GB.sol:Ownable:Ownable(),0x4d9412b6c12b2e2bf0da15416b71f33c846e635b/BIGLUV.sol:Ownable:Ownable(),5,5,1
"     function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
     }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x003f79d7be15dc1ad90ce00e6ea68f335e2b789b/TzTToken.sol:TzTToken:balanceOf(address),0x2c6b2bed2ad5b920936363b0cab60d684c718327/NWO.sol:NWO:balanceOf(address),5,5,1
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x1f77db6ecbce65902d8e27888b40d344f45c337e/WHSCoin.sol:BasicToken:totalSupply(),0x7e921CA9b78d9A6cCC39891BA545836365525C06/SelflleryYouToken.sol:BasicToken:totalSupply(),5,5,1
"    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
","    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
",0x2e16e10fa931d2623d4779cb6320b62ce542aa02/TQXToken.sol:Owned:acceptOwnership(),0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa/LIFECOIN.sol:Owned:acceptOwnership(),5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4b30d120fca686ba384a275064548446dfd8c850/STBToken.sol:STBToken:approve(address,uint256)","0x0a4d2fb8189bb7dbcc2e566e8e1fbbff637cb390/BMT.sol:BMT:approve(address,uint256)",4,4,1
"		modifier	onlyOwner	() {
			require(msg.sender ==		owner	);
			_;
		}
","	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}
",0x4f0cd65448e587bfcdc729da11dfd4ac45c9a8af/MBS_Portfolio.sol:Ownable:onlyOwner(),0x4a96396566fad1033470c9ff848fd69c101a87e2/PublicTokenRegister.sol:Ownable:onlyOwner(),5,5,1
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6f5c77c6975bc2a9e69cec270e22c020114aca6d/KKKKCOIN.sol:EIP20:allowance(address,address)","0x3dc460aca540d0add6debf147a06dc3f34e86eb0/Pixel.sol:StandardToken:allowance(address,address)",5,5,1
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x7c817a4806d2dc1fc9c1f8057f6e9aa94a4d6c8e/CoinstocksToken.sol:TokenERC20:transfer(address,uint256)","0x3d610d9d5add5dfda6b5e52574dc36672f3064b9/BTSC.sol:BTSC:transfer(address,uint256)",5,5,1
"  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }
","    function pause() onlyOwner whenNotPaused public {
        paused = true;
        Pause();
    }
",0x7e7ac3b826c8a940728f324766089cadac54ed30/BLMToken.sol:Pausable:pause(),0x1afafc35b364595f06e89a0429c5762452eb7ffd/CXTCContract.sol:Pausable:pause(),5,5,1
"    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
        OwnershipTransferred(owner, newOwner);
    }
","  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }
",0x0b5828d786f397c73554c5b091aa9ea108fffc51/TilcoinStorage.sol:Ownable:transferOwnership(address),0x7d462f1219ea5bdc8e6a6d879d96ef2a6c5275f8/LiteDashCoin.sol:Ownable:transferOwnership(address),5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x5dc6d8a603a5c48d6a6a322bc027ce42357d0e4d/MoyToken.sol:StandardToken:transferFrom(address,address,uint256)","0x1f26c33b8aed19a68fed28b712696b4102c9a6e2/PreSaleZNA.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x6db8b725824a3e4b49ec12ab76bb678f55a3d6ff/ERC20token.sol:ERC20token:transferFrom(address,address,uint256)","0x5c25bab9b4ab4c6ede1d7092f2f1bf92287d10bc/CryptoCashCow.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) returns (bool success) {
        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]); // Check allowance
        balanceOf[_from] -= _value; // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance
        totalSupply -= _value; // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x4e25ab55f79a9776c3737ef8902fac1c5ca8276e/Angel.sol:Angel:burnFrom(address,uint256)","0x5bfd517c7b03e889204e0cf48f1cf94d067524ea/NeuroToken.sol:token:burnFrom(address,uint256)",4,4,1
"function transfer(address to, uint value) public returns (bool ok) {

    if(_balances[msg.sender] < value) revert();

    if(!safeToAdd(_balances[to], value)) revert();


    _balances[msg.sender] -= value;
    _balances[to] += value;
    Transfer(msg.sender, to, value);
    return true;
  }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x4fc02519648ca7c1ca120f5f73f928ed1ca8bfb3/TMXGlobalToken.sol:TMXGlobalToken:transfer(address,uint256)","0x4a41661a42436b4b07bc887abcf69b07d567c706/THXToken.sol:StandardToken:transfer(address,uint256)",1,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x5d4df6dd12fc56a31e2550efd6414e47a676ecef/MiningRigRentalsToken.sol:TokenERC20:transferFrom(address,address,uint256)","0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5/PiToken.sol:PiToken:transferFrom(address,address,uint256)",5,5,1
"function sub(uint256 a, uint256 b) internal constant returns(uint256) {
assert(b <= a);
return a - b;
}
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x3a5d621b17b3e28de84d88050b460b8435e3966c/Propethy.sol:SafeMath:sub(uint256,uint256)","0x8b69f58be5d02ddc832384ef930bfad2f9223719/N2Contract.sol:SafeMath:sub(uint256,uint256)",5,5,1
"  function mul(uint256 a, uint256 b) internal pure  returns (uint256) {
      uint256 c = a * b;
      assert(a == 0 || c / a == b);
      return c;
  }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x2bb362a97f2bbb87af4cfe4faa6e3f049a5e364f/DoctorChainToken.sol:SafeMath:mul(uint256,uint256)","0x07c0ef8c8961cb7fc0dadd0a40c57b7b7dfed230/TESTTESTICO.sol:SafeMath:mul(uint256,uint256)",5,5,1
"    function add(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x2cf3a4af0c34c4f12f4bc391bd123d13eeefd7fc/GENEPromoToken.sol:SafeMath:add(uint256,uint256)","0x3A157f8041E618Cac2B68D2D203e36Dd8D96Bd90/NoMarketingBullshit.sol:SafeMath:add(uint256,uint256)",5,5,1
"	function transferOwnership(address newOwner) onlyOwner public {
		if (newOwner != address(0)) {
			owner = newOwner;
		}
	}
","    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x6bd992c2f23cf9ae324f76614ec2ac5541008601/TradeNetCoin.sol:Ownable:transferOwnership(address),0x1fa50285d76f2f9c79ba76b4bd992212147797c2/TCNYCoin.sol:Ownable:transferOwnership(address),5,5,1
"  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
","    function balanceOf(address _owner) constant public returns (uint256) {
	 return balances[_owner];
    }
",0x0f0c3fedb6226cd5a18826ce23bec92d18336a98/URToken.sol:BasicToken:balanceOf(address),0x0cd161ef9eb19a95fefa69c36f9cf552c19e6b8f/AnimatixToken.sol:AnimatixToken:balanceOf(address),5,5,1
"function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
   return allowed[_owner][_spender];
}
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x5df21c6adb35ec396514bc93d219a2df6a323a92/Protecthor.sol:Protecthor:allowance(address,address)","0x2e14e0c5589f5d6c4f34d230950f82177e001f53/SSAToken.sol:StandardToken:allowance(address,address)",5,5,1
"	function balanceOf(address _owner) public view returns (uint balance) {
		return balances[_owner];
	}
","  	function balanceOf(address _owner) public constant returns (uint256 balance)
  	{
		return balances[_owner];
  	}
",0x2e208cf41b721c3cb4ac78cc05938619bdccc0d0/protoLEXToken.sol:protoLEXToken:balanceOf(address),0x2e2625d38ec84cbc13117fa1a74e4266b5e94318/FJH.sol:FJH:balanceOf(address),3,3,1
"  modifier canMint() {
    require(!mintingFinished);
    _;
  }
","  modifier canMint() {
    require(!mintingFinished);
    _;
  }
",0x04cc783b450b8d11f3c7d00dd03fdf7fb51fe9f2/FilmscoinToken.sol:MintableToken:canMint(),0x0fd9214c147ef20b562ecf8f8298f732fe89558c/OpenSaleChest.sol:MintableToken:canMint(),5,5,1
"    function totalSupply() constant returns (uint256 totalSupply) {
        return _totalSupply;
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
",0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:totalSupply(),0x0c1d55e948d26c1e7a6bc9a1f93c9d15395a39f1/JCT.sol:JCT:totalSupply(),5,5,1
"  function allowance(address _owner, address _spender) external view returns (uint256) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x5B932f07fd6E8fEbe913f70C913cD0D1FfD3a0A7/OVOToken.sol:ERC20Standard:allowance(address,address)","0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:allowance(address,address)",5,5,1
"    constructor () public {
        owner = msg.sender;
    }
","    constructor() public {
        owner = msg.sender;
    }
",0x6d39766fc715217ba313e338a4c023065d963889/BeringiaContract.sol:Ownable:constructor(),0x4b5da69c6289bd71d643710d0a63bd4867808451/PaoToken.sol:Ownable:constructor(),5,5,1
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyOwner {
        require (msg.sender == owner);
        _;
    }
",0x4f6Fe3bBEfDB17E23D6e74a33482413c961569C3/Cillionaire.sol:owned:onlyOwner(),0x8a19d9bbbc5edf01ddd4acc6736f4091e67ad72a/AlsIco.sol:Owned:onlyOwner(),5,5,1
"  constructor() public {
    owner = msg.sender;
  }
","    constructor() public {
        owner = msg.sender;
    }
",0x1f060991e27634cdc449776ed9771e6f8cce6dd0/CoinSmarttICO.sol:Ownable:constructor(),0x1e66f8bf4e95d61cfac0f98d9d6c0ffa23e360e5/MamaToken.sol:Owned:constructor(),5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
",0x2c821a3ce3b5c0a471862eb63a2ef99a4d285d43/CriptaliaRewards.sol:CriptaliaRewards:totalSupply(),0x5cd89fa023d505db8324a29c8e2a7f14bfc73928/StanleyToken.sol:StanleyToken:totalSupply(),5,5,1
"    function transferOwnership(address newOwner)
        onlyOwner
    public {
        owner = newOwner;
    }
","    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
",0x1d9ca3546b84d3103b551c7d5006e4db172e06e6/Arbitrator.sol:Owned:transferOwnership(address),0x6aa2044c7a0f9e2758edae97247b03a0d7e73d6c/CardToken.sol:owned:transferOwnership(address),5,5,1
"    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }
","  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
",0x0db8d8b76bc361bacbb72e2c491e06085a97ab31/iQeon.sol:Ownable:transferOwnership(address),0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:Ownable:transferOwnership(address),4,4,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x6fb3e0a217407efff7ca062d46c26e5d60a14d69/IoTeXNetwork.sol:SafeMath:add(uint256,uint256)","0x6fb143fa38e119f1e70609dc8ab9e4d65e871f65/UKPound.sol:SafeMath:add(uint256,uint256)",4,4,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {



    return a / b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x5f2eb336c18ba7a6c9349bf68af677a6e1808ab8/EcoShareToken.sol:SafeMath:div(uint256,uint256)","0x6ee2ee1a5a257e6e7ade7fe537617ead9c7bd3d2/BittechToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"  function div(uint256 a, uint256 b) internal returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x3f9ef884433bdcbe10e6477e58be727bc4e6731a/BIONEUM.sol:SafeMath:div(uint256,uint256)","0x3b03bfac807ef159d64a09420ed67848e2160232/AALMCrowdsale.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
",0x3c7916a935faedd57bd8e3a91daf5c081f723855/PowerToken.sol:TokenERC20:balanceOf(address),0x6ea89484b983a40b1571914561a41c34c075e3af/GoldBoxToken.sol:BasicToken:balanceOf(address),5,5,1
"    function approve(address _spender, uint256 _value) transfersEnabled public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x3f1db1493f18764022bdbd0ce52b4c7f232ed029/DistributedBank.sol:StandardToken:approve(address,uint256)","0x2c61c057c4d599f21d11533d321c1d3e25d16afc/PixieToken.sol:StandardToken:approve(address,uint256)",4,4,1
"   function allowance(address _owner, address _spender) public view returns (uint256) {
     return allowed[_owner][_spender];
   }
","    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }
","0x7a54fae94b6960d9f7316612eec179078e911769/MoviePass.sol:MoviePass:allowance(address,address)","0x5d0fa08aeb173ade44b0cf7f31d506d8e04f0ac8/DAPPToken.sol:DAPPToken:allowance(address,address)",5,5,1
"  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
","  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
",0x7a1bbc9a25f8224cad23e2888775ab8b61c8894f/KMHToken.sol:Ownable:renounceOwnership(),0x5e55d802d5df48d59c411fe39ba7ae207e5fbf90/Ethereumwhocoin.sol:Ownable:renounceOwnership(),5,5,1
"    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
        balanceOf[msg.sender] -= _value;                      // Subtract from the sender
        totalSupply -= _value;                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
        balanceOf[msg.sender] -= _value;                      // Subtract from the sender
        totalSupply -= _value;                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
",0x0a3454b1c30f956f52f6a5b712b390b243ecd288/GA_chain.sol:GA_chain:burn(uint256),0x5b18bf749d3015640d0301325415c8f95ea087ac/AdvancedArtificialIntelligenceSafetyDefense.sol:AdvancedArtificialIntelligenceSafetyDefense:burn(uint256),5,5,1
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }
","  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }
",0x8b10c775f9089de76fa50ac2effeb012e43497fb/TOBToken.sol:StandardToken:balanceOf(address),0x7f32d1959b5361e884df8c9d017a03f4ce29c8b2/Kemonocoin.sol:Kemonocoin:balanceOf(address),4,4,1
"    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {
        return allowed[_owner][_spender];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6e0695d06382ee1A7eacbB32eD69a9E06E9C9d6a/Minecoin.sol:Minecoin:allowance(address,address)","0x7dcdbd2c6548774d301811658ddcb0e75eca9881/VETRA.sol:StandardToken:allowance(address,address)",5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","  function approve(address _spender, uint256 _value) returns (bool success) {
          allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x06ea7f6e403b68b228423cec502deb793c1c6c18/GigsToken.sol:GigsToken:approve(address,uint256)","0x3f9e8af3ab96c7560c1404ed2d6794ead7ce846a/ERC20.sol:ERC20:approve(address,uint256)",4,4,1
"    function allowance(address _owner, address _spender) constant  public returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x5c93583bd77beaab16b0b334ec87e37069152092/WBSToken.sol:StandardToken:allowance(address,address)","0x7b2e42fbba091de219b244e049f4593eec2a20f6/SimpleToken.sol:StandardToken:allowance(address,address)",5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x7a7f2a4550841258a516d71a90c28c97a529a66a/Omnic.sol:ERC20Token:approve(address,uint256)","0x1ee4910bd5e9b1b063277ce69e84a1a3ebf1ee95/UPXToken.sol:StandardToken:approve(address,uint256)",4,4,1
"    function balanceOf(address _owner) constant returns(uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x03Cf2a857b2217429D47850D884Efc47DA54b08B/BBXCoin.sol:BBXCoin:balanceOf(address),0x03f839d3c0857202691f390c2f8723accd738286/XgoldCrowdsaleToken.sol:BasicToken:balanceOf(address),5,5,1
"    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x1ee4910bd5e9b1b063277ce69e84a1a3ebf1ee95/UPXToken.sol:StandardToken:allowance(address,address)","0x6a691ae563524b705a8accf1646bcac100d9bb0d/JCoin.sol:StandardToken:allowance(address,address)",5,5,1
"  function divX(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x0f43e50aa2ec14296a33f68d0c8c605b3acc08dc/TAKLIMAKAN.sol:SaferMath:divX(uint256,uint256)","0x7fab314ab059a6d6f622f64d62860c94d1fd9603/QTLToken.sol:SafeMath:div(uint256,uint256)",4,4,1
"   function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 r = a + b;

      require(r >= a);

      return r;
   }
","    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x00c4B398500645eb5dA00a1a379a88B11683ba01/EximchainToken.sol:Math:add(uint256,uint256)","0x8b8aaf37e44e87cc1285a822c767104b28dc0d58/AirDropContract.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x1b9dcdcddd2d6ca699cad9505faa363e81145c6b/BrinkToken.sol:BrinkToken:transferFrom(address,address,uint256)","0x5f6e8ae5036be21cb17285f0e7f2b8d51e0b24ee/NenmoToken.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x3bc73fda7c90fc7359399664d25ca943793f1e6f/BeatToken.sol:StandardToken:transferFrom(address,address,uint256)","0x3e318c580d23c28156fe0da55ad71b41798b75ed/DiscCoin.sol:StandardToken:transferFrom(address,address,uint256)",5,5,1
"    function balanceOf(address _owner)
    public view
    returns (uint256 balance) {
        return balances[_owner];
    }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x0bbb5a54767166b21e4a74d30500248a05ed985f/StarambaToken.sol:StandardToken:balanceOf(address),0x8bd010f5e46af9c1f5f0976ceea79bcc8410821b/EthixToken.sol:BasicToken:balanceOf(address),5,5,1
"	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b > 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold
		return c;
	}
","    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:SafeMath:div(uint256,uint256)","0x7a4033a93885247a4292988a3c0c0e3c1cf55721/Airdroster.sol:SafeMath:div(uint256,uint256)",5,5,1
"function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
return allowed[_owner][_spender];
}
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x4f595feaa226aad29fc9f3e9fd2e2081d1162910/YUN.sol:YUN:allowance(address,address)","0x1a645debd700890f1bc93626078d89e260bd09ce/TheMostPrivateCoinEver.sol:StandardToken:allowance(address,address)",5,5,1
"  function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x7d669ae0b893f91f59861194d53e3ef348d7d4a8/EthereumCenturion.sol:StandardToken:decreaseApproval(address,uint256)","0x1f325f9d0fa3ecb7f38c61cae9cbeb34f0502e44/CoupeToken.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x6f9b6b18388a5dd76ec0954af1616af1206db215/ZLHToken.sol:StandardToken:decreaseApproval(address,uint256)","0x5d9443fd1329579142afb537523d8715efc34e57/Taooda.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"	function allowance(address _owner, address _spender)public constant returns (uint256 remaining) {
	    return allowed[_owner][_spender];
	}
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x4cf526f412a88371e899336bd54388ef50dafaf6/SocialMediaToken.sol:SocialMediaToken:allowance(address,address)","0x3ee8743a700f04de27471a43e0da359608679b63/Cygnus.sol:StandardToken:allowance(address,address)",5,5,1
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
","  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
",0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:Pausable:unpause(),0x3bcfe4786ce5669fe06282ebf11afe3d0f606cda/Leaxcoin.sol:Pausable:unpause(),5,5,1
"    function sub(uint256 a, uint256 b) internal returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:SafeMath:sub(uint256,uint256)","0x0b4ce72a70e87bee66e0f43e9c861366e9d7de19/Pisces_ZodiacToken.sol:SafeMath:sub(uint256,uint256)",5,5,1
"  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}
","    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
","0x7f7584465ab12b67ecefe8fde6e799c16d1ae273/Fricacoin.sol:StandardToken:allowance(address,address)","0x4AFEa0F1252335E5E6be870139de87725e16560b/NatminToken.sol:NatminToken:allowance(address,address)",5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //??token???????(2^256 - 1)
        //??????????????????????token?????????????????? if ??
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x4b222a1fe6acec5b8b6b34f02ee0d69be431a2d6/MANHATTANPROXYRIVDR.sol:StandardToken:transfer(address,uint256)","0x3eb63aac98ebb3f341171a2eeb8ca2c5531c621a/Coin.sol:StandardToken:transfer(address,uint256)",5,5,1
"    function sub(uint256 a, uint256 b) internal constant returns(uint256) {
        assert(b <= a);
        return a - b;
    }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x5d9afcf314fc10c74fa3383edd31f339b3278a2c/TRADERSCOIN.sol:SafeMath:sub(uint256,uint256)","0x8b372327fb107e1e2863ddb9586c8b69e12da5e3/EtherZaarTwitter.sol:SafeMath:sub(uint256,uint256)",5,5,1
"  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x8a1cec92faafa44eecc3633b939a98f4ae4b87ee/OGX.sol:StandardToken:allowance(address,address)","0x3ee8f673aa24e41300e9a3bdabef7c534c537199/NLBCoin.sol:StandardToken:allowance(address,address)",4,4,1
"    function approve(address _spender, uint256 _value)
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval( msg.sender ,_spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5b29a6277c996b477d6632e60eef41268311ce1c/Dragon.sol:Dragon:approve(address,uint256)","0x7f9697c2d71f933904f3420344ec8b22004f85fa/ChainMaster.sol:StandardToken:approve(address,uint256)",4,4,1
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipChanged(owner, newOwner);
    owner = newOwner;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd/Mythereum.sol:Manageable:transferOwnership(address),0x8c32f8d0edb496326de8d3adf46f622a744b86fe/CAStoreContract.sol:Ownable:transferOwnership(address),4,4,1
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4c567c3363cc42c5a42c6d8bf01503fd1d0b91cd/ElementhToken.sol:StandardToken:approve(address,uint256)","0x4ef6ea200f5b5fe49421c03cb7690abedca5d685/OpiriaCrowdsale.sol:StandardToken:approve(address,uint256)",4,4,1
"	function div(uint256 a, uint256 b) internal constant returns (uint256) {
		uint256 c = a / b;
		return c;
	}
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x2e62af2ad08239c528ee7ed72914dad6a897b1fd/CryptoToken.sol:SafeMath:div(uint256,uint256)","0x3ff88c83845bce6788f53a41b74bd9609b20db76/ChatTradersCoin.sol:SafeMath:div(uint256,uint256)",5,5,1
"  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x3d44a72919dd5ac4be78364ca577aa4a7d9f0a43/EPXCrowdsale.sol:owned:onlyOwner(),0x6eaeb67b455157a879227aaa73a8e4e27cb32e15/CellToken.sol:Ownable:onlyOwner(),5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","0x7dccb8c9639b50cfc33175307f0656d6eb5892ac/Coinasia.sol:BasicToken:transfer(address,uint256)","0x6bade5d03fa771627fa82470e86dbe13b8b77428/Needit.sol:BasicToken:transfer(address,uint256)",5,5,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }
","    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }
","0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:SafeMath:div(uint256,uint256)","0x3da034753B42Bda1BcFA682f29685E2fd6729016/VoipToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x7c0924eea284ef4b7a1b0fefdd0d808fc717377e/ATOToken.sol:ATOToken:transferAnyERC20Token(address,uint256)","0x06f3a5b77623c0943f0f6c497cef0f39f3bc0089/Zygoma.sol:Zygoma:transferAnyERC20Token(address,uint256)",5,5,1
"   function approve (address _spender, uint256 _value) returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    Approval (msg.sender, _spender, _value);
    return true;
  }
","  function approve(address _spender, uint _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x0f71fda4987069d5cc1d0e6c234fd01675947b5e/LIDToken.sol:AbstractToken:approve(address,uint256)","0x2ea13316d1e54e6de5d4a7e167071477a1feb003/GozToken.sol:StandardToken:approve(address,uint256)",4,4,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1deb5132070402dffdb988f8e7514dd6ef2d444b/Digipay.sol:StandardToken:increaseApproval(address,uint256)","0x8a1ce73cef5b49a250c58ccf9a145d87925ea438/Ssnc.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"  function Ownable() public {
    owner = msg.sender;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x6a04f1b8cd341232b59c8bc70a102c45f6b29b38/ICO.sol:Ownable:Ownable(),0x4c64ec047fd2d83b7cab6189f71d718ac63bd2f0/HLWCOIN.sol:Ownable:Ownable(),5,5,1
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = (
            allowed[msg.sender][_spender].add(_addedValue));
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x5c8e877a5dcad74fb69dcf19770868b4d29d51e2/PAYBUDToken.sol:StandardToken:increaseApproval(address,uint256)","0x3c4c1bc1e2539d5948b6e75bf2fbe37e1e0ed05c/GotecoinToken.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x7e1892fee14fe293ad71f5afd2132dbffabee0ab/blablabla.sol:ERC223Token:balanceOf(address),0x0bc527253250f70e0bfcf802a0098e93389f22a5/HplusToken.sol:StandardToken:balanceOf(address),4,4,1
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x0cacf6822d036730e112263fe91b6dd1086787d6/BlueHillMining.sol:SafeMath:mul(uint256,uint256)","0x6e5d0bbcf30cf79411cc9e6e7d8edfc2c5c8be4d/EBCBToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x6ba22692a402ba9bf664794e26e108f601325212/Platopay.sol:owned:onlyOwner(),0x5fd72a8a514697232cce4e0166c48993b060f46c/VanityURL.sol:Ownable:onlyOwner(),5,5,1
"    function Cashpayz() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
","    function DSCCoin() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
",0x6abb492d778903be5fb8922e076ca5e337e29062/Cashpayz.sol:Cashpayz:Cashpayz(),0x7a7194168245d76f1f2830c937626b7c383067c8/DSCCoin.sol:DSCCoin:DSCCoin(),4,4,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4b98e3d7167eb66c333a0e279522c44d3716b445/Arcturus.sol:StandardToken:decreaseApproval(address,uint256)","0x7c43dea72a94972a341489b60ce9a07eb45253f9/AGRECrowdsale.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw;
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
","    function transfer(address _to, uint256 _value) public {
        if (_to == 0x0)  revert();
		if (_value <= 0)  revert();
        if (balanceOf[msg.sender] < _value)  revert();
        if (balanceOf[_to] + _value < balanceOf[_to])  revert();
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        Transfer(msg.sender, _to, _value);
    }
","0x4e75b2086338f156f04d6563bec43e46c7f8051b/BGJC.sol:BGJC:transfer(address,uint256)","0x2e3f4428026e83acd6c34279e5ed9e920499fd02/NewToken.sol:NewToken:transfer(address,uint256)",4,4,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
      allowance[msg.sender][_spender] = _value;
      return true;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x1ef57424c7f38628a0e25177ff61a671fbe4b405/BitWestToken.sol:BitWestToken:approve(address,uint256)","0x7CF2e4469d48F3e414dF46cdd41A0E7286a7AFb0/PHDToken.sol:PHDToken:approve(address,uint256)",5,5,1
"  function allowance(address _owner, address _spender) public constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:StandardToken:allowance(address,address)","0x4d319d5a58f9d4690fb10c62fa54b5a42c54f431/MOLTYToken.sol:StandardToken:allowance(address,address)",4,4,1
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x3ff88c83845bce6788f53a41b74bd9609b20db76/ChatTradersCoin.sol:Ownable:onlyOwner(),0x5b90b68049631d80fee37e00df623e80a6c2ee25/Crypbest.sol:Owned:onlyOwner(),5,5,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x6dcfac01b1fb424c76459d96eaa0e0e51be9d3ba/Blockcash.sol:SafeMath:div(uint256,uint256)","0x3c1999d19401469693cb8d8acd14fd3aec34dd15/GoogleChainToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x2a6a139da8d1f430696663d640591d5199aa718e/JjWorldToken.sol:Ownable:onlyOwner(),0x4f9B160eC27C75797c0ACF0198a221ED8a1Dc32f/eElectroneum.sol:Ownable:onlyOwner(),5,5,1
"  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x1ccc29f9ced9d1a5ce81a7262eac8fcd7eca5788/Ants.sol:StandardToken:allowance(address,address)","0x3f61b512856056d663fd763b880da4a8ed4ceeee/TutellusCrowdsale.sol:StandardToken:allowance(address,address)",5,5,1
"  	function allowance(address _owner, address _spender) public constant returns (uint256 remaining)
  	{
		return allowed[_owner][_spender];
  	}
","    function allowance(address _owner, address _spender
    ) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x7df24b03c7f4a697f337da0755427dfb3d1c3e4d/COLETOKEN.sol:COLETOKEN:allowance(address,address)","0x1B9743f556D65e757c4c650B4555bAF354cB8bd3/ETBSToken.sol:MiniMeToken:allowance(address,address)",5,5,1
"	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
	    return allowed[_owner][_spender];
	}
","    	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      		return allowed[_owner][_spender];
    	}
","0x6a27778baa415f9086ba0703c7a9c6cde0d46f2b/XtremcoinToken.sol:XtremcoinToken:allowance(address,address)","0x2ea7ae77369654e4afe84ef3733fccd8e159e1fe/E4Token.sol:E4Token:allowance(address,address)",5,5,1
"    function CPNtest() {

         initialSupply = 100000000;
        name =""CryptoNightTest"";
        decimals = 8;
        symbol = ""CPN"";

        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply

    }
","    function RollsRoyce() {

         initialSupply = 5000000;
         name =""RollsRoyce"";
        decimals = 1;
         symbol = ""RRC"";

        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply

    }
",0x3edb8b883af8df699e66e7bffb45fad37a3493a7/CPNtest.sol:CPNtest:CPNtest(),0x6d150887670539be19ec85835db4db89532f1ff9/RollsRoyce.sol:RollsRoyce:RollsRoyce(),4,4,1
"    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x0b4bdc478791897274652dc15ef5c135cae61e60/DAEXToken.sol:StandardToken:balanceOf(address),0x0dadf584229a468a0ad29d6e22a56a65fe7b86f6/StfuToken.sol:BasicToken:balanceOf(address),5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:SafeMath:div(uint256,uint256)","0x0f33a2f6dc77be2134e1537bf919f7d9ef1d225d/MOT.sol:SafeMath:div(uint256,uint256)",5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x3f45d3b92976b02c4ce587df68b9c7943ff7efc3/TSCoin.sol:SafeMath:mul(uint256,uint256)","0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0/CCOIN.sol:SafeMath:mul(uint256,uint256)",5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }
","    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
","0x2Bb85293d3faBaB96C812170E112C6472951145c/TaxiToken.sol:PausableToken:increaseApproval(address,uint256)","0x0deecb13f4e801bdbf2721875756d44b207ca580/ETHERCToken.sol:PausableToken:increaseApproval(address,uint256)",5,5,1
"  function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {
    uint256 z = x * y;
    assert((x == 0)||(z/x == y));
    return z;
  }
","    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }
","0x1d8f5b2bd72a7db787e4f42cce6be8474389353d/EthRoi.sol:SafeMath:safeMult(uint256,uint256)","0x4e0603e2a27a30480e5e3a4fe548e29ef12f64be/Credo.sol:SafeMath:safeMult(uint256,uint256)",5,5,1
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x7ac6629c2c8e7ca6e9696ad6627725ae42c28df7/CSCToken.sol:SafeMath:add(uint256,uint256)","0x3a5caf051718d98026a29e21d9abe6f8c8a23fa0/PuJaDaToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
","0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:getTokenBalance(address,address)","0x4ccc3759eb48faf1c6cfadad2619e7038db6b212/SuperEdge.sol:SuperEdge:getTokenBalance(address,address)",5,5,1
"  	function approve(address _spender, uint256 _value) public returns (bool)
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x1e786b405fb2876f9a61c8fc7d2db01157b7cfe8/OTA.sol:OTA:approve(address,uint256)","0x0be061e3c22b14bea9bbbcf8c044415d3e6a77a8/BifreeToken.sol:StandardToken:approve(address,uint256)",5,5,1
"    function owned() public {owner = msg.sender;}
","    function Owned() public {
        owner = msg.sender;
    }
",0x0bd3862a22c1c01d406335b24524ab3da5b116b8/EmrCrowdfund.sol:owned:owned(),0x0d00fd58ea71bac05b307d46c7ab389b29219a8f/PhipsiToken.sol:Owned:Owned(),4,4,1
"  function approve(address _spender, uint256 _value) public returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x5dc6d8a603a5c48d6a6a322bc027ce42357d0e4d/MoyToken.sol:StandardToken:approve(address,uint256)","0x7c0f6468838d8256a6bb334da2136a825aa3ea15/StarsICO.sol:StandardToken:approve(address,uint256)",5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x1fc3db544c4d4dd09f7a0524f3c64c9d0ac2abac/ESSENTIA.sol:ESSENTIA_ERC20:approveAndCall(address,uint256,bytes)","0x2dc0170450e66af2d3f5c56aa0b20ec4a254902e/MyAdvancedToken.sol:token:approveAndCall(address,uint256,bytes)",5,5,1
"    function allowance(address _owner, address _spender)
        public
        constant
        returns (uint)
    {
        return allowed[_owner][_spender];
    }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x1e83cdd27d0b34c727c417759585e87e2770c28c/TestyTest.sol:ERC20Token:allowance(address,address)","0x5c64031c62061865e5fd0f53d3cdaef80f72e99d/HashGardToken.sol:StandardToken:allowance(address,address)",4,4,1
"    function Utils() {
    }
","    function Util() public{}
",0x0b1fdd0e5c340d25d669819f0cd937ed3bbef4f9/EtherToken.sol:Utils:Utils(),0x1b5a535502c519987115ebe5892666f4102bdf9f/SmartVows.sol:Util:Util(),4,4,1
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }
",0x7b8cf0e0de46a6b5272dced7f1ffb8ea24a82421/NvcFundCoin.sol:NvcFundToken:balanceOf(address),0x5f3ed006e544f70f8c8344201958b58316065d1b/InitialToken.sol:StandardToken:balanceOf(address),5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x8aefbc7df185694f19fe1da7f499e95069761766/WOLFEXToken.sol:SafeMath:mul(uint256,uint256)","0x2f21116abbb4a91d916be8c665b461aea00eb568/HODL_Token.sol:SafeMath:mul(uint256,uint256)",4,4,1
"function allowance(address _owner, address _spender) constant returns(uint256 remaining) {
return allowed[_owner][_spender];
}
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x3a5d621b17b3e28de84d88050b460b8435e3966c/Propethy.sol:Propethy:allowance(address,address)","0x1e77b10ead7ae84bc54394bd33821e5c7b74fbb8/Testico.sol:Testico:allowance(address,address)",5,5,1
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x7b00cac9b094f775b7e2009e017c3600f06c944c/Issuer.sol:SafeMath:mul(uint256,uint256)","0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:SafeMath:mul(uint256,uint256)",5,5,1
"    function add(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x07c0ef8c8961cb7fc0dadd0a40c57b7b7dfed230/TESTTESTICO.sol:SafeMath:add(uint256,uint256)","0x6eed4a400ce1e79f41bdf755ea2fac4d4c29d9c6/HawkTokenCrowdsale.sol:SafeMath:add(uint256,uint256)",5,5,1
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {
        uint256 z = _x * _y;
        assert(_x == 0 || z / _x == _y);
        return z;
    }
","0x0a8c316420f8d27812beae70faa42f0522c868b1/WAVEliteToken.sol:SafeMath:mul(uint256,uint256)","0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:SafeMath:safeMul(uint256,uint256)",4,4,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
",0x6b87999be87358065bbde41e8a0fe0b7b1cd2514/TeslaWatt.sol:TeslaWatt:balanceOf(address),0x4dbf69fd676a0dd7b2ac7d8c3d4f9e4ee7201ac7/ExiliumToken.sol:ExiliumToken:balanceOf(address),5,5,1
"    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][spender];
        if (subtractedValue > oldValue) {
            allowed[msg.sender][spender] = 0;
        } else {
            allowed[msg.sender][spender] = oldValue.sub(subtractedValue);
        }
        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
        return true;
    }
","  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1c2de9c9fd19a4de38d8bf2b98369c45ccf09048/CityLifePlusToken.sol:CityLifePlusToken:decreaseApproval(address,uint256)","0x3dd4d9886ae628ce7fc4ef7b8242fb4703bc9755/PreICOCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x0a4d2fb8189bb7dbcc2e566e8e1fbbff637cb390/BMT.sol:BMT:approve(address,uint256)","0x2ca8e1fbcde534c8c71d8f39864395c2ed76fb0e/ChozunCoin.sol:StandardToken:approve(address,uint256)",5,5,1
"    function add(uint256 a, uint256 b) internal returns (uint256) {

        uint256 c = a + b;

        assert(c >= a);

        return c;

    }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x2DBE0f03f1dddbdbc87557e86dF3878AE25af855/HashRushICO.sol:SafeMath:add(uint256,uint256)","0x2dc2e581f1dca93b618937aa313c8920153af960/KyberNetworkTokenSale.sol:SafeMath:add(uint256,uint256)",5,5,1
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {

if (a == 0) {

return 0;

}

uint256 c = a * b;

assert(c / a == b);

return c;

}
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x2dcea121a1d3f0075b9927a2ef7c3ce8a953bc30/AnterosToken.sol:SafeMath:mul(uint256,uint256)","0x2f102963f61acf1ca4badfe82057b440f2fc722c/EaiToken.sol:SafeMath:mul(uint256,uint256)",5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }
","0x7eba66ae4aa6f60c9fe00a39883e60e4e6a59323/TimeBankToken.sol:SafeMath:div(uint256,uint256)","0x7c5cf07b5c7d4b7f7cd001e96ec7e7189a155773/KeplerToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"  function OSNToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;

    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
","  function LuxProject() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
",0x3b07a0f3a9dee1144532fca548bf31afaeba0290/OSNToken.sol:OSNToken:OSNToken(),0x7a33017e1b81781c95db0716c3609fd920d94cf7/LuxProject.sol:LuxProject:LuxProject(),4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x7a4528ac52fa6b27aaa1e0dc1bcfbd7f82976595/RidgeToken.sol:ridgeContract:transfer(address,uint256)","0x2fa5a79bb3606b26db51896ec98ae898a5ae15b5/BitcoinDiamond.sol:StandardToken:transfer(address,uint256)",5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x5d0fa08aeb173ade44b0cf7f31d506d8e04f0ac8/DAPPToken.sol:SafeMath:mul(uint256,uint256)","0x5fed01f08b6c17c3d985481dc8f8e5c1105a60d1/AAToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x4d4377ef856e89cbf76f8e994ab3065445d82f4f/Airdrop.sol:SafeMath:mul(uint256,uint256)","0x5d13b1f5c2202675e90d3234661abe0883afece8/TestCoin.sol:SafeMath:mul(uint256,uint256)",5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x0Dae0a0d130F053fE4bbbec4927539E5f06d2684/PrymexPreICOCrowdsale.sol:StandardToken:transferFrom(address,address,uint256)","0x5d05de87d694f0c2971d4e0192fb924bb0712802/KRWTether.sol:StandardToken:transferFrom(address,address,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) transfersEnabled public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","0x4dda7044db5fa409cc36629077ef6e56ee9a96ee/LINCToken.sol:BasicToken:transfer(address,uint256)","0x07ed0e2dc552e09dd543f7f70312b5035f6820aa/UbitToken.sol:BasicToken:transfer(address,uint256)",4,4,1
"    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {
        uint256 c = _a + _b;
        require(c >= _a);

        return c;
    }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x2f94cf1e282580226680d06bdeb63f34cca9c5d0/GUCN.sol:SafeMath:add(uint256,uint256)","0x6de126fe427b7556328038a400afa99b857760b7/MANETokenCrowdsale.sol:SafeMath:add(uint256,uint256)",4,4,1
"      function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
      }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x7bd83a0188e3ecd303efd83e91b652fee0b149e1/TestToken.sol:StandardToken:increaseApproval(address,uint256)","0x7c35b9cab8657623e3fd499ae3e00554fa05ce84/TTMToken.sol:StandardToken:increaseApproval(address,uint256)",4,4,1
"  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }
","  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
",0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:Crowdsale:forwardFunds(),0x1d02b62ee240a669718128570fa49ec5ed8ab7c2/GC_ICO.sol:GC_ICO:_forwardFunds(),4,4,1
"    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6ce4642936028cf493c9bdd72e78130297cb77ea/BixtrimToken.sol:StandardToken:approve(address,uint256)","0x4Cb447bEE2Faf3a633914953dc8273A99efBD9FB/CmmToken.sol:StandardToken:approve(address,uint256)",4,4,1
"    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }
","    function decreaseApproval(address _spender, uint _subtractedValue) isRunning public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        }
        else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","0x6ce4642936028cf493c9bdd72e78130297cb77ea/BixtrimToken.sol:StandardToken:decreaseApproval(address,uint256)","0x6b9a2f183291cc734390093b84f92dee144d38dd/DeepCoinToken.sol:StandardToken:decreaseApproval(address,uint256)",4,4,1
"  modifier onlyOwner() {
    if (msg.sender != owner) {
      revert();
    }
    _;
  }
","  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }
",0x0e41c976f456ccb29c04e62ba70094d174f2b503/NoahDividend.sol:Ownable:onlyOwner(),0x4ba3bbb97b5580e73b8649929b3a1e7e99b3faf6/Airdropper.sol:Ownable:onlyOwner(),4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","0x7bc514c46d47cfe989a967a36a6760e4eef50a97/TomBit.sol:TomBit:approveAndCall(address,uint256,bytes)","0x6c5607c25121c8a1070311c85ae5f474b0d5f642/BENZCoin.sol:BENZCoin:approveAndCall(address,uint256,bytes)",5,5,1
"  modifier whenNotPaused() {
    require(!paused);
    _;
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x8b40761142b9aa6dc8964e61d0585995425c3d94/TripioToken.sol:Pausable:whenNotPaused(),0x6a85f717aaa16a9050858be9415eb213dfc1957a/XpressToken.sol:Pausable:whenNotPaused(),5,5,1
"    function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x8bf8bcf8aba5ecffffd431489fe79dad38023a9b/Bus.sol:Bus:balanceOf(address),0x2c84c27f3b36900b0c599a57e358e9f7ab77f869/DemeterToken.sol:BasicToken:balanceOf(address),5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true; } }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);              // Cast spender to tokenRecipient contract
        approve(_spender, _value);                                      // Set approval to contract for _value
        spender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract
        return true;
    }
","0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f/HEART.sol:HEART:approveAndCall(address,uint256,bytes)","0x7b5271c23e0da39d17e04304c5ce651ed6074e8c/DASABI_IO_Contract.sol:DASABI_IO_Contract:approveAndCall(address,uint256,bytes)",4,4,1
"    function div(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a / b;
        return c;
    }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x3cd8e97289dccfed9546ea58d0a0031037410c06/PREZ45Coin.sol:SafeMath:div(uint256,uint256)","0x2aa0a30006fdf8cf273ddf7a80c56eb3646f28b7/LSDCrowdsale.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x4fb2445742d0c413a917b2484960b0d80950b540/Bible.sol:Bible:transferFrom(address,address,uint256)","0x1c2699cbb862c6bfccd9ff8c80734263cd486578/CryptoIgniterToken.sol:CryptoIgniterToken:transferFrom(address,address,uint256)",5,5,1
"    function approve (address _spender, uint256 _value) returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x1acc5652735bc9ed6b420627d93411ff6a6df549/EthealPromoToken.sol:AbstractToken:approve(address,uint256)","0x1d6d79615f523a420b0958138c3f36f046831553/ATC.sol:StandardToken:approve(address,uint256)",4,4,1
"  function sub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:SafeMath:sub(uint256,uint256)","0x7dccb8c9639b50cfc33175307f0656d6eb5892ac/Coinasia.sol:SafeMath:sub(uint256,uint256)",5,5,1
"    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:SafeMath:add(uint256,uint256)","0x7fccf800568747b178c6cbbe4bf3d147df75ac61/CBCToken.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x2c7ad26f46e53eff2f06e10b83ea413f14706585/ERC20Token.sol:StandardToken:balanceOf(address),0x5Fe56CB82b3D88B6e37d3A9Dba8f5b40b28dDA7E/CmctSale.sol:BasicToken:balanceOf(address),5,5,1
"  function balanceOf(address _owner) public constant returns (uint256 balance) {

    return balances[_owner];

  }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x0f42d209fc46f678e8d31717d7ce14c69724a60e/SAATCoin.sol:BasicToken:balanceOf(address),0x6e968321cf36846a54917bf85c91e21a032fedb8/OmenoToken.sol:StandardToken:balanceOf(address),5,5,1
" function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
        return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b);
        return c;
    }
","0x2c0c9c1939dffb7c303307554cceae1c04370b39/PGTBToken.sol:SafeMath:mul(uint256,uint256)","0x03cc979c46b030c4abd7d4063cd075cb38cd0919/Exchange.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2AeD2725378013f66a2462D7C6B0F365494Cdc0c/WXC.sol:WXC:approve(address,uint256)","0x1bb491fb9167b09dda879f938d28acc95fc2a1a2/Plutaneum.sol:StandardToken:approve(address,uint256)",5,5,1
"    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x5ee9bf058b4deebf04756ca262c70232494783f0/MIAMIcoin.sol:Owned:transferOwnership(address),0x1bd49ed82e56061a3cc72feeec729eb65cceb9d3/HIROTOKEN.sol:Owned:transferOwnership(address),5,5,1
"  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","0x0ccf3426755c88f85445e325f6f0f413e3375b49/AifiToken.sol:StandardToken:increaseApproval(address,uint256)","0x8c5a05b691288f85e6e27bf6b5a454d2814f5a6f/WubCoin.sol:ERC20CompatibleToken:increaseApproval(address,uint256)",4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool) {
        if (approve(_spender, _value)) {
            TokenRecipient spender = TokenRecipient(_spender);
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        return false;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x3c7916a935faedd57bd8e3a91daf5c081f723855/PowerToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)","0x4ce47b4e5f0ee1118b6a064dbb3b3ed2edcffd9f/BelriumToken.sol:BelriumToken:approveAndCall(address,uint256,bytes)",4,4,1
"function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
",0x7d89c06e55dfb8c9de313b2f987a169e4992730b/CowrieToken.sol:StandardToken:balanceOf(address),0x6a85f717aaa16a9050858be9415eb213dfc1957a/XpressToken.sol:BasicToken:balanceOf(address),5,5,1
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x0b3a0edd51ee5e7900666bbfdf139ea55ccf0ca0/Team.sol:SafeMath:mul(uint256,uint256)","0x4e3b8c663d1a6620730dd68d65966b867d9e2f80/ListingsERC20.sol:SafeMath:mul(uint256,uint256)",5,5,1
"  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      Freeze ();
    }
  }
","  function freezeTransfers () public {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      Freeze ();
    }
  }
",0x0f71fda4987069d5cc1d0e6c234fd01675947b5e/LIDToken.sol:LIDToken:freezeTransfers(),0x7b0c06043468469967dba22d1af33d77d44056c8/MorpheusToken.sol:MorpheusToken:freezeTransfers(),5,5,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a / b; return c;}
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x2f3abc0a1cf1d7d0487fd220aa3283a63982ba60/Coinage.sol:SafeMath:div(uint256,uint256)","0x7b06ad092541635cf83a1ff03daf713269d94a15/IouRootsPresaleToken.sol:SafeMath:div(uint256,uint256)",5,5,1
"    function balanceOf(address _owner) constant returns (uint balance) {
        return balances[_owner];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x3cf6f11a4940dd8bf2e6eea46e30d8f76fa84daf/TonCoin.sol:StandardToken:balanceOf(address),0x05a0ea0e87d273e6a1fe04ca8b5a795422d7507b/HawalaToken.sol:StandardToken:balanceOf(address),4,4,1
"    function safeSub(uint256 a, uint256 b) internal returns (uint256) {
        assert(a >= b);
        return a - b;
    }
","    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x5be015eb0be828742b1e9ff9f784ea51e540b6e8/LooksCoin.sol:SafeMath:safeSub(uint256,uint256)","0x5f5d0767fb8ba2c2793bf7957993a63b5e67d92b/CryptoBotsIdleToken.sol:CryptoBotsIdleToken:safeSub(uint256,uint256)",4,4,1
