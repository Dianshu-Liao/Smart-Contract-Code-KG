function1 code,function2 code,function1 FEN,function2 FEN,rate,label1,label2,label
"	function	PI_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
","	function	getPI_edit_29	()	public	constant	returns	(	string	)	{
		return	inPI_edit_29	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:PI_EDIT_1(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_29(),1.0,5,5,1
"    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
",0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:getTokens(),0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:canDistr(),1.0,5,5,1
"  modifier onlyPayloadSize(uint size) {
     require(msg.data.length >= size + 4);
     _;
  }
","  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
",0x7aa90a794ed8fdb030936193dd01672a2d2ac852/MagnaChain.sol:BasicToken:onlyPayloadSize(uint256),0x7aa90a794ed8fdb030936193dd01672a2d2ac852/MagnaChain.sol:BasicToken:balanceOf(address),0.30952380952380953,4,4,0
"    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        emit MintFinished();
        return true;
    }
","    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowance[_owner][_spender];
    }
",0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:finishMinting(),"0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:allowance(address,address)",0.09693877551020408,4,4,0
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:transfer(address,uint256)",0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:withdrawForeignTokens(address),0.7857142857142857,4,4,0
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","0x2e127da05768e3e1609569dc5fa2494e4e97d1cb/PrinceberkToken.sol:PrinceberkToken:transfer(address,uint256)","0x2e127da05768e3e1609569dc5fa2494e4e97d1cb/PrinceberkToken.sol:PrinceberkToken:approveAndCall(address,uint256,bytes)",0.9689655172413794,4,4,1
"	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}
","	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpDataStorage:BdpDataStorage(bytes8),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpDataStorage:getLastRegionId(),1.0,4,4,1
"    function GA_chain() {
        balanceOf[msg.sender] =  1800000000 * 1000000000000000000;              // Give the creator all initial tokens
        totalSupply =  1800000000 * 1000000000000000000;                        // Update total supply
        name = ""GA_chain"";                                   // Set the name for display purposes
        symbol = ""GAC"";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    }
","    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
",0x0a3454b1c30f956f52f6a5b712b390b243ecd288/GA_chain.sol:GA_chain:GA_chain(),"0x0a3454b1c30f956f52f6a5b712b390b243ecd288/GA_chain.sol:GA_chain:transfer(address,uint256)",0.9333333333333332,4,4,1
"  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","0x02ed9b30e7fb4d4e06495c96810aeb2fac8b2989/SENSToken.sol:SafeMath:max64(uint64,uint64)","0x02ed9b30e7fb4d4e06495c96810aeb2fac8b2989/SENSToken.sol:SafeMath:add(uint256,uint256)",0.4324324324324325,4,4,0
"    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
","    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
",0x6d009ecf0cb74554f1460fdf9ec7b24fd577d3f3/NePayReborn.sol:NePayReborn:finishDistribution(),0x6d009ecf0cb74554f1460fdf9ec7b24fd577d3f3/NePayReborn.sol:NePayReborn:canDistr(),1.0,4,4,1
"    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
","    function DHAMAR() public {
        owner = activityFunds;
        
        balanceOf[founder] = totalSupply.mul(25).div(100);
        balanceOf[preSeasonGame] = totalSupply.mul(55).div(100);
        balanceOf[activityFunds] = totalSupply.mul(10).div(100);
        balanceOf[lockedFundsForthefuture] = totalSupply.mul(10).div(100);
    }
",0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:finishMinting(),0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:DHAMAR(),0.010101010101010102,4,4,0
"    function isContract(address _addr) constant internal returns(bool) {
        uint size;
        if (_addr == 0) return false;
        assembly {
            size := extcodesize(_addr)
        }
        return size>0;
    }
","    function transferFrom(address _from, address _to, uint256 _amount
    ) returns (bool success) {

        // The controller of this contract can move tokens around at will,
        //  this is important to recognize! Confirm that you trust the
        //  controller of this contract, which in most situations should be
        //  another open source smart contract or 0x0
        if (msg.sender != controller) {
            if (!transfersEnabled) throw;

            // The standard ERC 20 transferFrom functionality
            if (allowed[_from][msg.sender] < _amount) return false;
            allowed[_from][msg.sender] -= _amount;
        }
        return doTransfer(_from, _to, _amount);
    }
",0x1B9743f556D65e757c4c650B4555bAF354cB8bd3/ETBSToken.sol:MiniMeToken:isContract(address),"0x1B9743f556D65e757c4c650B4555bAF354cB8bd3/ETBSToken.sol:MiniMeToken:transferFrom(address,address,uint256)",0.0,4,4,0
"  function releaseTokenTransfer() public onlyCrowdsaleAgent {
    released = true;
  }
","  function balanceOf(address _owner) constant public returns (uint balance) {
    return balances[_owner].value;
  }
",0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:TokenAdrToken:releaseTokenTransfer(),0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:TokenAdrToken:balanceOf(address),0.05,4,4,0
"    function sub(uint256 x, uint256 y) internal pure returns (uint256) {
        uint256 z = x - y;
        require(x >= y && z <= x);
        return z;
    }
","    function add(uint256 x, uint256 y) internal pure returns (uint256) {
        uint256 z = x + y;
        require(z >= x && z>=y);
        return z;
    }
","0x1af8f3265d8274bde624edd9ec97f852fa4a5856/MOREToken.sol:MOREToken:sub(uint256,uint256)","0x1af8f3265d8274bde624edd9ec97f852fa4a5856/MOREToken.sol:MOREToken:add(uint256,uint256)",0.2307692307692308,4,4,0
"    modifier onlyOwner {
        if(owner != msg.sender) revert();
        _;
    }
","    function changePhaseToICO() external onlyOwner returns (bool){
        currentPhase = Phase.ICO;
        return true;
    }
",0x08a4d2372777267373ff0fbf80fa278b2846c087/Gmt.sol:Gmt:onlyOwner(),0x08a4d2372777267373ff0fbf80fa278b2846c087/Gmt.sol:Gmt:changePhaseToICO(),0.004830917874396135,4,4,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        if (msg.sender != owner) { revert(); }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function disablePurchasing() {
        if (msg.sender != owner) { revert(); }
        purchasingAllowed = false;
    }
","0x3f17af8d4e950ecce6f24bfaf0e43a56d8fb3491/PrayersTokenICO.sol:PrayersTokenICO:approve(address,uint256)",0x3f17af8d4e950ecce6f24bfaf0e43a56d8fb3491/PrayersTokenICO.sol:PrayersTokenICO:disablePurchasing(),0.0,4,4,0
"    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","0x8acfc0d6ddddcddaac8d5c88d281a95278e2bec5/AirDropToken.sol:SafeMath:safeMul(uint256,uint256)","0x8acfc0d6ddddcddaac8d5c88d281a95278e2bec5/AirDropToken.sol:SafeMath:safeAdd(uint256,uint256)",0.4929859719438878,4,4,0
"    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[4],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)",1.0,4,4,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x3eb21f4678b352fcd8facf06b642c6720e04961b/Alpha.sol:Alpha:transferFrom(address,address,uint256)",0x3eb21f4678b352fcd8facf06b642c6720e04961b/Alpha.sol:Alpha:totalSupply(),0.9655172413793104,4,4,1
"    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[4])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])",1.0,4,4,1
"  function finishMinting() public onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
","    function haltDirectTrade() onlyOwner public {
        directTradeAllowed = false;
    }
",0x5e441B5C140034B179E2FabC96F1a29e14dBc47A/ClimateCoinToken.sol:ClimateCoinToken:finishMinting(),0x5e441B5C140034B179E2FabC96F1a29e14dBc47A/ClimateCoinToken.sol:ClimateCoinToken:haltDirectTrade(),0.0,4,4,0
"  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
","  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met
    // if (_value > _allowance) throw;

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }
",0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:StandardToken:balanceOf(address),"0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:StandardToken:transferFrom(address,address,uint256)",0.025809716599190284,4,4,0
"  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:SafeMath:min256(uint256,uint256)","0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:SafeMath:max256(uint256,uint256)",1.0,4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x4bbdeadf8334e8a85d3e22ec090af74c3a673118/YesNo.sol:StandardToken:transferFrom(address,address,uint256)","0x4bbdeadf8334e8a85d3e22ec090af74c3a673118/YesNo.sol:StandardToken:approve(address,uint256)",0.9813753581661891,4,4,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x6af777c884f426b7a2f2d71cd8fff12e07762171/MajestyAssetsJunction.sol:MajestyAssetsJunction:approveAndCall(address,uint256,bytes)","0x6af777c884f426b7a2f2d71cd8fff12e07762171/MajestyAssetsJunction.sol:MajestyAssetsJunction:transferAnyERC20Token(address,uint256)",0.9663299663299664,4,4,1
"    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[4],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[4])",1.0,4,4,1
"    function MultiOwnable() {
        // Add default owner
        address owner = msg.sender;
        ownerMap[owner] = true;
        owners.push(owner);
    }
","    function addOwner(address owner) onlyOwner returns (bool) {
        if (!isOwner(owner) && owner != 0) {
            ownerMap[owner] = true;
            owners.push(owner);

            OwnerAdded(owner);
            return true;
        } else return false;
    }
",0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:MultiOwnable:MultiOwnable(),0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:MultiOwnable:addOwner(address),1.0,4,4,1
"	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}
","	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}
","0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:pushOwnedToken(address,uint256)",0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:getTokenIdsIndex(uint256),1.0,4,4,1
"    function randomDS_getSessionPubKeyHash()
    external
    constant
    returns (bytes32) {
        uint i = uint(sha3(reqc[msg.sender]))%randomDS_sessionPubKeysHash.length;
        return randomDS_sessionPubKeysHash[i];
    }
","    function getCodeSize(address _addr)
    private
    constant
    returns(uint _size)
    {
        assembly {
            _size := extcodesize(_addr)
        }
    }
",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:randomDS_getSessionPubKeyHash(),0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:getCodeSize(address),1.0,4,4,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyNewOwner() {
        require(msg.sender != address(0));
        require(msg.sender == newOwner);
        _;
    }
",0x1a66e09f7dccc10eae46e27cfa6b8d44a50df1e7/PRASMToken.sol:Ownable:onlyOwner(),0x1a66e09f7dccc10eae46e27cfa6b8d44a50df1e7/PRASMToken.sol:Ownable:onlyNewOwner(),0.0004741583688952111,4,4,0
"    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","    function symbol() public view returns (string _symbol) {
        return symbol;
    }
",0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:DIETSweets:totalSupply(),0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:DIETSweets:symbol(),0.4606741573033708,4,4,0
"    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;

        bytes32 sigr;
        bytes32 sigs;

        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }


        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(sha3(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(sha3(pubkey)) == signer);
        }
    }
","    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:verifySig(bytes32,bytes,bytes)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[],uint256)",1.0,4,4,1
"  function changeFeeAccount(address feeAccount_) onlyAdmin {
    feeAccount = feeAccount_;
  }
","  constructor(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {
    admin = admin_;
    feeAccount = feeAccount_;
    accountLevelsAddr = accountLevelsAddr_;
    feeMake = feeMake_;
    feeTake = feeTake_;
    feeRebate = feeRebate_;
  }
",0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:changeFeeAccount(address),"0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:constructor(address,address,address,uint256,uint256,uint256)",1.0,4,4,1
"  function addAdmin(address addr)
    public
    onlyAdmin
  {
    addRole(addr, ROLE_ADMIN);
  }
","  function delAdmin(address addr)
    public
    onlyAdmin
  {
    removeRole(addr, ROLE_ADMIN);
  }
",0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:VeraCrowdsale:addAdmin(address),0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:VeraCrowdsale:delAdmin(address),1.0,4,4,1
"    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false 
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender] 
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:transferToAddress(address,uint256,bytes)","0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:transfer(address,uint256,bytes,string)",0.7083333333333334,4,4,0
"    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
        //Scarcecoin - Modified to mint
        if(msg.sender == _to) return mint();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
        uint64 _now = uint64(now);
        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));
        transferIns[_to].push(transferInStruct(uint128(_value),_now));
        return true;
    }
","    function annualInterest() constant returns(uint interest) {
        uint _now = now;
        interest = maxMintProofOfStake;
        //Scarcecoin - Modified initial interest rate to 100%
        if((_now.sub(stakeStartTime)).div(1 years) == 0) {
            interest = (770 * maxMintProofOfStake).div(100);
        } else if((_now.sub(stakeStartTime)).div(1 years) == 1) {
            interest = (435 * maxMintProofOfStake).div(100);
        } 
    }
","0x0df600c873da796c3ef6d6a0472772eb954d6986/ScarceCoinToken.sol:ScarceCoinToken:transfer(address,uint256)",0x0df600c873da796c3ef6d6a0472772eb954d6986/ScarceCoinToken.sol:ScarceCoinToken:annualInterest(),0.631578947368421,4,4,0
"    function split(slice self, slice needle) internal returns (slice token) {
        split(self, needle, token);
    }
","    function toString(slice self) internal returns (string) {
        var ret = new string(self._len);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        memcpy(retptr, self._ptr, self._len);
        return ret;
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:split(strings:slice,strings:slice)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:toString(strings:slice),0.6666666666666666,4,4,0
"  modifier whenNotPaused() {
    require(!paused);
    _;
  }
","  function pause() public onlyOwner whenNotPaused returns(bool) {
    paused = true;
    emit Pause();
    return true;
  }
",0x6b7e3c3ad124af008b61d0afe93437d0218a0cf8/PayChainCoin.sol:Pausable:whenNotPaused(),0x6b7e3c3ad124af008b61d0afe93437d0218a0cf8/PayChainCoin.sol:Pausable:pause(),0.09965635738831616,4,4,0
"    function safeSub(uint a, uint b) internal returns (uint) {
        require(b <= a);
        return a - b;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x1cf594f4c97e8a32abd7b456af0419f484747455/PlusCoin.sol:PlusCoin:safeSub(uint256,uint256)","0x1cf594f4c97e8a32abd7b456af0419f484747455/PlusCoin.sol:PlusCoin:approve(address,uint256)",0.011363636363636364,4,4,0
"  function withdraw(uint amount) {
    if (tokens[0][msg.sender] < amount) throw;
    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
    if (!msg.sender.call.value(amount)()) throw;
    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
  }
","  function changeFeeAccount(address feeAccount_) {
    if (msg.sender != admin) throw;
    feeAccount = feeAccount_;
  }
",0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:withdraw(uint256),0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:changeFeeAccount(address),0.75,4,4,0
"    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmin(x, y);
    }
","    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","0x0d88ed6e74bbfd96b831231638b66c05571e824f/DSToken.sol:DSMath:wmin(uint128,uint128)","0x0d88ed6e74bbfd96b831231638b66c05571e824f/DSToken.sol:DSMath:hsub(uint128,uint128)",0.8,2,2,0
"    function transfer(Data storage self, address to, uint tokens) public returns (bool success) {
        // Owner and minter can move tokens before the tokens are transferable
        require(self.transferable || (self.mintable && (msg.sender == self.owner  || msg.sender == self.minter)));
        require(!self.accountLocked[msg.sender]);
        self.balances[msg.sender] = safeSub(self.balances[msg.sender], tokens);
        self.balances[to] = safeAdd(self.balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {
        require(msg.sender == self.owner);
        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:transfer(BTTSLib:Data,address,uint256)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:transferAnyERC20Token(BTTSLib:Data,address,uint256)",1.0,4,4,1
"	function	setData_10	(	string	newData_10	)	public	onlyOwner	{		
		inData_10	=	newData_10	;						
	}										
","		function	Eligibility_Group_5				(				
			address	_User_5		,					
			IERC20Token	_Securities_5		,					
			uint256	_Standard_5							
		)									
			public	onlyOwner							
		{									
			User_5		=	_User_5		;			
			Securities_5		=	_Securities_5		;			
			Standard_5		=	_Standard_5		;			
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setData_10(string),"0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:Eligibility_Group_5(address,IERC20Token,uint256)",0.0,2,2,0
"  function Ownable() {
    owner = msg.sender;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x6f1a769952c60b2d03f46419adeda91d87866dab/ELiteCoin.sol:Ownable:Ownable(),0x6f1a769952c60b2d03f46419adeda91d87866dab/ELiteCoin.sol:Ownable:onlyOwner(),0.9294003868471954,4,4,1
"    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[2])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[])",1.0,4,4,1
"	function offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)
		{
			Interface c = Interface(_contract);
			c.offerPieceForSale(_price);
		}
","	function burnByAddress (address _contract, uint256 _amount) onlyBy (owner)
		{
			Interface c = Interface(_contract);
			c.burn(_amount);
		}
","0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:offerPieceForSaleByAddress(address,uint256)","0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:burnByAddress(address,uint256)",1.0,4,4,1
"    modifier notTooSmallAmountOnly(){
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }
","    function cfi_whitelist(address addr) public constant returns(bool) { return PRIORITY_ADDRESS_LIST.contains(addr); }
",0x6be4e8a44c9d22f39db262cf1a54c1172da3b864/CrowdsaleMinter.sol:CrowdsaleMinter:notTooSmallAmountOnly(),0x6be4e8a44c9d22f39db262cf1a54c1172da3b864/CrowdsaleMinter.sol:CrowdsaleMinter:cfi_whitelist(address),0.16666666666666666,2,2,0
"	function	POOL_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
","	function	getPOOL_edit_13	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_13	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:POOL_EDIT_1(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_13(),1.0,4,4,1
"  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SafeMath:max256(uint256,uint256)","0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SafeMath:max64(uint64,uint64)",0.8342857142857143,2,2,0
"    function sell(uint256 amount) canTransfer public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
","    function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner public {
        crowdsaleAgent = _crowdsaleAgent;
    }
",0x06f726f750dd2a140a3f3bbe1fa58b624b361a33/RajTestICO.sol:RajTest:sell(uint256),0x06f726f750dd2a140a3f3bbe1fa58b624b361a33/RajTestICO.sol:RajTest:setCrowdsaleAgent(address),0.0,2,2,0
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x1a980d8b8643f807a0d0acbe9b0ed2c26f03868b/WZCoinToken.sol:StandardToken:balanceOf(address),"0x1a980d8b8643f807a0d0acbe9b0ed2c26f03868b/WZCoinToken.sol:StandardToken:transfer(address,uint256)",0.2269969666329626,2,2,0
"    function setOwner(address _owner) isCreator public {
        owner = _owner;      
    }
","    function kill() isCreator public {
        selfdestruct(owner);
    }
",0x01ef10e16d9a6ec00d150d52fcad6f8327851b30/CLVRCrowdsale.sol:CLVRCrowdsale:setOwner(address),0x01ef10e16d9a6ec00d150d52fcad6f8327851b30/CLVRCrowdsale.sol:CLVRCrowdsale:kill(),0.7142857142857143,2,2,0
"  function getBlockNumber() internal constant returns (uint) {
    return block.number;
  }
","  function min(uint a, uint b) internal pure returns (uint) {
    return a < b ? a : b;
  }
",0x1d95a10ee67595aee46f82983c567b92f5e6534a/Voting.sol:Voting:getBlockNumber(),"0x1d95a10ee67595aee46f82983c567b92f5e6534a/Voting.sol:Voting:min(uint256,uint256)",0.5,2,2,0
"    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setNetworkName(string),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:ecrecovery(bytes32,bytes)",1.0,4,4,1
"		function	getData_9	()	public	constant	returns	(	string	)	{
			return	inData_9	;						
		}									
","		function	setData_9	(	string	newData_9	)	public	onlyOwner	{	
			inData_9	=	newData_9	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_9(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_9(string),1.0,4,4,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x3f45d3b92976b02c4ce587df68b9c7943ff7efc3/TSCoin.sol:StandardToken:decreaseApproval(address,uint256)","0x3f45d3b92976b02c4ce587df68b9c7943ff7efc3/TSCoin.sol:StandardToken:allowance(address,address)",0.9477434679334916,2,2,0
"    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x4d6445C92aE02748105C73EE97E8327E726e465c/FMLY.sol:SafeMath:add(uint256,uint256)","0x4d6445C92aE02748105C73EE97E8327E726e465c/FMLY.sol:SafeMath:mul(uint256,uint256)",0.7943820224719101,2,2,0
"    function safeSub(uint a, uint b) public pure returns (uint) {
    assert(b <= a);
    return a - b;
  }
","    function safeAdd(uint a, uint b) public pure returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","0x3c63d4b0330a1ab969ff0f8b2ba227540a15b0ca/SpanCoin.sol:safemath:safeSub(uint256,uint256)","0x3c63d4b0330a1ab969ff0f8b2ba227540a15b0ca/SpanCoin.sol:safemath:safeAdd(uint256,uint256)",0.7826086956521741,4,4,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x6feb3a071a2732378521c53d024b67ad068ec921/RamenCoin.sol:RamenCoin:add(uint256,uint256)","0x6feb3a071a2732378521c53d024b67ad068ec921/RamenCoin.sol:RamenCoin:sub(uint256,uint256)",0.9747191011235956,4,4,1
"	function	getPI_edit_28	()	public	constant	returns	(	string	)	{
		return	inPI_edit_28	;						
	}									
","	function	setPI_edit_9	(	string	newPI_edit_9	)	public	onlyOwner	{	
		inPI_edit_9	=	newPI_edit_9	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_28(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_9(string),1.0,4,4,1
"    function donateToWhale(uint256 amount) 
    internal 
    {
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));
        totalDonated += amount;
        emit Donate(amount, whale, msg.sender);
    }
","    function AdjustDifficulty(uint256 amount) 
    onlyOwner()
    public
    {
        difficulty = amount;
        
        emit DifficultyChanged(difficulty);
    }
",0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:donateToWhale(uint256),0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:AdjustDifficulty(uint256),0.5,2,2,0
"    function callBtoWithSto(
        uint    amount,
        uint    expiration,
        bytes32 nonce,
        uint    price,
        uint    size,
        uint    strike,
        uint    validUntil,
        bytes32 r,
        bytes32 s,
        uint8   v
    ) public hasFee(amount) {
        bytes32 h = keccak256(Action.SellCallToOpen, expiration, nonce, price, size, strike, validUntil, this);
        address maker = _getMaker(h, v, r, s);

        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);
        _buyCallToOpen(amount, expiration, price, strike, msg.sender);
        _sellCallToOpen(amount, expiration, price, strike, maker);
    }
","    function settlePut(uint expiration, uint strike, address writer) public {
        require(msg.sender == writer || isAuthorized(msg.sender, msg.sig), ""Unauthorized"");
        require(now > expiration, ""Expired"");

        bytes32 series = keccak256(expiration, strike);
        require(putsSold[series][writer] > 0);

        if (putsAssigned[series] < putsExercised[series]) {
            uint maximum = putsSold[series][writer];
            uint needed = putsExercised[series].sub(putsAssigned[series]);
            uint assignment = maximum.min(needed);

            totalDai[writer] = totalDai[writer].sub(assignment.mul(strike).div(1 ether));
            putsSold[series][writer] = putsSold[series][writer].sub(assignment);
            putsAssigned[series] = putsAssigned[series].add(assignment);

            _addEth(assignment, writer);
            emit AssignPut(writer, assignment, expiration, strike);
        }

        uint yield = putsSold[series][writer].mul(strike).div(1 ether);
        _collectFee(writer, settlementFee);
        dai[writer] = dai[writer].add(yield);
        putsSold[series][writer] = 0;
        emit SettlePut(writer, expiration, strike);
    }
","0x03cc979c46b030c4abd7d4063cd075cb38cd0919/Exchange.sol:Exchange:callBtoWithSto(uint256,uint256,bytes32,uint256,uint256,uint256,uint256,bytes32,bytes32,uint8)","0x03cc979c46b030c4abd7d4063cd075cb38cd0919/Exchange.sol:Exchange:settlePut(uint256,uint256,address)",1.0,4,4,1
"  function approveAndCall(
    address _spender,
    uint256 _value,
    bytes _data
  )
    public
    payable
    whenNotPaused
    returns (bool)
  {
    return super.approveAndCall(_spender, _value, _data);
  }
","  function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public
    payable
    whenNotPaused
    returns (bool)
  {
    return super.transferFromAndCall(_from, _to, _value, _data);
  }
","0x0a8b758bbc4a5791c5647ca80351e008f1e3bca1/ItemToken.sol:EverGold:approveAndCall(address,uint256,bytes)","0x0a8b758bbc4a5791c5647ca80351e008f1e3bca1/ItemToken.sol:EverGold:transferFromAndCall(address,address,uint256,bytes)",1.0,4,4,1
"  function setOwners(address[] _owners) internal {
    for (uint i = 0; i < _owners.length; i++) {
      require(_owners[i] != address(0));
      isOwner[_owners[i]] = true;
      OwnerAddition(_owners[i]);
    }
    owners = _owners;
  }
","  function removeOwner(address _owner) public onlyOwner {
    require(owners.length > 1);
    isOwner[_owner] = false;
    for (uint i = 0; i < owners.length - 1; i++) {
      if (owners[i] == _owner) {
        owners[i] = owners[SafeMath.sub(owners.length, 1)];
        break;
      }
    }
    owners.length = SafeMath.sub(owners.length, 1);
    OwnerRemoval(_owner);
  }
",0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4/TokenLock.sol:Owned:setOwners(address[]),0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4/TokenLock.sol:Owned:removeOwner(address),1.0,4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x6b8323684fcb595d0ef03d1b686845722433791a/JetToken.sol:StandardToken:transfer(address,uint256)","0x6b8323684fcb595d0ef03d1b686845722433791a/JetToken.sol:StandardToken:allowance(address,address)",0.9776632302405498,4,4,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x2e1ce8b63c1c152532b4fe4dee4715655ba8c35f/UmmahDinar.sol:UmmahDinar:transferFrom(address,address,uint256)","0x2e1ce8b63c1c152532b4fe4dee4715655ba8c35f/UmmahDinar.sol:UmmahDinar:approve(address,uint256)",1.0,4,4,1
"    function attachSubscriptionModule(SubscriptionModule subModule)
    noAnyReentrancy
    external
    only(owner) {
        SUBSCRIPTION_MODULE = subModule;
        if (address(subModule) > 0) subModule.attachToken(this);
    }
","    function _burnForDeposit(address owner, uint amount)
    public
    onlyTrusted
    returns (bool success) {
        if (balances[owner] >= amount) {
            balances[owner] -= amount;
            totalOnDeposit += amount;
            totalInCirculation -= amount;
            return true;
        } else { return false; }
    }
",0x2d4370400cdcbec8f26ee4face1fa120227271e4/SAN.sol:SAN:attachSubscriptionModule(SubscriptionModule),"0x2d4370400cdcbec8f26ee4face1fa120227271e4/SAN.sol:SAN:_burnForDeposit(address,uint256)",1.0,4,4,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    if((now>=transferOpenTimes)&&(now<=transferCloseTimes))
    {
      return false;
    }else
    {

     require(_to != address(0));
     require(_value <= balances[_from]);
     require(_value <= allowed[_from][msg.sender]);

     balances[_from] = balances[_from].sub(_value);
     balances[_to] = balances[_to].add(_value);
     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
     emit Transfer(_from, _to, _value);
     return true;
    }
  }
","0x2db48cb78c7541e9ebfb79b3797d99b8b6fd7fd2/OREX.sol:StandardToken:increaseApproval(address,uint256)","0x2db48cb78c7541e9ebfb79b3797d99b8b6fd7fd2/OREX.sol:StandardToken:transferFrom(address,address,uint256)",0.027060270602706032,2,2,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
",0x3cba7924c6c8ca8e8bc39557debe1369b688866e/MoneroClassic.sol:MoneroClassic:burn(uint256),"0x3cba7924c6c8ca8e8bc39557debe1369b688866e/MoneroClassic.sol:MoneroClassic:burnFrom(address,uint256)",0.8990610328638498,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x4ee18f80c4c6e1e7ecb32f2fb6393486924679ac/Etheriumhit.sol:StandardToken:transferFrom(address,address,uint256)","0x4ee18f80c4c6e1e7ecb32f2fb6393486924679ac/Etheriumhit.sol:StandardToken:allowance(address,address)",0.978021978021978,4,4,1
"    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
","    modifier onlyOwner{
        require(msg.sender == owner);
        _;
    }
",0x2c1bf16a6ab64c2d55d916ba928138e488d3785a/XRTToken.sol:Owned:transferOwnership(address),0x2c1bf16a6ab64c2d55d916ba928138e488d3785a/XRTToken.sol:Owned:onlyOwner(),0.8593996840442338,4,4,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x2b4ab685a8773ae154bec7b0a1d1931cc29684ac/freeXLMG.sol:freeXLMG:transferFrom(address,address,uint256)","0x2b4ab685a8773ae154bec7b0a1d1931cc29684ac/freeXLMG.sol:freeXLMG:allowance(address,address)",0.9913793103448276,4,4,1
"    function isContract(address _addr) constant internal returns (bool) {
        if (_addr == 0) return false;
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }
","    modifier noReentrancy(uint m) {
        var _locks = bitlocks;
        if (_locks & m > 0) throw;
        bitlocks |= m;
        _;
        bitlocks = _locks;
    }
",0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:Base:isContract(address),0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:Base:noReentrancy(uint256),0.38461538461538464,2,2,0
"   modifier onlyOwner()
    {
        require((msg.sender == owner) || (msg.sender ==  bkaddress));
        _;
    }
","    function balanceOf(address _owner) public constant returns (uint256 balance) 
        {
            return balanceOf[_owner];
        }
",0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:onlyOwner(),0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:balanceOf(address),0.0625,2,2,0
"    function Ownable(){
        owner = msg.sender;
    }
","    modifier onlyOwner(){
        if(msg.sender != owner){
            throw;
        }
        _;
    }
",0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:Ownable:Ownable(),0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:Ownable:onlyOwner(),0.0609284332688588,2,2,0
"	function set_tokens_received() onlyOwner {
		tokens_received();
	}
","	function emergency_token_withdraw(address _address) onlyOwner {
	 	ERC20 temp_token = ERC20(_address);
		require(temp_token.transfer(msg.sender, temp_token.balanceOf(this)));
	}
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:set_tokens_received(),0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:emergency_token_withdraw(address),1.0,4,4,1
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_cbAddress(),0.8,2,2,0
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x4e9547d1a1154ee0451f063c253ad8dc39d5384c/ICO.sol:SafeMath:add(uint256,uint256)","0x4e9547d1a1154ee0451f063c253ad8dc39d5384c/ICO.sol:SafeMath:sub(uint256,uint256)",0.9747191011235956,5,5,1
"	function setDeveloper(address addr , bool status) public onlyOwner returns (bool) {
		developers[addr] = status;
		return true;
	}
","	function allowance(address approver, address spender) public constant returns (uint256) {
		return allowed[approver][spender];
	}
","0x2e62af2ad08239c528ee7ed72914dad6a897b1fd/CryptoToken.sol:CryptoToken:setDeveloper(address,bool)","0x2e62af2ad08239c528ee7ed72914dad6a897b1fd/CryptoToken.sol:CryptoToken:allowance(address,address)",0.0,2,2,0
"    function empty(slice self) internal returns (bool) {
        return self._len == 0;
    }
","    function count(slice self, slice needle) internal returns (uint count) {
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;
        while (ptr <= self._ptr + self._len) {
            count++;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;
        }
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:empty(strings:slice),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:count(strings:slice,strings:slice)",1.0,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x8a4aeb9455896e2cd498a9afc42a7f85638660eb/StockBetSale.sol:SafeMath:sub(uint256,uint256)","0x8a4aeb9455896e2cd498a9afc42a7f85638660eb/StockBetSale.sol:SafeMath:div(uint256,uint256)",0.738933030646992,2,2,0
"	function	setData_29	(	string	newData_29	)	public	onlyOwner	{	
		inData_29	=	newData_29	;					
	}									
","	function	setData_12	(	string	newData_12	)	public	onlyOwner	{	
		inData_12	=	newData_12	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_29(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_12(string),1.0,5,5,1
"  function add_to_bounty() payable {
    // Only allow the developer to contribute to the buy execution bounty.
    if (msg.sender != developer_address) throw;
    // Disallow adding to bounty if kill switch is active.
    if (kill_switch) throw;
    // Disallow adding to the bounty if contract has already bought the tokens.
    if (bought_tokens) throw;
    // Update bounty to include received amount.
    bounty += msg.value;
  }
","  modifier onlyOwner() {
    if (msg.sender != developer_address) {
      throw;
    }
    _;
  }
",0x1B455D30c2e46F6ecb6fA022791fa7C1bCe8bB62/ZiberToken.sol:ZiberToken:add_to_bounty(),0x1B455D30c2e46F6ecb6fA022791fa7C1bCe8bB62/ZiberToken.sol:ZiberToken:onlyOwner(),1.0,5,5,1
"    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function name() public constant returns (string) { return ""ANIMATIX""; }
","0x0cd161ef9eb19a95fefa69c36f9cf552c19e6b8f/AnimatixToken.sol:AnimatixToken:allowance(address,address)",0x0cd161ef9eb19a95fefa69c36f9cf552c19e6b8f/AnimatixToken.sol:AnimatixToken:name(),0.0013574660633484162,2,2,0
"	function	setPOOL_edit_14	(	string	newPOOL_edit_14	)	public	onlyOwner	{	
		inPOOL_edit_14	=	newPOOL_edit_14	;					
	}									
","	function	setPOOL_edit_27	(	string	newPOOL_edit_27	)	public	onlyOwner	{	
		inPOOL_edit_27	=	newPOOL_edit_27	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_14(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_27(string),1.0,5,5,1
"	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}
","	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getImagePartsCount(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getImageDescriptor(uint256),1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x5ed786a050c866703e16ad621b9259553a1188a9/ERONIUM.sol:SafeMath:mul(uint256,uint256)","0x5ed786a050c866703e16ad621b9259553a1188a9/ERONIUM.sol:SafeMath:div(uint256,uint256)",0.3127715030408341,2,2,0
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x5ed786a050c866703e16ad621b9259553a1188a9/ERONIUM.sol:SafeMath:mul(uint256,uint256)","0x5ed786a050c866703e16ad621b9259553a1188a9/ERONIUM.sol:SafeMath:div(uint256,uint256)",0.3127715030408341,2,2,0
"  function setKYCAdmin(address _address) external onlyBy(owner) {
    kycAdmin = _address;
  }
","  function removeFromWhitelist(address _beneficiary) public onlyBy(kycAdmin) {
    whitelist[_beneficiary] = false;
    emit RemoveFromWhitelist(_beneficiary);
  }
",0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:setKYCAdmin(address),0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:removeFromWhitelist(address),0.5,2,2,0
"    modifier whenNotHalted() {
        require(!halted);
        _;
    }
","    function proposeRewardsWithdrawal(address recipient) public onlyOwner {
        require(!rewardsWithdrawn);

        rewardsWithdrawalRecipient = recipient;
        rewardsWithdrawalProposed = true;
    }
",0x4d305c2334c02e44ac592bbea681ba4cc1576de3/RepuX.sol:RepuX:whenNotHalted(),0x4d305c2334c02e44ac592bbea681ba4cc1576de3/RepuX.sol:RepuX:proposeRewardsWithdrawal(address),0.0,2,2,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;          // Set allowance         
        Approval(msg.sender, _spender, _value);             // Raise Approval event         
        return true;
    }
","    function mintTokens(address _sendTo, uint256 _sendAmount)public onlyOwner {
        mintSBIToken(_sendTo, _sendAmount);
    }
","0x7b5271c23e0da39d17e04304c5ce651ed6074e8c/DASABI_IO_Contract.sol:DASABI_IO_Contract:approve(address,uint256)","0x7b5271c23e0da39d17e04304c5ce651ed6074e8c/DASABI_IO_Contract.sol:DASABI_IO_Contract:mintTokens(address,uint256)",0.0005356186395286557,2,2,0
"	function notePrepurchase(address _who, uint _etherPaid, uint _amberSold)
		only_prepurchaser
		only_before_period
		public
	{
		// Admin ensures bounded value.
		tokens.mint(_who, _amberSold);
		saleRevenue += _etherPaid;
		totalSold += _amberSold;
		Prepurchased(_who, _etherPaid, _amberSold);
	}
","	modifier only_certified(address who) { require (CERTIFIER.certified(who)); _; }
","0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:notePrepurchase(address,uint256,uint256)",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:only_certified(address),1.0,5,5,1
"  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x8a7b7b9b2f7d0c63f66171721339705a6188a7d5/EtherDoge.sol:StandardToken:allowance(address,address)","0x8a7b7b9b2f7d0c63f66171721339705a6188a7d5/EtherDoge.sol:StandardToken:transferFrom(address,address,uint256)",0.1683673469387755,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x1f5cdaaa54f19442b1b0b6fa7f489871fd7d86ec/EndoSHARD.sol:EndoSHARD:allowance(address,address)",0x1f5cdaaa54f19442b1b0b6fa7f489871fd7d86ec/EndoSHARD.sol:EndoSHARD:totalSupply(),0.8297872340425532,2,2,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7/YouAreRichToken.sol:YouAreRichToken:approve(address,uint256)","0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7/YouAreRichToken.sol:YouAreRichToken:allowance(address,address)",0.9777777777777776,5,5,1
"    function transferFrom(address _from, address _to, uint _value) public safe_arguments(3) returns (bool) {

        // Check if the sender has enough
        require(balances[_from] >= _value);

        // Check for overflows
        require(balances[_to] + _value >= balances[_to]);

        // Check allowance
        require(_value <= allowed[_from][msg.sender]);

        // Transfer tokens
        balances[_to] += _value;
        balances[_from] -= _value;

        // Update allowance
        allowed[_from][msg.sender] -= _value;

        // Notify listeners
        Transfer(_from, _to, _value);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return totalTokenSupply;
    }
","0x3e250a4f78410c29cfc39463a81f14a226690eb4/DRPSToken.sol:Token:transferFrom(address,address,uint256)",0x3e250a4f78410c29cfc39463a81f14a226690eb4/DRPSToken.sol:Token:totalSupply(),0.011976047904191616,2,2,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x4e3bcc324af823460c07fa6998ee5caa418a67bf/AsiaCoin.sol:StandardToken:transfer(address,uint256)","0x4e3bcc324af823460c07fa6998ee5caa418a67bf/AsiaCoin.sol:StandardToken:approve(address,uint256)",0.9742268041237112,5,5,1
"    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:uint2str(uint256),0.8,2,2,0
"  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","0x5d1f6e8143065f47723ea4cebf53f2ed24c003c6/Issuer.sol:SafeMath:min256(uint256,uint256)","0x5d1f6e8143065f47723ea4cebf53f2ed24c003c6/Issuer.sol:SafeMath:safeDiv(uint256,uint256)",0.2471264367816092,2,2,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Ownable:onlyOwner(),0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Ownable:transferOwnership(address),0.15979137031768612,2,2,0
"  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }
","  function UpgradeableToken(address _upgradeMaster) public {
    upgradeMaster = _upgradeMaster;
  }
",0x4b95ecf2a6ebf1371158b3f1a9ca32ce18d7c751/WeTestToken.sol:UpgradeableToken:getUpgradeState(),0x4b95ecf2a6ebf1371158b3f1a9ca32ce18d7c751/WeTestToken.sol:UpgradeableToken:UpgradeableToken(address),0.9444444444444444,2,2,0
"    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
","    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:__callback(bytes32,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[],uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function buy() payable public {
        uint amount = msg.value * buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:transferFrom(address,address,uint256)",0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:buy(),0.009280742459396751,2,2,0
"    function stra2cbor(string[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:stra2cbor(string[]),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string,string)",1.0,5,5,1
"	function safeSub(uint a, uint b) internal returns (uint) {
    	assert(b <= a);
    	return a - b;
  }
","    function assert(bool assertion) internal {
    if (!assertion) assert;
  }
","0x7abf8a69cba9dbf808b5984624eb55a528ea44f2/Petro.sol:SafeMath:safeSub(uint256,uint256)",0x7abf8a69cba9dbf808b5984624eb55a528ea44f2/Petro.sol:SafeMath:assert(bool),0.010869565217391304,2,2,0
"    modifier whenNotPaused() {
        require(!paused);
        _;
    }
","    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
",0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:whenNotPaused(),"0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:increaseApproval(address,uint256)",0.006872852233676976,2,2,0
"	function purchaseTo(address _recipient)
		only_certified(msg.sender)
		payable
		public
	{
		processPurchase(_recipient);
	}
","	modifier when_allocatable_locked(uint amount) { require (lockedAllocatable >= amount); _; }
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:purchaseTo(address),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:when_allocatable_locked(uint256),1.0,5,5,1
"    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:strConcat(string,string,string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[2])",0.4444444444444444,4,4,0
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
",0x3c77312be032b7e36b57b5a9a44fed9fb3d59771/HJHToken.sol:HJHToken:onlyWhitelist(),"0x3c77312be032b7e36b57b5a9a44fed9fb3d59771/HJHToken.sol:HJHToken:getTokenBalance(address,address)",0.8333333333333334,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string,uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x7b558299f9befecebb28ca6243c851f070e555b2/RepostiX.sol:RepostiX:transferFrom(address,address,uint256)","0x7b558299f9befecebb28ca6243c851f070e555b2/RepostiX.sol:RepostiX:transfer(address,uint256)",0.2647058823529412,4,4,0
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
","    function transfer(address _to, uint256 _value) public whenNotPaused {
        if(_to == address(this)){
            sell(_value);
        }else{
            _transfer(msg.sender, _to, _value);
        }
    }
","0x7b606bc8ce7ba370b14bf5b43d1987cbaadc8d6d/DunkPayToken.sol:DunkPayToken:freezeAccount(address,bool)","0x7b606bc8ce7ba370b14bf5b43d1987cbaadc8d6d/DunkPayToken.sol:DunkPayToken:transfer(address,uint256)",0.004878048780487805,4,4,0
"    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x7a3a93891a6f407fa8af8a6b3f3663571fba5646/MacQueenToken.sol:MacQueenToken:totalSupply(),0x7a3a93891a6f407fa8af8a6b3f3663571fba5646/MacQueenToken.sol:MacQueenToken:onlyOwner(),0.07462686567164177,4,4,0
"	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}
","	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:getTokenOwner(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:getTokenIdsLength(),1.0,5,5,1
"    function updatePartner2_vows(string _partner2_vows) public {
        require((msg.sender == owner || msg.sender == partner2_address) && (bytes(partner2_vows).length == 0));
        partner2_vows = _partner2_vows;
    }
","    function updatePartner1_vows(string _partner1_vows) public {
        require((msg.sender == owner || msg.sender == partner1_address) && (bytes(partner1_vows).length == 0));
        partner1_vows = _partner1_vows;
    }
",0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:updatePartner2_vows(string),0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:updatePartner1_vows(string),1.0,5,5,1
"    function TokenTKC(
    ) public {
        balanceOf[msg.sender] = totalSupply;                
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
",0x3d6c445ad3d85270853845c4847174859c76035e/TokenTKC.sol:TokenTKC:TokenTKC(),"0x3d6c445ad3d85270853845c4847174859c76035e/TokenTKC.sol:TokenTKC:burnFrom(address,uint256)",0.5,4,4,0
"  function withdraw(){
    // If called before the ICO, cancel caller's participation in the sale.
    if (!bought_tokens) {
      // Store the user's balance prior to withdrawal in a temporary variable.
      uint256 eth_amount = balances[msg.sender];
      // Update the user's balance prior to sending ETH to prevent recursive call.
      balances[msg.sender] = 0;
      // Return the user's funds.  Throws on failure to prevent loss of funds.
      msg.sender.transfer(eth_amount);
    }
    // Withdraw the sender's tokens if the contract has already purchased them.
    else {
      // Store the user's ZBR balance in a temporary variable (1 ETHWei -> 2000 ZBRWei).
      uint256 ZBR_amount = balances[msg.sender] * ZBR_per_eth;
      // Update the user's balance prior to sending ZBR to prevent recursive call.
      balances[msg.sender] = 0;
      // No fee for withdrawing if the user would have made it into the crowdsale alone.
      uint256 fee = 0;
      // 1% fee if the user didn't check in during the crowdsale.
      if (!checked_in[msg.sender]) {
        fee = ZBR_amount / 100;
        // Send any non-zero fees to developer.
        if(!token.transfer(developer_address, fee)) throw;
      }
      // Send the user their tokens.  Throws if the crowdsale isn't over.
      if(!token.transfer(msg.sender, ZBR_amount - fee)) throw;
    }
  }
","    function min256(uint256 a, uint256 b) internal constant returns (uint256) {
      return a < b ? a : b;
    }
",0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:withdraw(),"0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:min256(uint256,uint256)",1.0,5,5,1
"    function sell(uint amount) public returns (uint revenue){
        require(balanceOf[msg.sender] >= amount);         // checks if the sender has enough to sell
        balanceOf[this] += amount;                        // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks
        emit Transfer(msg.sender, this, amount);               // executes an event reflecting on the change
        return revenue;                                   // ends function and returns
    }
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
",0x2f3ac824f6ccf3912f4dc1d29d954c83ff5eab8a/GoodfieldNewRetail.sol:GoodfieldNewRetail:sell(uint256),"0x2f3ac824f6ccf3912f4dc1d29d954c83ff5eab8a/GoodfieldNewRetail.sol:GoodfieldNewRetail:setPrices(uint256,uint256)",0.8333333333333334,4,4,0
"  constructor() public {owner = msg.sender; }
","  modifier onlyOwner() {require(msg.sender == owner); _; }
",0x4c9f09dee5a3cf650c50ad729c34e985785b932f/REALIDVerification.sol:Ownable:constructor(),0x4c9f09dee5a3cf650c50ad729c34e985785b932f/REALIDVerification.sol:Ownable:onlyOwner(),0.9397163120567376,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x7c24982c5166b5529d95af55a210ed04eed7d1db/HIBA.sol:StandardToken:transfer(address,uint256)","0x7c24982c5166b5529d95af55a210ed04eed7d1db/HIBA.sol:StandardToken:transferFrom(address,address,uint256)",0.986254295532646,5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x0C6967b8EA63093F632143E1C260Be756E08441F/Namek.sol:SafeMath:div(uint256,uint256)","0x0C6967b8EA63093F632143E1C260Be756E08441F/Namek.sol:SafeMath:sub(uint256,uint256)",0.9890410958904108,5,5,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
      if (balances[msg.sender] >= _value && _value > 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }
",0x4e0603e2a27a30480e5e3a4fe548e29ef12f64be/Credo.sol:StandardToken:balanceOf(address),"0x4e0603e2a27a30480e5e3a4fe548e29ef12f64be/Credo.sol:StandardToken:transfer(address,uint256)",0.28766430738119314,4,4,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x5c757f693aa2e4aff5664e23a6b0c06a0bb3727a/Wran.sol:Wran:transfer(address,uint256)",0x5c757f693aa2e4aff5664e23a6b0c06a0bb3727a/Wran.sol:Wran:burn(uint256),0.8060046189376443,4,4,0
"    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function transfer(address _to, uint256 _value) public returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x5cedfb528651d758819ce12061cb8f8ecae91fab/OwnedToken.sol:StandardToken:allowance(address,address)","0x5cedfb528651d758819ce12061cb8f8ecae91fab/OwnedToken.sol:StandardToken:transfer(address,uint256)",0.03316326530612245,2,2,0
"    function getPrice(string _datasource, uint _gaslimit)
    public
    returns (uint _dsprice) {
        return getPrice(_datasource, _gaslimit, msg.sender);
    }
","    function randomDS_getSessionPubKeyHash() constant returns (bytes32) {
        uint i = uint(sha3(reqc[msg.sender]))%randomDS_sessionPubKeysHash.length;
        return randomDS_sessionPubKeysHash[i];
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:getPrice(string,uint256)",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:randomDS_getSessionPubKeyHash(),1.0,5,5,1
"    modifier validDestination( address to )
    {
        require(to != address(0x0));
        require(to != address(this));
        _;
    }
","    function transfer(address _to, uint _value) validDestination(_to) public returns (bool) {
        return super.transfer(_to, _value);
    }
",0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:WobToken:validDestination(address),"0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:WobToken:transfer(address,uint256)",0.42857142857142855,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        
","    function YuanBaoCoin() {
        balanceOf[msg.sender] = 3050000000000000; // Give the creator all initial tokens
        totalSupply = 3050000000000000;                        // Update total supply
        name = ""ybcoin"";                                   // Set the name for display purposes
        symbol = ""YBCT"";                               // Set the symbol for display purposes
        decimals = 8;                            // Amount of decimals for display purposes
    }
","0x1d2c21400f7ced43369bd4a8373e561878bb8a2e/YuanBaoCoin.sol:YuanBaoCoin:approveAndCall(address,uint256,bytes)",0x1d2c21400f7ced43369bd4a8373e561878bb8a2e/YuanBaoCoin.sol:YuanBaoCoin:YuanBaoCoin(),0.015968063872255488,4,4,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
",0x5e046ccca2b0629f2eef9146cd091a5dcfed0a85/TRVLToken.sol:Ownable:onlyOwner(),0x5e046ccca2b0629f2eef9146cd091a5dcfed0a85/TRVLToken.sol:Ownable:_transferOwnership(address),0.04125177809388336,4,4,0
"    function balanceOf(address _owner) public constant returns (uint256 _balance) {
        return balanceOf[_owner];
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x3fe53debe8720a61a3e40f85da8611e810fe1fa0/MyTokenEVC.sol:MyTokenEVC:balanceOf(address),"0x3fe53debe8720a61a3e40f85da8611e810fe1fa0/MyTokenEVC.sol:MyTokenEVC:approveAndCall(address,uint256,bytes)",0.2790697674418605,4,4,0
"    function transferable() public view returns (bool) {
        return data.transferable;
    }
","    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        return data.signedApproveAndCall(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:transferable(),"0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:signedApproveAndCall(address,address,uint256,bytes,uint256,uint256,bytes,address)",1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x7d340bd7cbdb170c70654a6216530a4a9eccaa68/BasecoinToken.sol:StandardToken:allowance(address,address)",0x7d340bd7cbdb170c70654a6216530a4a9eccaa68/BasecoinToken.sol:StandardToken:balanceOf(address),0.4974489795918368,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x03b6609aaceccec42ef526a35b1bd5d728874ea4/PDATAToken.sol:PDATAToken:allowance(address,address)",0x03b6609aaceccec42ef526a35b1bd5d728874ea4/PDATAToken.sol:PDATAToken:balanceOf(address),0.9696048632218844,5,5,1
"    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) revert();
        // Prevent transfer to 0x0 address
        if (balanceOf[msg.sender] < _value) revert();
        // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();
        // Check for overflows
        balanceOf[msg.sender] -= _value;
        // Subtract from the sender
        balanceOf[_to] += _value;
        // Add the same to the recipient
        Transfer(msg.sender, _to, _value);
        // Notify anyone listening that this transfer took place
    }
","    function approve(address _spender, uint256 _value)
    returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x5d1f5Db1AE19575d261b40cd6a60f049FB4c3678/Sponsify.sol:Sponsify:transfer(address,uint256)","0x5d1f5Db1AE19575d261b40cd6a60f049FB4c3678/Sponsify.sol:Sponsify:approve(address,uint256)",0.6145833333333334,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[2],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getNetworkName(),0.8,2,2,0
"    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
","    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;

        bytes32 sigr;
        bytes32 sigs;

        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }


        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(keccak256(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(keccak256(pubkey)) == signer);
        }
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:ecrecovery(bytes32,bytes)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:verifySig(bytes32,bytes,bytes)",0.4444444444444444,2,2,0
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
","0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:SafeMath:sub(uint256,uint256)","0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:SafeMath:add(uint256,uint256)",0.9846765039727582,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function Enterprise() public {
        symbol = ""ENT"";
        name = ""Enterprise"";
        decimals = 18;
        _totalSupply = 2100000000000000000000000000;
        balances[0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c] = _totalSupply;
        Transfer(address(0), 0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c, _totalSupply);
    }
","0x1bcdd65cb986d67cfdd3250097951172bca054be/Enterprise.sol:Enterprise:transfer(address,uint256)",0x1bcdd65cb986d67cfdd3250097951172bca054be/Enterprise.sol:Enterprise:Enterprise(),0.4782608695652174,2,2,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x5d2bc5ea02ff6efb44a3b67a4c6b42fbc26d9965/Coin786token18.sol:Coin786token18:transferFrom(address,address,uint256)","0x5d2bc5ea02ff6efb44a3b67a4c6b42fbc26d9965/Coin786token18.sol:Coin786token18:transferAnyERC20Token(address,uint256)",0.9784482758620692,5,5,1
"    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x0f2f3d4937579a7feafa477a46666326910881b7/TheGreatWishOfChina.sol:TheGreatWishOfChina:approve(address,uint256)","0x0f2f3d4937579a7feafa477a46666326910881b7/TheGreatWishOfChina.sol:TheGreatWishOfChina:approveAndCall(address,uint256,bytes)",0.8964059196617337,2,2,0
"    function distributeAirdrop(address[] addresses, uint256 amount) public returns (bool) {
        require(amount > 0 
                && addresses.length > 0
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        amount = amount.mul(1e8);
        uint256 totalAmount = amount.mul(addresses.length);
        require(balanceOf[msg.sender] >= totalAmount);
        
        for (uint j = 0; j < addresses.length; j++) {
            require(addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amount);
            Transfer(msg.sender, addresses[j], amount);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","    function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length);

        uint256 totalAmount = 0;
        
        for (uint j = 0; j < addresses.length; j++) {
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            require(balanceOf[addresses[j]] >= amounts[j]);
            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);
            totalAmount = totalAmount.add(amounts[j]);
            Transfer(addresses[j], msg.sender, amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].add(totalAmount);
        return true;
    }
","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:distributeAirdrop(address[],uint256)","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:collectTokens(address[],uint256[])",0.8333333333333334,2,2,0
"	function	getData_3	()	public	constant	returns	(	string	)	{	
		return	inData_3	;							
	}										
","	function	getData_1	()	public	constant	returns	(	string	)	{	
		return	inData_1	;							
	}										
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_3(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_1(),0.8333333333333334,2,2,0
"    function SFCapitalToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }
","   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }
","0x8b6cda5cc518c904e8844f445e1a7c7d2db0ff16/SFCapitalToken.sol:SFCapitalToken:SFCapitalToken(string,string,uint8,uint256)","0x8b6cda5cc518c904e8844f445e1a7c7d2db0ff16/SFCapitalToken.sol:SFCapitalToken:increaseApproval(address,uint256)",0.6428571428571429,2,2,0
"    function withdrawEther(uint256 amount) {
        if(msg.sender != owner)throw;
        owner.transfer(amount);
    }
","    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
        if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
",0x0f2e95b771937743b41d698e4d140683172e7249/FDT.sol:FDT:withdrawEther(uint256),"0x0f2e95b771937743b41d698e4d140683172e7249/FDT.sol:FDT:transfer(address,uint256)",1.0,5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
",0x3e41e76d7b7cb54365317c7e7f1f411d59744922/FixedSupplyToken.sol:FixedSupplyToken:balanceOf(address),"0x3e41e76d7b7cb54365317c7e7f1f411d59744922/FixedSupplyToken.sol:FixedSupplyToken:transferAnyERC20Token(address,uint256)",0.91875,2,2,0
"    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x6f7ad850ef94320cb88f5ae66e5eb8244e81c949/x32323.sol:x32323:setPrices(uint256,uint256)","0x6f7ad850ef94320cb88f5ae66e5eb8244e81c949/x32323.sol:x32323:_transfer(address,address,uint256)",0.0425531914893617,2,2,0
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:StandardToken:approve(address,uint256)","0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:StandardToken:increaseApproval(address,uint256)",0.4008574490889603,2,2,0
"    function addLimitedWalletAddress(address _wallet) public {
        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);
        limitedWallets[_wallet] = true;
    }
","    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {
        return super.transfer(_to, _value);
    }
",0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6/ABYSS.sol:TransferLimitedToken:addLimitedWalletAddress(address),"0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6/ABYSS.sol:TransferLimitedToken:transfer(address,uint256)",1.0,5,5,1
"    function release() public returns(uint256 transferedAmount) {
        checkForReceivedTokens();
        require(msg.sender == beneficiary);//, ""Funds may be released only to beneficiary"");
        uint256 amountToTransfer = getReleasableFunds();
        require(amountToTransfer > 0);//, ""Out of funds"");
        // internal accounting
        alreadyReleasedAmount = alreadyReleasedAmount.add(amountToTransfer);
        internalBalance = internalBalance.sub(amountToTransfer);
        VestingMasterInterface(owner).substractLockedAmount(amountToTransfer);
        // actual transfer
        ERC20TokenInterface(tokenAddress).transfer(beneficiary, amountToTransfer);
        emit Released(amountToTransfer);
        return amountToTransfer;
    }
","    function checkForReceivedTokens() public{
        if (getTokenBalance() != internalBalance){
            uint256 receivedFunds = getTokenBalance().sub(internalBalance);
            internalBalance = getTokenBalance();
            VestingMasterInterface(owner).addLockedAmount(receivedFunds);
            emit TokensReceivedSinceLastCheck(receivedFunds);
        }
    }
",0x3c24f5560797280F12E190cac7e5711a73c91c63/VestingMasterContract.sol:TokenVestingContract:release(),0x3c24f5560797280F12E190cac7e5711a73c91c63/VestingMasterContract.sol:TokenVestingContract:checkForReceivedTokens(),1.0,5,5,1
"	function OwnableToken() public {
		owner = msg.sender;
	}
","	function setControler(address _controller) public onlyOwner {
		controller = _controller;
	}
",0x6d908a2ef63aeac21cb2b5c3d32a145f14144b38/VernamCrowdSaleToken.sol:OwnableToken:OwnableToken(),0x6d908a2ef63aeac21cb2b5c3d32a145f14144b38/VernamCrowdSaleToken.sol:OwnableToken:setControler(address),0.0,2,2,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
",0x3a6aee23b8f2fc528f29040f51e7737edf9fce27/GoodBoyPoints.sol:GoodBoyPoints:totalSupply(),"0x3a6aee23b8f2fc528f29040f51e7737edf9fce27/GoodBoyPoints.sol:GoodBoyPoints:transferFrom(address,address,uint256)",0.8175182481751825,2,2,0
"  modifier whenNotPaused() {
    require(!paused);
    _;
  }
","  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }
",0x7e7ac3b826c8a940728f324766089cadac54ed30/BLMToken.sol:Pausable:whenNotPaused(),0x7e7ac3b826c8a940728f324766089cadac54ed30/BLMToken.sol:Pausable:pause(),0.4432989690721649,2,2,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:approve(address,uint256)","0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:transferAnyERC20Token(address,uint256)",0.9238095238095241,2,2,0
"    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
","    function decimals() public view returns (uint8 _decimals) {	
		return decimals;
    }
",0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:isContract(address),0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:decimals(),0.5614035087719298,2,2,0
"    function Rate() constant returns (uint) {
        return rate;
    }
","   function Period() constant returns (uint) {
        return period;
    }
",0x1e591bcf0b95b56f38b1700fde40598c4826f63e/UkeyToken.sol:Crowdsale:Rate(),0x1e591bcf0b95b56f38b1700fde40598c4826f63e/UkeyToken.sol:Crowdsale:Period(),1.0,5,5,1
"  function safeMul(uint a, uint b) internal pure  returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function max64(uint64 a, uint64 b) internal pure returns (uint64) {
    return a >= b ? a : b;
  }
","0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:SafeMath:safeMul(uint256,uint256)","0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:SafeMath:max64(uint64,uint64)",0.22673031026252985,2,2,0
"    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x3da034753B42Bda1BcFA682f29685E2fd6729016/VoipToken.sol:VoipToken:adminClaimAirdrop(address,uint256)","0x3da034753B42Bda1BcFA682f29685E2fd6729016/VoipToken.sol:VoipToken:allowance(address,address)",1.0,5,5,1
"    modifier coupon(string code){
        oraclize = OraclizeI(OAR.getAddress());
        oraclize.useCoupon(code);
        _;
    }
","    function ba2cbor(bytes[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:coupon(string),0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:ba2cbor(bytes[]),0.6666666666666666,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool) {
        if (approve(_spender, _value)) {
            TokenRecipient spender = TokenRecipient(_spender);
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        return false;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value > 0);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
","0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)","0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:transferFrom(address,address,uint256)",0.02012072434607646,2,2,0
"    modifier checkAmount() {
        require(msg.value >= minAmount);
        _;
    }
","    function finishMinting() public onlyOwner saleFinished overSoftcap {
        require(status == 1 || (status != 2 && now < start + period * 1 days && balanceTotal < hardcap));
        uint issuedTokenSupply = token.totalSupply();
        uint restrictedTokens = issuedTokenSupply.mul(restricted).div(100 - restricted);
        mintAndTransfer(owner, restrictedTokens);
        token.finishMinting();
        owner.transfer(this.balance);
    }
",0x06df8621e05cfbfcde583fa15f103962d51b21ed/NooToken.sol:NooCrowdsale:checkAmount(),0x06df8621e05cfbfcde583fa15f103962d51b21ed/NooToken.sol:NooCrowdsale:finishMinting(),0.5,2,2,0
"  function sendTokensToOwner(uint _tokens) onlyOwner returns (bool ok){
      require(balances[contractAddress] >= _tokens);
      balances[contractAddress] = safeSub(balances[contractAddress],_tokens);
      balances[owner] = safeAdd(balances[owner],_tokens);
      return true;
  }
","  function dispenseTokensToInvestorAddressesByValue(address[] _addresses, uint[] _value) onlyOwner returns (bool ok){
     require(_addresses.length == _value.length);
     for(uint256 i=0; i<_addresses.length; i++){
        onSaleTokens = safeSub(onSaleTokens, _value[i]);
        balances[_addresses[i]] = safeAdd(balances[_addresses[i]], _value[i]);
        balances[contractAddress] = safeSub(balances[contractAddress], _value[i]);
     }
     return true;
  }
",0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:Coin:sendTokensToOwner(uint256),"0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:Coin:dispenseTokensToInvestorAddressesByValue(address[],uint256[])",1.0,5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    addToAddresses(_to);
    return true;
  }
","  function mint(address _to, uint256 _amount) onlyOwner public returns (bool){
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    addToAddresses(_to);
    Mint(_to, _amount);
    return true;
  }
","0x4BB301e545A3e948b20EA9A0F02D3948af6Fe6db/TarynToken.sol:TarynToken:transfer(address,uint256)","0x4BB301e545A3e948b20EA9A0F02D3948af6Fe6db/TarynToken.sol:TarynToken:mint(address,uint256)",0.0,2,2,0
"    function setCrowdsaleTotal(uint256 _crowdsaleTotal) onlyOwner public {
        crowdsaleTotal = _crowdsaleTotal;
    }
","    function lockInternalAccount(address _target, bool _lock, uint256 _releaseTime) onlyOwner public {
        require(_target != address(0));

        internalLockAccount[_target] = _lock;
        releaseLockAccount[_target] = _releaseTime;

    }
",0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:setCrowdsaleTotal(uint256),"0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:lockInternalAccount(address,bool,uint256)",1.0,5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
",0x01d614b9914342b7cbb798b1eb392460a05b3b4c/NCO.sol:NCO:totalSupply(),"0x01d614b9914342b7cbb798b1eb392460a05b3b4c/NCO.sol:NCO:transfer(address,uint256)",0.8540145985401459,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function increaseApproval (address _spender, uint _addedValue) 
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x7fddac3f0807b135488795b42cd2dcd3ef8c3a0b/LinkToken.sol:StandardToken:transferFrom(address,address,uint256)","0x7fddac3f0807b135488795b42cd2dcd3ef8c3a0b/LinkToken.sol:StandardToken:increaseApproval(address,uint256)",0.3075,2,2,0
"    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {
        oraclize_randomDS_args[queryId] = commitment;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[2],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_setCommitment(bytes32,bytes32)",0.8,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)
                && _value > 0
                && balanceOf[_from] >= _value
                && allowance[_from][msg.sender] >= _value
                && now > unlockUnixTime[_from]
                && now > unlockUnixTime[_to]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
","    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {
        require(_unitAmount > 0);

        totalSupply = totalSupply.add(_unitAmount);
        balanceOf[_to] = balanceOf[_to].add(_unitAmount);
        emit Mint(_to, _unitAmount);
        emit Transfer(address(0), _to, _unitAmount);
        return true;
    }
","0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:transferFrom(address,address,uint256)","0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:mint(address,uint256)",1.0,5,5,1
"    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function name() public view returns (string _name) {
        return name;
    }
","0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:transferToContract(address,uint256,bytes)",0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:name(),0.9523809523809524,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x0d9b54834162aeeb248983d772a647fb38ba9f2a/DONC.sol:DONC:transfer(address,uint256)","0x0d9b54834162aeeb248983d772a647fb38ba9f2a/DONC.sol:DONC:approve(address,uint256)",0.9960474308300395,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[2])",1.0,5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough
		require(_value > 0); 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","	function freeze(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough
		require(_value > 0); 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply
        Freeze(msg.sender, _value);
        return true;
    }
",0x3fc39066ba6e199514ce2ad6abf45b8ab4a83599/BEB.sol:BEB:burn(uint256),0x3fc39066ba6e199514ce2ad6abf45b8ab4a83599/BEB.sol:BEB:freeze(uint256),0.8095238095238095,2,2,0
"    function totalSupply() constant returns (uint256 supply){
        return supplies.total;
    }
","    function transfer(address _to, uint256 _amount) returns (bool success) {
        require(isSealed());

        // according to INC's total supply, never overflow here
        if (accounts[msg.sender].balance >= _amount
            && _amount > 0) {            
            accounts[msg.sender].balance -= uint112(_amount);
            accounts[_to].balance = _amount.add(accounts[_to].balance).toUINT112();
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
",0x4BFFC9B4d4DcF730820a2EdCAD48Ff5D7E0Ae807/INC.sol:INC:totalSupply(),"0x4BFFC9B4d4DcF730820a2EdCAD48Ff5D7E0Ae807/INC.sol:INC:transfer(address,uint256)",0.0,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x5abaff0b83f81dc061c590aadcba013c69237fd7/CryptoJade.sol:CryptoJade:allowance(address,address)","0x5abaff0b83f81dc061c590aadcba013c69237fd7/CryptoJade.sol:CryptoJade:transferFrom(address,address,uint256)",0.6990881458966566,2,2,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
       
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x0e4f0dab7dcfc2fd32b8f79f3e736d134bbf6c7e/InternationalTourismPublicChain.sol:StandardToken:transfer(address,uint256)","0x0e4f0dab7dcfc2fd32b8f79f3e736d134bbf6c7e/InternationalTourismPublicChain.sol:StandardToken:transferFrom(address,address,uint256)",0.986254295532646,4,4,1
"    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }
","    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
",0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:enableWhitelist(address[]),0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:burn(uint256),0.8695652173913043,2,2,0
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x1ab345a819eb8c2c4708a82e046a7a16ed534984/PureChainToken.sol:PureChainToken:transfer(address,uint256)","0x1ab345a819eb8c2c4708a82e046a7a16ed534984/PureChainToken.sol:PureChainToken:approve(address,uint256)",0.9960474308300395,4,4,1
"    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
        require(allowed[_from][msg.sender] > _amount);
        if (transferring(_from, _to, _amount)) {
            allowed[_from][msg.sender] -= _amount;
            return true;
        }
        return false;
    }
","    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }
","0x0ccD5eA595a3E7537e471F40a4d90F88eD0cf5ec/Altruism.sol:Altruism:transferFrom(address,address,uint256)",0x0ccD5eA595a3E7537e471F40a4d90F88eD0cf5ec/Altruism.sol:Altruism:balanceOf(address),1.0,4,4,1
"    function str_to_bytes32(string memory source) private pure returns(bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if(tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
","    function setSegmentOwner(string _picture, uint32 _row, uint32 _col, string _email, string _login) onlyManager public returns(bool success) {
        bytes32 key = str_to_bytes32(_picture);

        require(pictures[key].rows > 0);
        require(_row > 0 && _col > 0 && _row <= pictures[key].rows && _col <= pictures[key].cols);
        require(segments[key][_row][_col].row > 0);
        
        segments[key][_row][_col].email = _email;
        segments[key][_row][_col].login = _login;

        SegmentOwner(key, _row, _col, _email, _login);

        return true;
    }
",0x8b31b636cdc07f1266d8b937dd3952d7f4669018/MytilcoinStorage.sol:MytilcoinStorage:str_to_bytes32(string),"0x8b31b636cdc07f1266d8b937dd3952d7f4669018/MytilcoinStorage.sol:MytilcoinStorage:setSegmentOwner(string,uint32,uint32,string,string)",1.0,4,4,1
"  function balanceOf(address _owner) public constant returns (uint balance) {
    balance = balances[_owner];
  }
","  modifier ownerOnly {
    require(msg.sender == owner);
    _;
  }
",0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:balanceOf(address),0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:ownerOnly(),0.3333333333333333,4,4,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x1a5e8ace39857ff6882518cea475da59729ebb9b/ZEXCoin.sol:ZEXCoin:transferFrom(address,address,uint256)","0x1a5e8ace39857ff6882518cea475da59729ebb9b/ZEXCoin.sol:ZEXCoin:allowance(address,address)",0.9913793103448276,4,4,1
"		function	getCmd	()	public	constant	returns	(	uint256	)	{
			return	Cmd	;						
		}									
","		function	Eligibility_Group_3				(				
			address	_User_3		,					
			IERC20Token	_Securities_3		,					
			uint256	_Standard_3							
		)									
			public	onlyOwner							
		{									
			User_3		=	_User_3		;			
			Securities_3		=	_Securities_3		;			
			Standard_3		=	_Standard_3		;			
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:getCmd(),"0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:Eligibility_Group_3(address,IERC20Token,uint256)",1.0,4,4,1
"	function	getData_14	()	public	constant	returns	(	string	)	{
		return	inData_14	;						
	}									
","	function	getData_16	()	public	constant	returns	(	string	)	{
		return	inData_16	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_14(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_16(),1.0,4,4,1
"    function takeEther(uint amount) public onlyOwner {
        require(status == 1);
        owner.transfer(amount);
    }
","    modifier underHardcap() {
        require(balanceTotal <= hardcap);
        _;
    }
",0x06df8621e05cfbfcde583fa15f103962d51b21ed/NooToken.sol:NooCrowdsale:takeEther(uint256),0x06df8621e05cfbfcde583fa15f103962d51b21ed/NooToken.sol:NooCrowdsale:underHardcap(),1.0,4,4,1
"  function complete_sell_exchange(uint256 _amount_give) private {

    uint256 amount_get_ = get_amount_sell(_amount_give);


    // this is the amount that is transferred to the seller -minus the commision ANYWAY (even if admin_commission_activated is False) 
    uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_);
    
    transferTokensThroughProxyToContract(msg.sender,this,_amount_give);


    // the commission is transferred to admin only if admin_commission_activated, but the commission is subtracted anyway
    if(admin_commission_activated) {
      transferETHFromContract(msg.sender,amount_get_minus_commission_);

      uint256 admin_commission_ = amount_get_ - amount_get_minus_commission_;

      transferETHFromContract(admin, admin_commission_);     

    }
    else {
      transferETHFromContract(msg.sender,amount_get_);
    }
  }
","  function deposit_eth() private { 

    transferETHToContract();

  }  
",0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:complete_sell_exchange(uint256),0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:deposit_eth(),0.0,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x3ba5a8d30a598c58558f11d8347f76dd6f1d05f6/ipshoots.sol:ipshoots:transferFrom(address,address,uint256)","0x3ba5a8d30a598c58558f11d8347f76dd6f1d05f6/ipshoots.sol:ipshoots:approve(address,uint256)",0.8770301624129929,4,4,0
"    function __callback(bytes32 myid, string result) public {
        __callback(myid, result, new bytes(0));
    }
","    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:__callback(bytes32,string)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[3])",1.0,4,4,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x4b2bc34cbe34ea6c4efa802b968bb57bf6c0e810/WillyCoin.sol:WillyCoin:allowance(address,address)","0x4b2bc34cbe34ea6c4efa802b968bb57bf6c0e810/WillyCoin.sol:WillyCoin:transferAnyERC20Token(address,uint256)",0.9057750759878421,4,4,0
"  function CGCoinToken () {
    owner = msg.sender;
  }
","  function setOwner (address _newOwner) {
    require (msg.sender == owner);

    owner = _newOwner;
  }
",0x5c790caf8d45cf339362a78fc56ba9e3cf2aa6a0/CGCoinToken.sol:CGCoinToken:CGCoinToken(),0x5c790caf8d45cf339362a78fc56ba9e3cf2aa6a0/CGCoinToken.sol:CGCoinToken:setOwner(address),0.4,4,4,0
"  function implementsERC721() public view returns (bool _implements) {
    return erc721Enabled;
  }
","  function balanceOf (address _owner) public view returns (uint256 _balance) {
    uint256 counter = 0;
    for (uint8 i = 0; i < listedItems.length; i++) {
      if (ownerOf(listedItems[i]) == _owner) {
          counter++;
      }
    }
    return counter;
  }
",0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:implementsERC721(),0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:balanceOf(address),0.0,4,4,0
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x5c7bbbb83325785c88b44124eb137100aa91ab11/PMCoin.sol:StandardToken:increaseApproval(address,uint256)","0x5c7bbbb83325785c88b44124eb137100aa91ab11/PMCoin.sol:StandardToken:decreaseApproval(address,uint256)",1.0,4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x1d6d1947428310dd91bec6fcc0d9ea48430c33ed/PSYT.sol:PSYT:approveAndCall(address,uint256,bytes)","0x1d6d1947428310dd91bec6fcc0d9ea48430c33ed/PSYT.sol:PSYT:approve(address,uint256)",0.846307385229541,4,4,0
"    function allowance(address src, address guy) constant returns (uint256) {
        return _approvals[src][guy];
    }
","    function stop() auth  {
        stopped = true;
    }
","0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:allowance(address,address)",0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:stop(),0.25,4,4,0
"    function _sell(address _from,uint256 amount) internal returns (uint256 revenue){
        require(sellOpen);
        require(!frozenAccount[_from]);
        require(amount>0);
        require(sellPrice>0);
        require(_from!=owner);
        _transfer(_from,owner,amount);
        revenue = amount * sellPrice;
        _from.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks
        SellToken(_from,sellPrice,amount,revenue);
        return revenue;                                   // ends function and returns
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","0x0a9A9ce600D08BF9b76F49FA4e7b38A67EBEB1E6/GrowToken.sol:GrowToken:_sell(address,uint256)",0x0a9A9ce600D08BF9b76F49FA4e7b38A67EBEB1E6/GrowToken.sol:GrowToken:onlyOwner(),1.0,4,4,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x0ff7ae69784f1e25f10d7f086502a0b3ad803927/bitcoinforceToken.sol:bitcoinforceToken:burnFrom(address,uint256)","0x0ff7ae69784f1e25f10d7f086502a0b3ad803927/bitcoinforceToken.sol:bitcoinforceToken:approveAndCall(address,uint256,bytes)",0.8929503916449086,4,4,0
"  function transfer(address _to, uint256 _value) returns (bool success) {
    //Default assumes totalSupply can't be over max (2^256 - 1).
    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
    //Replace the if with this one instead.
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    //if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      emit Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }
","  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:StandardToken:transfer(address,uint256)","0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:StandardToken:approve(address,uint256)",0.8505747126436781,4,4,0
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  modifier onlyPayloadSize(uint256 numwords) {
    assert(msg.data.length >= numwords * 32 + 4);
    _;
  }
",0x8a4bc94944b2df58fc6d9cf108b8bd213df56972/XTRD.sol:BasicToken:balanceOf(address),0x8a4bc94944b2df58fc6d9cf108b8bd213df56972/XTRD.sol:BasicToken:onlyPayloadSize(uint256),0.0,4,4,0
"    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {
        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
        orders[msg.sender][hash] = true;
        emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);
    }
","    function setBlackListERC223(address _token) public onlyAdmin {
        whiteListERC223[_token] = false;
    }
","0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:order(address,uint256,address,uint256,uint256,uint256)",0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:setBlackListERC223(address),0.0,4,4,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x7ec00fbdc952ba6871c827956f75ca889a51d70f/TokenBCC.sol:TokenBCC:approve(address,uint256)","0x7ec00fbdc952ba6871c827956f75ca889a51d70f/TokenBCC.sol:TokenBCC:transferFrom(address,address,uint256)",0.7991543340380549,4,4,0
"    function equals(slice self, slice other) internal returns (bool) {
        return compare(self, other) == 0;
    }
","    function memcpy(uint dest, uint src, uint len) private {
        // Copy word-length chunks while possible
        for(; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(destpart, srcpart))
        }
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:equals(strings:slice,strings:slice)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:memcpy(uint256,uint256,uint256)",1.0,4,4,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
",0x4b222a1fe6acec5b8b6b34f02ee0d69be431a2d6/MANHATTANPROXYRIVDR.sol:StandardToken:balanceOf(address),"0x4b222a1fe6acec5b8b6b34f02ee0d69be431a2d6/MANHATTANPROXYRIVDR.sol:StandardToken:allowance(address,address)",0.5915065722952477,4,4,0
"    function kill() isCreator public {
        selfdestruct(owner);
    }
","    function setPrice(uint256 _price) isCreator public {
        price = _price;
    }
",0x2bd0a6cb33205225c653975d57ce1c937fa6310f/SGEPreICO.sol:SGEPreICO:kill(),0x2bd0a6cb33205225c653975d57ce1c937fa6310f/SGEPreICO.sol:SGEPreICO:setPrice(uint256),0.8,4,4,0
"  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);
  }
","  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }
","0x4fc6f746dd8d4bd24cb0b19b6a17c4845765d0c9/OODCrowdsale.sol:OODCrowdsale:_deliverTokens(address,uint256)",0x4fc6f746dd8d4bd24cb0b19b6a17c4845765d0c9/OODCrowdsale.sol:OODCrowdsale:_getTokenAmount(uint256),0.8387096774193549,4,4,0
"    function mint(address guy, uint wad) public auth stoppable {
        _balances[guy] = add(_balances[guy], wad);
        _supply = add(_supply, wad);
        Mint(guy, wad);
    }
","    function push(address dst, uint wad) public {
        transferFrom(msg.sender, dst, wad);
    }
","0x2acb4ebae0891efb5041822a5d79e49c4e6016fa/CDPerFactory.sol:DSToken:mint(address,uint256)","0x2acb4ebae0891efb5041822a5d79e49c4e6016fa/CDPerFactory.sol:DSToken:push(address,uint256)",1.0,4,4,1
"    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:distr(address,uint256)",0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:onlyOwner(),0.9166666666666666,4,4,0
"    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);
    }
","    function approveAndCall(address spender, uint tokens, bytes _data) public returns (bool success) {
        return data.approveAndCall(spender, tokens, _data);
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:signedApproveAndCallCheck(address,address,uint256,bytes,uint256,uint256,bytes,address)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:approveAndCall(address,uint256,bytes)",1.0,4,4,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x6f9b6b18388a5dd76ec0954af1616af1206db215/ZLHToken.sol:StandardToken:increaseApproval(address,uint256)","0x6f9b6b18388a5dd76ec0954af1616af1206db215/ZLHToken.sol:StandardToken:transferFrom(address,address,uint256)",0.1597051597051597,4,4,0
"    function pause() external onlyOwner whenNotPaused {
        paused = true;
    }
","    modifier whenNotPaused() {
        require(!paused);
        _;
    }
",0x2e7570255ac8c449217fb15405fac01f5408d114/Centurions.sol:CryptoRomeControl:pause(),0x2e7570255ac8c449217fb15405fac01f5408d114/Centurions.sol:CryptoRomeControl:whenNotPaused(),0.9772727272727272,4,4,1
"    function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {
        if(transferIns[_address].length <= 0) return 0;

        for (uint i = 0; i < transferIns[_address].length; i++){
            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;

            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));
            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;

            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));
        }
    }
","    modifier onlyPayloadSize(uint size) {
        require(msg.data.length >= size + 4);
        _;
    }
","0x7c9d1395d34bab13d734a78a2ed2476c3dfb038d/PassiveToken.sol:PassiveToken:getCoinAge(address,uint256)",0x7c9d1395d34bab13d734a78a2ed2476c3dfb038d/PassiveToken.sol:PassiveToken:onlyPayloadSize(uint256),0.9444444444444444,4,4,0
"    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
","    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getNetworkName(),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:__callback(bytes32,string)",1.0,4,4,1
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        if (amount > 0) {
            return token.transfer(owner, amount);
        }
        return true;
    }
","    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }
",0x6FF73eE2255c30e072d35598f9b06795122d4e64/DigitalEnthusiasts.sol:DigitalEnthusiasts:withdrawForeignTokens(address),0x6FF73eE2255c30e072d35598f9b06795122d4e64/DigitalEnthusiasts.sol:DigitalEnthusiasts:enableWhitelist(address[]),0.0,4,4,0
"	function offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)			// Sell an indexed piece owned by the registrar.
		{
			Interface c = Interface(_contract);
			c.offerIndexedPieceForSale(_index, _price);
		}
","    modifier onlyBy (address _account)
    {
        require(msg.sender == _account);
        _;
    }
","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:offerIndexedPieceForSaleByAddress(address,uint256,uint256)",0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:onlyBy(address),1.0,4,4,1
"    function setCouldTrade(uint256 amountInWeiDecimalIs18) onlyOwner returns (bool success) {
        couldTrade = true;
        require(balanceOf[msg.sender] >= amountInWeiDecimalIs18);
        require(balanceOf[this] + amountInWeiDecimalIs18 >= amountInWeiDecimalIs18);
        balanceOf[msg.sender] -= amountInWeiDecimalIs18;
        balanceOf[this] += amountInWeiDecimalIs18;
        Transfer(msg.sender, this, amountInWeiDecimalIs18);
        return true;
    }
","    function sell(uint256 amountInWeiDecimalIs18) returns (uint256 revenue) {
        require(couldTrade);
        uint256 amount = amountInWeiDecimalIs18;
        require(balanceOf[msg.sender] >= amount);
        require(!frozenAccount[msg.sender]);

        revenue = amount * sellPrice / RATE;
        balanceOf[this] += amount;
        balanceOf[msg.sender] -= amount;
        require(msg.sender.send(revenue));
        Transfer(msg.sender, this, amount);
        return revenue;
    }
",0x5e2B35C3a8f80676B5B789876634d49A1332F001/ContentAdNetworkToken.sol:ContentAdNetworkToken:setCouldTrade(uint256),0x5e2B35C3a8f80676B5B789876634d49A1332F001/ContentAdNetworkToken.sol:ContentAdNetworkToken:sell(uint256),1.0,4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] = safeAdd(balances[_to], _value);
            balances[_from] = safeSub(balances[_from], _value);
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
            Transfer(_from, _to, _value);
            return true;
        } else return false;
    }
","    function transfer(address _to, uint256 _value) public returns (bool) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] = safeSub(balances[msg.sender], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            Transfer(msg.sender, _to, _value);
            return true;
        } else return false;
    }
","0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:StandardToken:transferFrom(address,address,uint256)","0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:StandardToken:transfer(address,uint256)",0.7428571428571429,4,4,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x4aef06aa244438f28fd60c710a1cdf825374bcbd/QuickFlip.sol:SafeMath:sub(uint256,uint256)","0x4aef06aa244438f28fd60c710a1cdf825374bcbd/QuickFlip.sol:SafeMath:mul(uint256,uint256)",0.9659477866061292,4,4,1
"  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","  function div(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","0x4BF8AA9D458C14dF5fb407a2aa2E9ECCcDc9fa79/CHEXToken.sol:SafeMath:max256(uint256,uint256)","0x4BF8AA9D458C14dF5fb407a2aa2E9ECCcDc9fa79/CHEXToken.sol:SafeMath:div(uint256,uint256)",0.19428571428571428,4,4,0
"    function receiveETH(address beneficiary) internal {
        if (msg.value < MIN_INVEST_ETHER) throw; // Don't accept funding under a predefined threshold
        
        uint coinToSend = bonus(msg.value.mul(COIN_PER_ETHER).div(1 ether)); // Compute the number of SkinCoin to send
        if (coinToSend.add(coinSentToEther) > MAX_CAP) throw;    
        Backer backer = backers[beneficiary];
        coin.transfer(beneficiary, coinToSend); // Transfer SkinCoins right now 
        backer.coinSent = backer.coinSent.add(coinToSend);
        backer.weiReceived = backer.weiReceived.add(msg.value); // Update the total wei collected during the crowdfunding for this backer    
        etherReceived = etherReceived.add(msg.value); // Update the total wei collected during the crowdfunding
        coinSentToEther = coinSentToEther.add(coinToSend);
        // Send events
        LogCoinsEmited(msg.sender ,coinToSend);
        LogReceivedETH(beneficiary, etherReceived); 
    }
","    function finalize() onlyOwner public {
        if (now < endTime) { // Cannot finalise before CROWDSALE_PERIOD or before selling all coins
            if (coinSentToEther == MAX_CAP) {
            } else {
                throw;
            }
        }
        if (coinSentToEther < MIN_CAP && now < endTime + 15 days) throw; // If MIN_CAP is not reached donors have 15days to get refund before we can finalise
        if (!multisigEther.send(this.balance)) throw; // Move the remaining Ether to the multisig address
        
        uint remains = coin.balanceOf(this);
        if (remains > 0) { // Burn the rest of SkinCoins
            if (!coin.burn(remains)) throw ;
        }
        crowdsaleClosed = true;
    }
",0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:receiveETH(address),0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:finalize(),1.0,4,4,1
"    function receiveETH(address beneficiary) internal {
        if (msg.value < MIN_INVEST_ETHER) throw; // Don't accept funding under a predefined threshold
        
        uint coinToSend = bonus(msg.value.mul(COIN_PER_ETHER).div(1 ether)); // Compute the number of SkinCoin to send
        if (coinToSend.add(coinSentToEther) > MAX_CAP) throw;    
        Backer backer = backers[beneficiary];
        coin.transfer(beneficiary, coinToSend); // Transfer SkinCoins right now 
        backer.coinSent = backer.coinSent.add(coinToSend);
        backer.weiReceived = backer.weiReceived.add(msg.value); // Update the total wei collected during the crowdfunding for this backer    
        etherReceived = etherReceived.add(msg.value); // Update the total wei collected during the crowdfunding
        coinSentToEther = coinSentToEther.add(coinToSend);
        // Send events
        LogCoinsEmited(msg.sender ,coinToSend);
        LogReceivedETH(beneficiary, etherReceived); 
    }
","    function finalize() onlyOwner public {
        if (now < endTime) { // Cannot finalise before CROWDSALE_PERIOD or before selling all coins
            if (coinSentToEther == MAX_CAP) {
            } else {
                throw;
            }
        }
        if (coinSentToEther < MIN_CAP && now < endTime + 15 days) throw; // If MIN_CAP is not reached donors have 15days to get refund before we can finalise
        if (!multisigEther.send(this.balance)) throw; // Move the remaining Ether to the multisig address
        
        uint remains = coin.balanceOf(this);
        if (remains > 0) { // Burn the rest of SkinCoins
            if (!coin.burn(remains)) throw ;
        }
        crowdsaleClosed = true;
    }
",0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:receiveETH(address),0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:finalize(),1.0,4,4,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x1a63138ba26440baeb7adfa96bad94ee483005bb/LATokenMinter.sol:SafeMath:div(uint256,uint256)","0x1a63138ba26440baeb7adfa96bad94ee483005bb/LATokenMinter.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x2cb4bbe398d4d6312533ffbfd0aebcb34c1febb6/Kildoneum.sol:StandardToken:transfer(address,uint256)","0x2cb4bbe398d4d6312533ffbfd0aebcb34c1febb6/Kildoneum.sol:StandardToken:allowance(address,address)",0.9776632302405498,4,4,1
"    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[5])",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),0.8,4,4,0
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
","0x2c0c06dae6bc7d7d7d8b0d67a1f1a47d6165e373/CryptonitexCoin.sol:CryptonitexCoin:freezeAccount(address,bool)",0x2c0c06dae6bc7d7d7d8b0d67a1f1a47d6165e373/CryptonitexCoin.sol:CryptonitexCoin:sell(uint256),0.270935960591133,4,4,0
"    function lockAddress(address target, bool status)
    external
    isOwner
    {
        require(owner != target);
        lockaddress[target] = status;
        emit Locked(target, status);
    }
","    modifier isTokenTransfer {
        // if token transfer is not allow
        if(!tokenTransfer) {
            require(unlockaddress[msg.sender]);
        }
        _;
    }
","0x0c178237d47172440c5792526c4952a279fdadf1/TPCToken.sol:Lockable:lockAddress(address,bool)",0x0c178237d47172440c5792526c4952a279fdadf1/TPCToken.sol:Lockable:isTokenTransfer(),1.0,4,4,1
"  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }
","  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","0x6d5d2755d75d816085a70d0ec5ec7c57eea2015f/SISApreSale.sol:Math:sub(uint256,uint256)","0x6d5d2755d75d816085a70d0ec5ec7c57eea2015f/SISApreSale.sol:Math:add(uint256,uint256)",0.8285714285714286,4,4,0
"	function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
		require(allowed[_from][msg.sender] >= _value && balances[msg.sender] >= _value	&& _value > 0);
		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		Transfer(_from, _to, _value);
		return true;
	}
","	function enableBonus() {
		require(msg.sender == owner); 
		bonusAllowed = true;
	}
","0x5ca5c12893A50Cf2561C218f9d44825c0083DaB6/ETHACE.sol:ETHACE:transferFrom(address,address,uint256)",0x5ca5c12893A50Cf2561C218f9d44825c0083DaB6/ETHACE.sol:ETHACE:enableBonus(),0.0,4,4,0
"    modifier is_cli() {
        require(clients[msg.sender] == true);
        _;
    }
","    modifier is_cr_mng() {
        require(cr_manager[msg.sender] == true);
        _;
    }
",0x1ffdbcecea31ea4f8a659f6ba0dc314983db872d/ClientsHandler.sol:ManageableContract:is_cli(),0x1ffdbcecea31ea4f8a659f6ba0dc314983db872d/ClientsHandler.sol:ManageableContract:is_cr_mng(),1.0,4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x1bce560a1e0c67dbd8d00e389a4e3ee3c46997be/OmiseGOClassic.sol:OmiseGOClassic:transferFrom(address,address,uint256)",0x1bce560a1e0c67dbd8d00e389a4e3ee3c46997be/OmiseGOClassic.sol:OmiseGOClassic:burn(uint256),0.8723897911832946,4,4,0
"    function strCompare(string _a, string _b) internal pure returns (int) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        uint minLength = a.length;
        if (b.length < minLength) minLength = b.length;
        for (uint i = 0; i < minLength; i ++)
            if (a[i] < b[i])
                return -1;
            else if (a[i] > b[i])
                return 1;
        if (a.length < b.length)
            return -1;
        else if (a.length > b.length)
            return 1;
        else
            return 0;
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:strCompare(string,string)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",0.8,4,4,0
"    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        if (balances[_from] >= _value
            && allowed[_from][msg.sender] >= _value
            && _value > 0
            && _from != _to
          ) {
            balances[_to]   = balances[_to].add(_value);
            balances[_from] = balances[_from].sub(_value);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
            Transfer(_from, _to, _value);
            return true;
        }

        return false;
    }
","    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        // useless operation
        require(_spender != address(0));

        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }

        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","0x04f2e7221fdb1b52a68169b25793e51478ff0329/Cappasity.sol:StandardToken:transferFrom(address,address,uint256)","0x04f2e7221fdb1b52a68169b25793e51478ff0329/Cappasity.sol:StandardToken:decreaseApproval(address,uint256)",0.22429906542056074,4,4,0
"  function name() constant returns (string _name) {
      return name;
  }
","  function symbol() constant returns (string _symbol) {
      return symbol;
  }
",0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:name(),0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:symbol(),1.0,4,4,1
"    function decimals() public view returns (uint8 _decimals) {
        return decimals;
    }
","    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:DIETSweets:decimals(),"0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:DIETSweets:transferToContract(address,uint256,bytes)",0.4444444444444444,4,4,0
"    function removeLock(address _addr) public onlyOwner returns (bool success){
        locked[_addr] = false;
        return true;
    }
","    function enableTransfer(bool _enable) public onlyOwner{
        transferEnabled = _enable;
    }
",0x0a25c807291e58716ab78752f8bb15eae8370e7d/ENBToken.sol:Controlled:removeLock(address),0x0a25c807291e58716ab78752f8bb15eae8370e7d/ENBToken.sol:Controlled:enableTransfer(bool),1.0,4,4,1
"    function setContracts() public onlyController {}
","    modifier onlyController() {
        require(msg.sender == controller);
        _;
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:FlightDelayControlledContract:setContracts(),0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:FlightDelayControlledContract:onlyController(),1.0,4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function _transfer(address _from, address _to, uint _value) internal {
	    require(!frozenAccount[_from]);
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        initialize(_from);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
	
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
        
        initialize(_to);
    }
","0x6c6ff5213433510c91c65787dcf604bb2dc37c19/x32323.sol:x32323:approveAndCall(address,uint256,bytes)","0x6c6ff5213433510c91c65787dcf604bb2dc37c19/x32323.sol:x32323:_transfer(address,address,uint256)",0.6926147704590818,4,4,0
"    function publicGetRound() view public returns (uint) {
        return round;
    }
","    modifier whenOwner() {
        require(msg.sender == owner);
        _;
    }
",0x7bb936f496884c52d21df7b9b93bed14d7c24a3c/EthMashChain.sol:EthMashChain:publicGetRound(),0x7bb936f496884c52d21df7b9b93bed14d7c24a3c/EthMashChain.sol:EthMashChain:whenOwner(),1.0,5,4,1
"    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
    }
     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        require(_totalSupply > 100000000000000000000000000);
        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);          
        _totalSupply = SafeMath.sub(_totalSupply, _value);                  
        emit Burn(msg.sender, _value);
        return true;
    }
","0x8b4dc26ef1416d65442eb6948b90720424f3bdfd/StakeToken.sol:StakeToken:decreaseApproval(address,uint256)",0x8b4dc26ef1416d65442eb6948b90720424f3bdfd/StakeToken.sol:StakeToken:burn(uint256),0.0,4,4,0
"    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x7e9e431a0b8c4d532c745b1043c7fa29a48d4fba/eosDACToken.sol:Owned:acceptOwnership(),0x7e9e431a0b8c4d532c745b1043c7fa29a48d4fba/eosDACToken.sol:Owned:transferOwnership(address),0.935103244837758,4,4,0
"	function	setPOOL_edit_7	(	string	newPOOL_edit_7	)	public	onlyOwner	{	
		inPOOL_edit_7	=	newPOOL_edit_7	;					
	}									
","	function	getPOOL_edit_3	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_3	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_7(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_3(),0.6666666666666666,4,4,0
"    function balanceOf(address _address) constant returns (uint256) {
        return getBalance(_address);
    }
","    function balance() constant returns (uint256) {
        return getBalance(msg.sender);
    }
",0x0a283ed40e2f050b53094d08bde36f67db50bcfa/FreeCoin.sol:FreeCoin:balanceOf(address),0x0a283ed40e2f050b53094d08bde36f67db50bcfa/FreeCoin.sol:FreeCoin:balance(),0.75,4,4,0
"    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[4],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",1.0,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);  
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;         
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true; }
","0x6fa8b7532cae4e8feedadfb4a757a43ae5243165/BING.sol:BING:_transfer(address,address,uint256)","0x6fa8b7532cae4e8feedadfb4a757a43ae5243165/BING.sol:BING:burnFrom(address,uint256)",0.8523316062176166,4,4,0
"    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){
        bool match_ = true;
	
	if (prefix.length != n_random_bytes) throw;
	        
        for (uint256 i=0; i< n_random_bytes; i++) {
            if (content[i] != prefix[i]) match_ = false;
        }

        return match_;
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getPrice(string),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:matchBytes32Prefix(bytes32,bytes,uint256)",0.25,4,4,0
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowance[_owner][_spender];
    }
","    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","0x4aff7f37696ce3bb0dbe10dd63bae8dc9f634623/Alpon.sol:Alpon:allowance(address,address)","0x4aff7f37696ce3bb0dbe10dd63bae8dc9f634623/Alpon.sol:Alpon:transfer(address,uint256,bytes,string)",0.007899934167215274,4,4,0
"    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);
        } else {
            return super.approve(_spender, _value);
        }
    }
","    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[_from]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    }
","0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Clost:approve(address,uint256)","0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Clost:transferFrom(address,address,uint256)",1.0,5,5,1
"    function Ownable() public {
        owner = msg.sender;
    }
","    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
",0x7a66391d2b0a9d087a77fb4acd3e19c59a76e940/TOC.sol:Ownable:Ownable(),0x7a66391d2b0a9d087a77fb4acd3e19c59a76e940/TOC.sol:Ownable:onlyOwner(),0.0609284332688588,4,4,0
"    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:indexOf(string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[3],uint256)",0.8,4,4,0
"	function	setPOOL_edit_18	(	string	newPOOL_edit_18	)	public	onlyOwner	{	
		inPOOL_edit_18	=	newPOOL_edit_18	;					
	}									
","	function	setPOOL_edit_1	(	string	newPOOL_edit_1	)	public	onlyOwner	{	
		inPOOL_edit_1	=	newPOOL_edit_1	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_18(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_1(string),1.0,5,5,1
"  modifier stopNonOwnersInEmergency {
    if (halted && msg.sender != owner) throw;
    _;
  }
","  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }
",0x7f9fa692e1b65d2b6d670feebd3e6bcc29606f14/PaymentForwarder.sol:Haltable:stopNonOwnersInEmergency(),0x7f9fa692e1b65d2b6d670feebd3e6bcc29606f14/PaymentForwarder.sol:Haltable:unhalt(),1.0,5,5,1
"    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = x / y;
    }
","    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + RAY / 2) / RAY);
    }
","0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58/ProspectorsCrowdsale.sol:DSMath:hdiv(uint128,uint128)","0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58/ProspectorsCrowdsale.sol:DSMath:rmul(uint128,uint128)",1.0,5,5,1
"  function balanceOf(address _owner) public constant returns (uint balance) {
    balance = balances[_owner];
  }
","  function setRestrictedAcct(address _restrictedAcct, uint _restrictUntil) public ownerOnly unlockedOnly {
    restrictedAcct = _restrictedAcct;
    restrictUntil = _restrictUntil;
  }
",0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:balanceOf(address),"0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:setRestrictedAcct(address,uint256)",0.3333333333333333,4,4,0
"  function balanceOf(address tokenOwner) public view returns (uint balance) {
    return balances[tokenOwner];
  }
","  function approve(address spender, uint tokens) public returns (bool success) {
    allowed[msg.sender][spender] = tokens;
    emit Approval(msg.sender, spender, tokens);
    return true;
  }
",0x1ba0ab6ef2d6fbd773fec0dd7f4633ae360db65e/ChoweToken.sol:ChoweToken:balanceOf(address),"0x1ba0ab6ef2d6fbd773fec0dd7f4633ae360db65e/ChoweToken.sol:ChoweToken:approve(address,uint256)",0.953125,5,5,1
"	function approve(address spender, uint256 value)								
		public							
		returns (bool success)							
	{								
		allowance[msg.sender][spender] = value;							
		emit Approval(msg.sender, spender, value);							
		return true;							
	}								
","	function transfer(address to, uint256 value) public returns (bool success) {								
		require(balanceOf[msg.sender] >= value);							
									
		balanceOf[msg.sender] -= value;  // deduct from sender's balance							
		balanceOf[to] += value;          // add to recipient's balance							
		emit Transfer(msg.sender, to, value);							
		return true;							
	}								
","0x3b9411b2ac139d9fc737c170a49239e381d87b43/DAX_1000_20180920.sol:DAX_1000_20180920:approve(address,uint256)","0x3b9411b2ac139d9fc737c170a49239e381d87b43/DAX_1000_20180920.sol:DAX_1000_20180920:transfer(address,uint256)",0.025296017222820242,4,4,0
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x5b9e703662e8c4a97d85941c2402653c8285b796/BEXMToken.sol:BEXMToken:burnFrom(address,uint256)","0x5b9e703662e8c4a97d85941c2402653c8285b796/BEXMToken.sol:BEXMToken:transferFrom(address,address,uint256)",0.9608355091383812,5,5,1
"    function approve(address guy, uint wad) public returns (bool) {
        _approvals[msg.sender][guy] = wad;

        emit Approval(msg.sender, guy, wad);

        return true;
    }
","    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }
","0x2c9e0924b023cc9a42bc1e6f20deb7e3ec727d54/DSToken.sol:DSTokenBase:approve(address,uint256)","0x2c9e0924b023cc9a42bc1e6f20deb7e3ec727d54/DSToken.sol:DSTokenBase:transfer(address,uint256)",0.6428571428571429,4,4,0
"	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}
","	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}
",0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:decrementOwnedTokensLength(address),0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:getTokenApproval(uint256),1.0,5,5,1
"    function stra2cbor(string[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:stra2cbor(string[]),0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getNetworkName(),0.75,4,4,0
"    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x0dd9cd40679988a880ecbd9de32f6c49e9333fb3/SBSToken.sol:SafeMath:safeSub(uint256,uint256)","0x0dd9cd40679988a880ecbd9de32f6c49e9333fb3/SBSToken.sol:SafeMath:safeMul(uint256,uint256)",0.983402489626556,5,4,1
"    function enableTokenTransfer()
    external
    onlyFromWallet
    {
        tokenTransfer = true;
        TokenTransfer();
    }
","    function transfer( address to, uint value)
    public
    isTokenTransfer
    checkLock
    returns (bool success) {

        require( _balances[msg.sender] >= value );

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);
        Transfer( msg.sender, to, value );
        return true;
    }
",0x6f7a4bac3315b5082f793161a22e26666d22717f/YeedToken.sol:YeedToken:enableTokenTransfer(),"0x6f7a4bac3315b5082f793161a22e26666d22717f/YeedToken.sol:YeedToken:transfer(address,uint256)",0.0,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:TokenERC20:transferFrom(address,address,uint256)","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:TokenERC20:burnFrom(address,uint256)",0.8538283062645011,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[3])",1.0,4,4,1
"  function burn(address _from, uint256 _unitAmount) onlyOwner public {
    require(_unitAmount > 0
            && balanceOf(_from) >= _unitAmount);

    balances[_from] = SafeMath.sub(balances[_from], _unitAmount);
    totalSupply = SafeMath.sub(totalSupply, _unitAmount);
    Burn(_from, _unitAmount);
  }
","  function Kemonocoin() public {
    totalSupply = initialSupply;
    balances[msg.sender] = totalSupply;
  }
","0x7f32d1959b5361e884df8c9d017a03f4ce29c8b2/Kemonocoin.sol:Kemonocoin:burn(address,uint256)",0x7f32d1959b5361e884df8c9d017a03f4ce29c8b2/Kemonocoin.sol:Kemonocoin:Kemonocoin(),1.0,4,4,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x0f01c825df1985cd2babbc29cdb0000927778b57/TreasureCoin.sol:TreasureCoin:transfer(address,uint256)",0x0f01c825df1985cd2babbc29cdb0000927778b57/TreasureCoin.sol:TreasureCoin:totalSupply(),0.924901185770751,4,4,0
"    function getRemainCoins() onlyOwner public {
        var remains = MAX_CAP - coinSentToEther;
        uint minCoinsToSell = bonus(MIN_INVEST_ETHER.mul(COIN_PER_ETHER) / (1 ether));
        if(remains > minCoinsToSell) throw;
        Backer backer = backers[owner];
        coin.transfer(owner, remains); // Transfer SkinCoins right now 
        backer.coinSent = backer.coinSent.add(remains);
        coinSentToEther = coinSentToEther.add(remains);
        // Send events
        LogCoinsEmited(this ,remains);
        LogReceivedETH(owner, etherReceived); 
    }
","    function setMultisig(address addr) onlyOwner public {
        if (addr == address(0)) throw;
        multisigEther = addr;
    }
",0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:getRemainCoins(),0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Crowdsale:setMultisig(address),1.0,4,4,1
"  function Ownable() {
    owner = msg.sender;
  }
","  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }
",0x8a1cec92faafa44eecc3633b939a98f4ae4b87ee/OGX.sol:Ownable:Ownable(),0x8a1cec92faafa44eecc3633b939a98f4ae4b87ee/OGX.sol:Ownable:onlyOwner(),0.0609284332688588,4,4,0
"  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x1bee5b6954bcf5a9b795b1068584ae332aa7a747/Minutes.sol:BasicToken:balanceOf(address),"0x1bee5b6954bcf5a9b795b1068584ae332aa7a747/Minutes.sol:BasicToken:transfer(address,uint256)",0.07987866531850353,4,4,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
",0x3d8945dcfc11627a6a762f203be3b1b14db36c4c/WHAToken.sol:TokenERC20:burn(uint256),"0x3d8945dcfc11627a6a762f203be3b1b14db36c4c/WHAToken.sol:TokenERC20:transfer(address,uint256)",0.8192488262910798,4,4,0
"  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      emit Freeze ();
    }
  }
","  function setOwner(address _newOwner) {
    require (msg.sender == owner);

    owner = _newOwner;
  }
",0x1b35806945ac1f02fe4fe68eba0d55b8104aa603/FBToken.sol:FBToken:freezeTransfers(),0x1b35806945ac1f02fe4fe68eba0d55b8104aa603/FBToken.sol:FBToken:setOwner(address),0.9615384615384616,4,4,1
"    function calculateIdeaBuySimple(uint256 eth) public view returns(uint256){
        return calculateIdeaBuy(eth,address(this).balance);
    }
","    function getMyIdeas() public view returns(uint256){
        address _caller = msg.sender;
        return claimedIdeas[_caller].add(getIdeasSinceLastDeploy(_caller));
    }
",0x02e582682aa7b4dcc3f7574c468ef61b29545404/CloneWars.sol:CloneWars:calculateIdeaBuySimple(uint256),0x02e582682aa7b4dcc3f7574c468ef61b29545404/CloneWars.sol:CloneWars:getMyIdeas(),0.25,4,4,0
"	modifier whenNotPaused() {
		require(!paused);
		_;
	}
","	function pause() onlyOwner whenNotPaused public returns (bool) {
		paused = true;
		emit Pause();
		return true;
	}
",0x0a255f700b16c0acf5673565c757b94fb38b27f2/NeoWorldCash.sol:Pausable:whenNotPaused(),0x0a255f700b16c0acf5673565c757b94fb38b27f2/NeoWorldCash.sol:Pausable:pause(),0.09965635738831616,4,4,0
"  function createTokenContract() internal returns (PrymexToken) {
    return new PrymexToken();
  }
","  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }
",0x0Dae0a0d130F053fE4bbbec4927539E5f06d2684/PrymexPreICOCrowdsale.sol:PrymexPreICOCrowdsale:createTokenContract(),0x0Dae0a0d130F053fE4bbbec4927539E5f06d2684/PrymexPreICOCrowdsale.sol:PrymexPreICOCrowdsale:hasEnded(),0.13333333333333333,4,4,0
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setProof(bytes1),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)",1.0,4,4,1
"    constructor() public {
        symbol = ""TIP"";
        name = ""Tip"";
        decimals = 18;
        _totalSupply = 1000000000 * 10 ** uint256(decimals);
        _airdropAmount = 8000 * 10 ** uint256(decimals);
        _airdropSupply =  300000000 * 10 ** uint256(decimals);
        _totalRemaining = _airdropSupply;
        balances[owner] = _totalSupply.sub(_airdropSupply);

        emit Transfer(address(0), owner, _totalSupply);
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x2d5abaf588db3e1bfafa9f8cd253b0d9b67c6572/TIP.sol:TIP:constructor(),"0x2d5abaf588db3e1bfafa9f8cd253b0d9b67c6572/TIP.sol:TIP:approveAndCall(address,uint256,bytes)",1.0,4,4,1
"    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }
","0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:transfer(address,uint256,bytes,string)",0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:balanceOf(address),0.7058823529411765,4,4,0
"    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:parseAddr(string),0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:getCodeSize(address),1.0,4,4,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x6be5744e45292144d6814ffbedcb6aad1bb287e4/CikkaCoin.sol:CikkaCoin:burn(uint256),"0x6be5744e45292144d6814ffbedcb6aad1bb287e4/CikkaCoin.sol:CikkaCoin:approveAndCall(address,uint256,bytes)",0.8849765258215962,4,4,0
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }
","    function symbol() public view returns (string _symbol) {
        return symbol;
    }
",0x3ce6c3ad8da82bfc8754fbe8c164061bfa89558d/GRAVURECOIN.sol:GRAVURECOIN:balanceOf(address),0x3ce6c3ad8da82bfc8754fbe8c164061bfa89558d/GRAVURECOIN.sol:GRAVURECOIN:symbol(),0.3953488372093023,4,4,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x04c39e68215a42d697d72ffcd8345a0155003b25/LicenseCoin.sol:StandardToken:allowance(address,address)","0x04c39e68215a42d697d72ffcd8345a0155003b25/LicenseCoin.sol:StandardToken:approve(address,uint256)",0.7185374149659864,4,4,0
" function balanceOf(address _owner) constant returns (uint256 balance) {
     return balances[_owner];
 }
"," function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
     var _allowance = allowed[_from][msg.sender];
    
     balances[_to] = safeAdd(balances[_to], _value);
     balances[_from] = safeSub(balances[_from], _value);
     allowed[_from][msg.sender] = safeSub(_allowance, _value);
     Transfer(_from, _to, _value);
     return true;
 }
",0x1cad49736eec8ca89b386b29c36255ffbe5fcd92/MOVIECREDITS3.sol:MOVIECREDITS3:balanceOf(address),"0x1cad49736eec8ca89b386b29c36255ffbe5fcd92/MOVIECREDITS3.sol:MOVIECREDITS3:transferFrom(address,address,uint256)",0.0262891809908999,2,2,0
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function onePercent(uint256 a) internal constant returns (uint256){
      return div(a,uint256(100));
  }
","0x6f38169cc63e97f5c258965c67ac11f052f288f2/FinalTestToken2.sol:SafeMath:add(uint256,uint256)",0x6f38169cc63e97f5c258965c67ac11f052f288f2/FinalTestToken2.sol:SafeMath:onePercent(uint256),0.0005617977528089888,1,1,0
"    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[1])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[])",1.0,4,4,1
"    function ownerOf(uint256 _tokenId) external view returns (address _owner) {
        _owner = idToOwner[_tokenId];
        require(_owner != address(0));
    }
","    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) internal canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from);
        require(_to != address(0));

        _transfer(_to, _tokenId);

        if (_to.isContract()) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(retval == MAGIC_ON_ERC721_RECEIVED);
        }
    }
",0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:ownerOf(uint256),"0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:_safeTransferFrom(address,address,uint256,bytes)",0.3333333333333333,1,1,0
"    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[5],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[])",1.0,4,4,1
"    modifier transfersEnabled() {
        require(transfersEnabledFlag);
        _;
    }
","    function transfer(address _to, uint256 _value) transfersEnabled() public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x1dc2ee8964dedd6d08ae26ae685eb19e54cd646c/TigerCashToken.sol:BasicToken:transfersEnabled(),"0x1dc2ee8964dedd6d08ae26ae685eb19e54cd646c/TigerCashToken.sol:BasicToken:transfer(address,uint256)",1.0,4,4,1
"    function transferFrom(address src, address dst, uint wad)
        public
        stoppable
        returns (bool)
    {
        require(_balances[src] - _frozens[src] >= wad);
        
        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {
            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);
        }

        _balances[src] = sub(_balances[src], wad);
        _balances[dst] = add(_balances[dst], wad);

        emit Transfer(src, dst, wad);

        return true;
    }
","    function approve(address guy, uint wad) public stoppable returns (bool) {
        return super.approve(guy, wad);
    }
","0x7fd23f0f50560a5bd469f791fee7410732b8ba70/DSToken.sol:DSToken:transferFrom(address,address,uint256)","0x7fd23f0f50560a5bd469f791fee7410732b8ba70/DSToken.sol:DSToken:approve(address,uint256)",0.3333333333333333,1,1,0
"    function unlock() onlyOwner public {
        require(locked);
        locked = false;
        Unlock();
    }
","    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {
        return sell(_to, _value * 1e18);
    }
",0x3eed0f69a22a50deb0e125b1a526ba657bbb1473/ProdToken.sol:CommonToken:unlock(),"0x3eed0f69a22a50deb0e125b1a526ba657bbb1473/ProdToken.sol:CommonToken:sellNoDecimals(address,uint256)",1.0,4,4,1
"    function getOwners()
    public
    constant
    returns (address[])
    {
        return owners;
    }
","    modifier confirmed(uint transactionId, address owner) {
        require(confirmations[transactionId][owner]);
        _;
    }
",0x4a32b05f949d54146ee5db1a0d1f554f9f67d9c0/PresaleFinalizeAgent.sol:RNTMultiSigWallet:getOwners(),"0x4a32b05f949d54146ee5db1a0d1f554f9f67d9c0/PresaleFinalizeAgent.sol:RNTMultiSigWallet:confirmed(uint256,address)",0.14285714285714285,1,1,0
"    function name() public view returns (string _name) {
        return name;
    }
","    function autoDistribute() payable public {
        require(distributeAmount > 0
                && balanceOf[owner] >= distributeAmount
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
        if(msg.value > 0) owner.transfer(msg.value);
        
        balanceOf[owner] = balanceOf[owner].sub(distributeAmount);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(distributeAmount);
        Transfer(owner, msg.sender, distributeAmount);
    }
",0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:name(),0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:autoDistribute(),0.2,1,1,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x8c32f8d0edb496326de8d3adf46f622a744b86fe/CAStoreContract.sol:SafeMath:add(uint256,uint256)","0x8c32f8d0edb496326de8d3adf46f622a744b86fe/CAStoreContract.sol:SafeMath:mul(uint256,uint256)",0.9758426966292136,4,4,1
"    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
","    function allowance(address _owner, address _spender) external view returns (uint) {
        return allowed[_owner][_spender];
    }
",0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:transferOwnership(address),"0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:allowance(address,address)",0.0012531328320802006,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5d3cf0e2611d95c8c3e30e1c7406765174243256/MidasDiscountToken.sol:StandardToken:transferFrom(address,address,uint256)","0x5d3cf0e2611d95c8c3e30e1c7406765174243256/MidasDiscountToken.sol:StandardToken:approve(address,uint256)",0.9715504978662872,4,4,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x4ccc99bc93c5c5b4d7f574d6d59ee3783831988a/bitbgcToken.sol:bitbgcToken:balanceOf(address),"0x4ccc99bc93c5c5b4d7f574d6d59ee3783831988a/bitbgcToken.sol:bitbgcToken:approveAndCall(address,uint256,bytes)",0.921875,1,1,0
"  function transfer(address _to, uint256 _value) public returns (bool success)
  {
      require(_to != address(0));
      require(balanceOf[msg.sender] >= _value);
      require(balanceOf[_to] + _value >= balanceOf[_to]);


      balanceOf[msg.sender] -= _value;
      balanceOf[_to] += _value;

      emit Transfer(msg.sender,_to,_value);
      
      success = true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool success)
  {
     allowed[msg.sender][_spender] = _value;

     emit Approval(msg.sender,_spender,_value);


     success = true;
  }
","0x7efb64549cb306839feab1ce3a3e55f7eb655cd0/BF.sol:BF:transfer(address,uint256)","0x7efb64549cb306839feab1ce3a3e55f7eb655cd0/BF.sol:BF:approve(address,uint256)",0.047619047619047616,1,1,0
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
","0x02b0cfdc2ce5775feb68be62a7df3bba56598817/EthereumAI.sol:SafeMath:div(uint256,uint256)","0x02b0cfdc2ce5775feb68be62a7df3bba56598817/EthereumAI.sol:SafeMath:min256(uint256,uint256)",0.02589489718202589,1,1,0
"    function decreaseApproval(address _spender, uint _subtractedValue)
        whenLive
        public
        returns (bool)
    {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
","    function approve(address _spender, uint256 _value) 
        whenLive 
        public 
        returns (bool)
    {
        return super.approve(_spender, _value);
    }
","0x1a37ab7420c3b9beacdd8329656061c685ffea15/MBAS.sol:MBAS:decreaseApproval(address,uint256)","0x1a37ab7420c3b9beacdd8329656061c685ffea15/MBAS.sol:MBAS:approve(address,uint256)",0.8333333333333334,1,1,0
"    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)",1.0,4,4,1
"  function increaseApproval (address _spender, uint _addedValue) 
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x0b5f57467db959b959410f83e3810fcfaa592f5b/BRLTOKEN.sol:StandardToken:increaseApproval(address,uint256)","0x0b5f57467db959b959410f83e3810fcfaa592f5b/BRLTOKEN.sol:StandardToken:transferFrom(address,address,uint256)",0.1597051597051597,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[5])",1.0,4,4,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
     require(_value <= balances[_from]);
     require(_value <= allowed[_from][msg.sender]);

    balances[_from] = SafeMath.sub(balances[_from], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
    Transfer(_from, _to, _value);
     return true;
   }
","   function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }
","0x2f2540218770da363dd3320b107f38fbeaf62472/EIB.sol:EIB:transferFrom(address,address,uint256)","0x2f2540218770da363dd3320b107f38fbeaf62472/EIB.sol:EIB:transfer(address,uint256)",0.7741935483870968,1,1,0
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value);
        return true;
    }
","0x7c65b7638f8550943b8dbf56461600451bcbecd5/EtherZaarFactory.sol:ERC20:allowance(address,address)","0x7c65b7638f8550943b8dbf56461600451bcbecd5/EtherZaarFactory.sol:ERC20:transferFrom(address,address,uint256)",0.29336734693877553,1,1,0
"	function	setPI_edit_30	(	string	newPI_edit_30	)	public	onlyOwner	{	
		inPI_edit_30	=	newPI_edit_30	;					
	}									
","	function	getPI_edit_7	()	public	constant	returns	(	string	)	{
		return	inPI_edit_7	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_30(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_7(),1.0,4,4,1
"    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[3])",1.0,4,4,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x0b24fdf35876bbe2a1cc925321b8c301017474d4/JustWallet.sol:JustWallet:_transfer(address,address,uint256)","0x0b24fdf35876bbe2a1cc925321b8c301017474d4/JustWallet.sol:JustWallet:approveAndCall(address,uint256,bytes)",0.8782383419689119,1,1,0
"    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:burn(uint256),0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:transferOwnership(address),0.9821428571428572,4,4,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        
        require(_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));
        return true;
    }
",0x2c3801C08894684e9a911cDD0e1aE966713E668E/BCBtuCoin.sol:BCBtuCoin:onlyOwner(),"0x2c3801C08894684e9a911cDD0e1aE966713E668E/BCBtuCoin.sol:BCBtuCoin:approveAndCall(address,uint256,bytes)",0.002844950213371266,1,1,0
"    function PushToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }
","    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
",0x5Ff0e9dAd9D452851167a45818C412d955d7A661/PushToken.sol:PushToken:PushToken(),0x5Ff0e9dAd9D452851167a45818C412d955d7A661/PushToken.sol:PushToken:onlyOwner(),0.4,1,1,0
"    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[1],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_useCoupon(string),0.6,1,1,0
"    function allowance(address _owner, address _spender) constant returns (uint) {
        return controller.allowance(_owner, _spender);
    }
","    function totalSupply() constant returns (uint) {
        return controller.totalSupply();
    }
","0x4e2504551edc1fefd574e0c946c1d9c8db250afd/Bittle.sol:Bittle:allowance(address,address)",0x4e2504551edc1fefd574e0c946c1d9c8db250afd/Bittle.sol:Bittle:totalSupply(),0.5,1,1,0
"    function setMyTokenList(address[] _tokenList)  
        public
        delegated
    {

    }
","    function getTransactionIds(uint from, uint to, bool pending, bool executed)
        public
        constant
        returns (uint[] _transactionIds)
    {
        uint[] memory transactionIdsTemp = new uint[](transactionCount);
        uint count = 0;
        uint i;
        for (i = 0; i < transactionCount; i++) {
            if (pending && !transactions[i].executed || executed && transactions[i].executed) {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        }
        _transactionIds = new uint[](to - from);
        for (i = from; i < to; i++) {
            _transactionIds[i - from] = transactionIdsTemp[i];
        }
    }
",0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:setMyTokenList(address[]),"0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:getTransactionIds(uint256,uint256,bool,bool)",1.0,4,4,1
"    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {
        // This famous algorithm is called ""exponentiation by squaring""
        // and calculates x^n with x as fixed-point and n as regular unsigned.
        //
        // It's O(log n), instead of O(n) for naive repeated multiplication.
        //
        // These facts are why it works:
        //
        //  If n is even, then x^n = (x^2)^(n/2).
        //  If n is odd,  then x^n = x * x^(n-1),
        //   and applying the equation for even x gives
        //    x^n = x * (x^2)^((n-1) / 2).
        //
        //  Also, EVM division is flooring and
        //    floor[(n-1) / 2] = floor[n / 2].

        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }
","    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:rpow(uint128,uint64)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:hsub(uint128,uint128)",0.25,1,1,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x7d865aa5e813f4bbc7e3a8d1dc65aa446be914cd/Puttu.sol:StandardToken:balanceOf(address),"0x7d865aa5e813f4bbc7e3a8d1dc65aa446be914cd/Puttu.sol:StandardToken:transfer(address,uint256)",0.28766430738119314,1,1,0
"    function queryN(string _datasource, bytes _args)
    payable
    returns (bytes32 _id) {
        return queryN(0, _datasource, _args, 200000);
    }
","    function addDSource(string dsname, byte proofType, uint multiplier) onlyadmin {
        bytes32 dsname_hash = sha3(dsname, proofType);
        dsources[dsources.length++] = dsname_hash;
        price_multiplier[dsname_hash] = multiplier;
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN(string,bytes)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:addDSource(string,bytes1,uint256)",1.0,4,4,1
"    function calculateEggBuy(uint256 eth,uint256 contractBalance) public view returns(uint256){
        return calculateTrade(eth,contractBalance,marketEggs);
    }
","    function buyEggs() public payable{
        require(initialized);
        uint256 eggsBought=calculateEggBuy(msg.value,SafeMath.sub(this.balance,msg.value));
        eggsBought=SafeMath.sub(eggsBought,devFee(eggsBought));
        ceoAddress.transfer(devFee(msg.value));
        claimedEggs[msg.sender]=SafeMath.add(claimedEggs[msg.sender],eggsBought);
    }
","0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:calculateEggBuy(uint256,uint256)",0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:buyEggs(),0.6111111111111112,1,1,0
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 10000000000;  
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = ""FEMCoin"";                                   // Set the name for display purposes
        symbol = ""FEMC"";                               // Set the symbol for display purposes
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x1efa4d569ed37107ffbb94c15d25a32b594bc553/FEMCoin.sol:FEMCoin:TokenERC20(uint256,string,string)","0x1efa4d569ed37107ffbb94c15d25a32b594bc553/FEMCoin.sol:FEMCoin:approve(address,uint256)",0.9090909090909092,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {

        return balances[tokenOwner];

    }
","0x2F141Ce366a2462f02cEA3D12CF93E4DCa49e4Fd/FreeToken.sol:FreeToken:approve(address,uint256)",0x2F141Ce366a2462f02cEA3D12CF93E4DCa49e4Fd/FreeToken.sol:FreeToken:balanceOf(address),0.9682539682539684,5,4,1
"	function	getPI_edit_31	()	public	constant	returns	(	string	)	{
		return	inPI_edit_31	;						
	}									
","	function	setPI_edit_28	(	string	newPI_edit_28	)	public	onlyOwner	{	
		inPI_edit_28	=	newPI_edit_28	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_31(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_28(string),1.0,5,5,1
"    function currentBetLimit() 
    public 
    view 
    returns (uint256)
    {
        return betLimit;
    }
","    modifier onlyRealPeople()
    {
          require (msg.sender == tx.origin);
        _;
    }
",0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:currentBetLimit(),0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:onlyRealPeople(),1.0,5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
",0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:balanceOf(address),0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:totalSupply(),0.853125,1,1,0
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    oldOwner = owner;
    owner = newOwner;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x0d62442a4b931ac1243997d96bfe37fef4fb03e7/HeartBoutPreICO.sol:Ownable:transferOwnership(address),0x0d62442a4b931ac1243997d96bfe37fef4fb03e7/HeartBoutPreICO.sol:Ownable:Ownable(),0.0,1,1,0
"	function	setData_1	(	string	newData_1	)	public	onlyOwner	{		
		inData_1	=	newData_1	;						
	}										
","		function	LLV_v31_5		()	public	{				
			owner	= msg.sender;							
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setData_1(string),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:LLV_v31_5(),0.0,1,1,0
"    function EthVerifyCore() public{
        ceoAddress=msg.sender;
        admins[ceoAddress]=true;
    }
","  modifier onlyAdmin() {
    require(admins[msg.sender]);
    _;
  }
",0x1c307a39511c16f74783fcd0091a921ec29a0b51/EthVerifyCore.sol:EthVerifyCore:EthVerifyCore(),0x1c307a39511c16f74783fcd0091a921ec29a0b51/EthVerifyCore.sol:EthVerifyCore:onlyAdmin(),1.0,5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x7ba8a5d59b21390a70b2ba968a183712e12a049c/VerityToken.sol:SafeMath:div(uint256,uint256)","0x7ba8a5d59b21390a70b2ba968a183712e12a049c/VerityToken.sol:SafeMath:sub(uint256,uint256)",0.9890410958904108,5,5,1
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","	function mintToken(address target, uint256 mintedAmount) onlyOwner {
		balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
","0x7e5ba6b8937db2e6ad5381d6128773a231676009/Bgamecoin.sol:Bgamecoin:transfer(address,uint256)","0x7e5ba6b8937db2e6ad5381d6128773a231676009/Bgamecoin.sol:Bgamecoin:mintToken(address,uint256)",0.03695150115473441,1,1,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
",0x2dc2e581f1dca93b618937aa313c8920153af960/KyberNetworkTokenSale.sol:Ownable:onlyOwner(),0x2dc2e581f1dca93b618937aa313c8920153af960/KyberNetworkTokenSale.sol:Ownable:transferOwnership(address),0.15979137031768612,1,1,0
"  function transferFrom(address _from, address _to, uint _value) returns (bool success) {

    uint _allowance = allowed[_from][msg.sender];

    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met
    balances[_to] = safeAdd(balances[_to],_value);
    balances[_from] = safeSub(balances[_from],_value);
    allowed[_from][msg.sender] = safeSub(_allowance,_value);
    Transfer(_from, _to, _value);
    return true;

  }
","  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:StandardToken:transferFrom(address,address,uint256)","0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:StandardToken:allowance(address,address)",0.981132075471698,5,5,1
"	function	setPOOL_edit_8	(	string	newPOOL_edit_8	)	public	onlyOwner	{	
		inPOOL_edit_8	=	newPOOL_edit_8	;					
	}									
","	function	POOL_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_8(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:POOL_EDIT_1(),0.5,1,1,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    modifier canPoSMint() {
        require(totalSupply < maxTotalSupply);
        _;
    }
",0x1b3bde49d13aec2d3629be78c341f61fd21a7cc4/Meristem.sol:Meristem:balanceOf(address),0x1b3bde49d13aec2d3629be78c341f61fd21a7cc4/Meristem.sol:Meristem:canPoSMint(),0.00910010111223458,1,1,0
"    function setCanAcceptTokens(address _address, bool _value) external onlyOwner {
        canAcceptTokens[_address] = _value;
    }
","    function burn(uint256 _amount) external {
        require(balances[msg.sender] >= _amount);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        totalSupply_ = totalSupply_.sub(_amount);

        emit Burn(msg.sender, _amount);
    }
","0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:ETToken:setCanAcceptTokens(address,bool)",0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:ETToken:burn(uint256),1.0,5,5,1
"    modifier canPoSMint() {
        require(totalSupply < maxTotalSupply);
        _;
    }
","    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
        //eGoldchain - Modified to mine
        if(msg.sender == _to) return mine();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
        uint64 _now = uint64(now);
        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));
        transferIns[_to].push(transferInStruct(uint128(_value),_now));
        return true;
    }
",0x07a64cf812844b2a3af03006ba9356c64da96ce2/eGoldchain.sol:eGoldchain:canPoSMint(),"0x07a64cf812844b2a3af03006ba9356c64da96ce2/eGoldchain.sol:eGoldchain:transfer(address,uint256)",0.9473684210526316,1,1,0
"    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                // Check if the sender has enough
        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        totalSupply -= _value;                               // Updates totalSupply
        Burn(_from, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x5be4294c774fd58b65e5753a1de2465f836d5acf/GOLDEQ.sol:GOLDEQ:burnFrom(address,uint256)","0x5be4294c774fd58b65e5753a1de2465f836d5acf/GOLDEQ.sol:GOLDEQ:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {
        Record storage record = records[node];
        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {
            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {
                data = record.abis[contentType];
                return;
            }
        }
        contentType = 0;
    }
","    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {
        return interfaceID == ADDR_INTERFACE_ID ||
        interfaceID == CONTENT_INTERFACE_ID ||
        interfaceID == NAME_INTERFACE_ID ||
        interfaceID == ABI_INTERFACE_ID ||
        interfaceID == PUBKEY_INTERFACE_ID ||
        interfaceID == TEXT_INTERFACE_ID ||
        interfaceID == MULTIHASH_INTERFACE_ID ||
        interfaceID == INTERFACE_META_ID;
    }
","0x0a2340e7af5dcf6f7f4acc0e01f2102fb4b144b7/PublicResolver.sol:PublicResolver:ABI(bytes32,uint256)",0x0a2340e7af5dcf6f7f4acc0e01f2102fb4b144b7/PublicResolver.sol:PublicResolver:supportsInterface(bytes4),0.3333333333333333,1,1,0
"    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;
        
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);
        
        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);
        
        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = 1; //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);
        
        if (sigok == false) return false;
        
        
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";
        
        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);
        
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);
        
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);
        
        return sigok;
    }
","    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getPrice(string,uint256)",1.0,5,5,1
"  function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
","  function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
",0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:ERC721Token:takeOwnership(uint256),"0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:ERC721Token:_mint(address,uint256)",1.0,5,5,1
"	function	setPI_edit_21	(	string	newPI_edit_21	)	public	onlyOwner	{	
		inPI_edit_21	=	newPI_edit_21	;					
	}									
","	function	setPI_edit_11	(	string	newPI_edit_11	)	public	onlyOwner	{	
		inPI_edit_11	=	newPI_edit_11	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_21(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_11(string),1.0,5,4,1
"    function sub(uint a, uint b) internal pure returns (uint) {
        assert(b <= a);
        return a - b;
    }
","    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
","0x1cca91a47db357445b89269f2fb4f647cd209968/Distribution.sol:SafeMath:sub(uint256,uint256)","0x1cca91a47db357445b89269f2fb4f647cd209968/Distribution.sol:SafeMath:add(uint256,uint256)",0.01904761904761905,1,1,0
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","0x5b68a0d3e80020a54e85cdd457bc4ad8c49d8056/OctaBlock.sol:OctaBlock:transferFrom(address,address,uint256)",0x5b68a0d3e80020a54e85cdd457bc4ad8c49d8056/OctaBlock.sol:OctaBlock:withdrawForeignTokens(address),0.7671232876712328,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[5],uint256)",1.0,5,4,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x2d295c19f405048c576b4c1179ea2458e8e13935/x32323.sol:x32323:_transfer(address,address,uint256)",0x2d295c19f405048c576b4c1179ea2458e8e13935/x32323.sol:x32323:burn(uint256),0.8808290155440415,1,1,0
"    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
        if ((_proof[0] != ""L"")||(_proof[1] != ""P"")||(_proof[2] != 1)) return 1;

        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
        if (proofVerified == false) return 2;

        return 0;
    }
","    modifier oraclizeAPI {
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);
        oraclize = OraclizeI(OAR.getAddress());
        _;
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclizeAPI(),0.0,1,1,0
"    function balanceOf(address _owner)
        public
        view 
        returns (uint256 balance)
    {
        if(JUSTed){
            if(bonus[msg.sender] > 0){
                return stdBalance + bonus[msg.sender];
            } else {
                return stdBalance;
            }
        } else {
            return 0;
        }
    }
","    function UNJUST(string _name, string _symbol, uint256 _stdBalance, uint256 _totalSupply, bool _JUSTed)
        public
    {
        require(owner == msg.sender);
        name = _name;
        symbol = _symbol;
        stdBalance = _stdBalance;
        totalSupply = _totalSupply;
        JUSTed = _JUSTed;
    }
",0x7cee63b86801b16eef574badd779c589caaa476d/JUST.sol:JUST:balanceOf(address),"0x7cee63b86801b16eef574badd779c589caaa476d/JUST.sol:JUST:UNJUST(string,string,uint256,uint256,bool)",1.0,5,4,1
"    function _burn(address _owner, uint256 _tokenId) internal {
        clearApproval(_owner, _tokenId);
        removeTokenFrom(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }
","    function approve(address _to, uint256 _tokenId) public {
        address owner = ownerOf(_tokenId);
        require(_to != owner);
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));

        if (getApproved(_tokenId) != address(0) || _to != address(0)) {
            tokenApprovals[_tokenId] = _to;
            emit Approval(owner, _to, _tokenId);
        }
    }
","0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:_burn(address,uint256)","0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:approve(address,uint256)",0.6666666666666666,1,1,0
"    function balanceOf(address tokenOwner) public view returns (uint balance) {

        return balances[tokenOwner];

    }
","    function transfer(address to, uint tokens) public returns (bool success) {

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        emit Transfer(msg.sender, to, tokens);

        return true;

    }
",0x1e378cdf48cd6faa3fc8e0bc0dbe02446969e46d/GEONToken.sol:GEONToken:balanceOf(address),"0x1e378cdf48cd6faa3fc8e0bc0dbe02446969e46d/GEONToken.sol:GEONToken:transfer(address,uint256)",0.896875,1,1,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
",0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:onlyOwner(),0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:balanceOf(address),0.03651019440493125,1,1,0
"    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
        // We do our own memory management here. Solidity uses memory offset
        // 0x40 to store the current end of memory. We write past it (as
        // writes are memory extensions), but don't update the offset so
        // Solidity will reuse it. The memory used here is only needed for
        // this context.

        // FIXME: inline assembly can't access return values
        bool ret;
        address addr;

        assembly {
            let size := mload(0x40)
            mstore(size, hash)
            mstore(add(size, 32), v)
            mstore(add(size, 64), r)
            mstore(add(size, 96), s)

            // NOTE: we can reuse the request memory because we deal with
            //       the return code
            ret := call(3000, 1, 0, size, 128, size, 32)
            addr := mload(size)
        }

        return (ret, addr);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:safer_ecrecover(bytes32,uint8,bytes32,bytes32)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[4])",1.0,4,4,1
"    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {
        return oraclize.setConfig(config);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[2])",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setConfig(bytes32),0.6,1,1,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x0b4298856285e36adf7682fbd06c8ffa3eeae72b/CTCToken.sol:StandardToken:decreaseApproval(address,uint256)","0x0b4298856285e36adf7682fbd06c8ffa3eeae72b/CTCToken.sol:StandardToken:allowance(address,address)",0.9477434679334916,1,1,0
"    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
",0x6b6ba7a1bbcbb5d0af5ecaf0a77eabdec899bcd4/EarnEnoughMoney.sol:EarnEnoughMoney:canDistr(),0x6b6ba7a1bbcbb5d0af5ecaf0a77eabdec899bcd4/EarnEnoughMoney.sol:EarnEnoughMoney:withdrawForeignTokens(address),0.8059701492537313,1,1,0
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4/FansChainToken.sol:FansChainToken:freezeAccount(address,bool)","0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4/FansChainToken.sol:FansChainToken:setPrices(uint256,uint256)",0.42857142857142855,1,1,0
"	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}
","	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:setImageBlurredAt(uint256,uint256)","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:setImageWidth(uint256,uint16)",1.0,4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function ClarkeCoin(
        ) {
        balances[msg.sender] = 600000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 600000000;                        // Update total supply (100000 for example)
        name = ""Clarke Coin"";                                   // Set the name for display purposes
        decimals = 2;                            // Amount of decimals for display purposes
        symbol = ""CLRK"";                               // Set the symbol for display purposes
    }
","0x3d4d901902ce946fb2b4f889989bef96dec0ed71/ClarkeCoin.sol:ClarkeCoin:approveAndCall(address,uint256,bytes)",0x3d4d901902ce946fb2b4f889989bef96dec0ed71/ClarkeCoin.sol:ClarkeCoin:ClarkeCoin(),0.08896210873146622,1,1,0
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x5e1c9b8262994575ea6473a90478055ea9d9791c/GoWalletProject.sol:SafeMath:div(uint256,uint256)","0x5e1c9b8262994575ea6473a90478055ea9d9791c/GoWalletProject.sol:SafeMath:sub(uint256,uint256)",0.9890410958904108,4,4,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x7ddb9cd43313a9af3494a7030aba5293f94cfecd/ttToken.sol:ttToken:transferFrom(address,address,uint256)",0x7ddb9cd43313a9af3494a7030aba5293f94cfecd/ttToken.sol:ttToken:totalSupply(),0.9655172413793104,4,4,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:SafeMath:mul(uint256,uint256)","0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:SafeMath:div(uint256,uint256)",0.3127715030408341,1,1,0
"    function BCBtuCoin () public {
        owner = msg.sender;
		balances[msg.sender] = totalSupply;
    }
","    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
    }
",0x2c3801C08894684e9a911cDD0e1aE966713E668E/BCBtuCoin.sol:BCBtuCoin:BCBtuCoin(),0x2c3801C08894684e9a911cDD0e1aE966713E668E/BCBtuCoin.sol:BCBtuCoin:burn(uint256),0.26666666666666666,1,1,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function CRDTToken() public {
        symbol = ""CRDT"";
        name = ""EverID CRDT Token"";
        decimals = 2;
        _totalSupply = 2000000000000000000;
        balances[0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593] = _totalSupply;
        Transfer(address(0), 0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593, _totalSupply);
    }
","0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:CRDTToken:allowance(address,address)",0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:CRDTToken:CRDTToken(),0.182370820668693,1,1,0
"	function	getPOOL_edit_31	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_31	;						
	}									
","	function	setPOOL_edit_20	(	string	newPOOL_edit_20	)	public	onlyOwner	{	
		inPOOL_edit_20	=	newPOOL_edit_20	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_31(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_20(string),1.0,4,4,1
"  modifier onlyOwnerOrManager(){
    require(msg.sender == manager || msg.sender == owner);
    _;
  }
","  function forwardFunds(uint256 value) internal {
    wallet.transfer(value);
  }
",0x4dfc56b2613729878aa0a49c928fb41af62ccbef/PreICO.sol:PreICO:onlyOwnerOrManager(),0x4dfc56b2613729878aa0a49c928fb41af62ccbef/PreICO.sol:PreICO:forwardFunds(uint256),0.043478260869565216,1,1,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","0x7b879c09973dcd83a12c58cdeb2103f620b4cd22/Kidcrypto.sol:Kidcrypto:transferFrom(address,address,uint256)","0x7b879c09973dcd83a12c58cdeb2103f620b4cd22/Kidcrypto.sol:Kidcrypto:transfer(address,uint256)",0.9870689655172412,4,4,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x3aa1f5b9ca11e3651a12be4a287de50c6fc48548/WsloanCoin.sol:WsloanCoin:approve(address,uint256)","0x3aa1f5b9ca11e3651a12be4a287de50c6fc48548/WsloanCoin.sol:WsloanCoin:transfer(address,uint256)",0.7991543340380549,1,1,0
"    modifier canTransfer(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == msg.sender || getApproved(_tokenId) == msg.sender || ownerToOperators[tokenOwner][msg.sender]);
        _;
    }
","    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
",0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:NFToken:canTransfer(uint256),0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:NFToken:getApproved(uint256),1.0,4,4,1
"	function	setPI_edit_23	(	string	newPI_edit_23	)	public	onlyOwner	{	
		inPI_edit_23	=	newPI_edit_23	;					
	}									
","	function	setPI_edit_27	(	string	newPI_edit_27	)	public	onlyOwner	{	
		inPI_edit_27	=	newPI_edit_27	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_23(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_27(string),1.0,4,4,1
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint decimalUnits
    ) public {
        owner = msg.sender;
        name = tokenName;
        symbol = tokenSymbol; 
        decimals = decimalUnits;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }
",0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8/DragonLifeChain.sol:DragonLifeChain:onlyOwner(),"0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8/DragonLifeChain.sol:DragonLifeChain:constructor(uint256,string,string,uint256)",0.005215742057847321,1,1,0
"	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}
","	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:getLastRegionId(),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:getRegionUrl(uint256),0.6,1,1,0
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
",0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:withdrawForeignTokens(address),0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:updateTokensPerEth(uint256),0.3606557377049181,1,1,0
"    function balanceOf(address _owner) constant returns(uint256 balance) {
        return balances[_owner];
    }
","    function Champion() {
        totalSupply = 25000000;
        symbol = 'CNP';
        owner = 0x1eca6ef43a7561b5ccffaa81a26d28cf6f3b8f6c;
        balances[owner] = totalSupply;
        decimals = 0;
    }
",0x4cb7a7a0fe462d302f553a1d8077d2943f061fcc/Champion.sol:Champion:balanceOf(address),0x4cb7a7a0fe462d302f553a1d8077d2943f061fcc/Champion.sol:Champion:Champion(),0.01769464105156724,1,1,0
"    function currentBetLimit() 
    public 
    view 
    returns (uint256)
    {
        return betLimit;
    }
","    constructor(address whaleAddress, uint256 wagerLimit) 
    onlyRealPeople()
    public 
    {
        openToPublic = false;
        owner = msg.sender;
        whale = whaleAddress;
        totalDonated = 0;
        betLimit = wagerLimit;
        
    }
",0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:currentBetLimit(),"0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:constructor(address,uint256)",1.0,4,4,1
"    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a < b ? a : b;
    }
","    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
","0x01b840bc3f9243733d5ae3f3ca61ca0587073bf4/GNCCrowdsale.sol:SafeMath:min64(uint64,uint64)","0x01b840bc3f9243733d5ae3f3ca61ca0587073bf4/GNCCrowdsale.sol:SafeMath:min256(uint256,uint256)",0.9864864864864864,4,4,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function CanToken() public {
        symbol = ""CAN"";
        name = ""CAN Coin"";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x2A7566f25B8ec8A96487dc2a453013d01c682CdB] = _totalSupply;
        Transfer(address(0), 0x2A7566f25B8ec8A96487dc2a453013d01c682CdB, _totalSupply);
    }
",0x2f88952012fae10de6341d018692bf470c14d13d/CanToken.sol:CanToken:balanceOf(address),0x2f88952012fae10de6341d018692bf470c14d13d/CanToken.sol:CanToken:CanToken(),0.365625,1,1,0
"    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }
","    function approve(address _spender, uint256 _value) public returns(bool) {
        require((_value == 0) || (allowances[msg.sender][_spender] == 0));
        allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x3cda321291949b3e0f2e8cc2d5ba9cfbfdbaf049/EGCToken.sol:TokenERC20:balanceOf(address),"0x3cda321291949b3e0f2e8cc2d5ba9cfbfdbaf049/EGCToken.sol:TokenERC20:approve(address,uint256)",0.02564102564102564,1,1,0
"    function parseInt(string _a, uint _b) internal pure returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }
","    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseInt(string,uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[1],uint256)",0.5,1,1,0
"	function regionExists(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUpdatedAt(_regionId) > 0;
	}
","	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageDataLength(_imageId, _part);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:regionExists(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getImageDataLength(uint256,uint16)",0.5,1,1,0
"  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
    //if token supply was not limited then we would prevent wrap:
    //if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to])
    if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && _value > 0) {
      balances[_from] -= _value;
      balances[_to] += _value;
      approvals[_from][msg.sender] -= _value;
      TransferEvent(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }
","  function totalSupply() public constant returns (uint supply) { supply = tokenSupply; }
","0x0edde4b6f91dbd2efd075ace85ec2e52d0696d44/BurnableToken.sol:BurnableToken:transferFrom(address,address,uint256)",0x0edde4b6f91dbd2efd075ace85ec2e52d0696d44/BurnableToken.sol:BurnableToken:totalSupply(),0.0015151515151515152,1,1,0
"  function setMinInvestedLimit(uint newMinInvestedLimit) public onlyOwner {
    minInvestedLimit = newMinInvestedLimit;
  }
","  function setDirectMintAgent(address newDirectMintAgent) public onlyOwner {
    directMintAgent = newDirectMintAgent;
  }
",0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:CommonCrowdsale:setMinInvestedLimit(uint256),0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:CommonCrowdsale:setDirectMintAgent(address),1.0,4,4,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function ALEX(){
     balanceOf[msg.sender] = totalSupply;
    }
","0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae/ALEX.sol:ALEX:_transfer(address,address,uint256)",0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae/ALEX.sol:ALEX:ALEX(),0.038860103626943004,1,1,0
"  function disableRefundPeriod() external onlyOwner{
  withinRefundPeriod = false;
  }
","  function emergencyStop() external onlyOwner {
    stopped = true;
  }
",0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:ZCrowdsale:disableRefundPeriod(),0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:ZCrowdsale:emergencyStop(),0.0,1,1,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
",0x5c493a221ae9b49c3e45f2df8a3b34223855c1f4/EverGold.sol:Ownable:onlyOwner(),0x5c493a221ae9b49c3e45f2df8a3b34223855c1f4/EverGold.sol:Ownable:renounceOwnership(),0.05926979611190138,1,1,0
"    function getMainLockup() public view returns(uint256){
        return mainLockup;
    }
","    function getMainBalance() public view returns(uint256){
        return token.balanceOf(this);
    }
",0x7b57ee1e32e2b3453838482970bf63c28b2472c9/Safe.sol:Safe:getMainLockup(),0x7b57ee1e32e2b3453838482970bf63c28b2472c9/Safe.sol:Safe:getMainBalance(),0.0,1,1,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x7f4C1ea56e9E4ab0B47bddc396F131074919E25f/NinjaCoinNC.sol:SafeMath:add(uint256,uint256)","0x7f4C1ea56e9E4ab0B47bddc396F131074919E25f/NinjaCoinNC.sol:SafeMath:mul(uint256,uint256)",0.9758426966292136,4,4,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","0x5fa1ea99eb3acc1f9e84cf28fde6431b8fdc9dc0/UselessAirdroppedToken.sol:UselessAirdroppedToken:approve(address,uint256)",0x5fa1ea99eb3acc1f9e84cf28fde6431b8fdc9dc0/UselessAirdroppedToken.sol:UselessAirdroppedToken:withdrawForeignTokens(address),0.3375796178343949,1,1,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
",0x5b7821baebcc7e1fa8eadd1220d3bbc02e9b28a3/CTODToken.sol:StandardToken:balanceOf(address),"0x5b7821baebcc7e1fa8eadd1220d3bbc02e9b28a3/CTODToken.sol:StandardToken:allowance(address,address)",0.5915065722952477,1,1,0
"    modifier onlyPayloadSize(uint size) {
        require(msg.data.length >= size + 4);
        _;
    }
","    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
",0x8a113a57e74aef531bee8de7e16e604916f053ac/ClipperCoin.sol:StandardToken:onlyPayloadSize(uint256),"0x8a113a57e74aef531bee8de7e16e604916f053ac/ClipperCoin.sol:StandardToken:transferFrom(address,address,uint256)",0.015873015873015872,1,1,0
"    function issue(address _to, uint _value) public only_owner safe_arguments(2) returns (bool) {
        
        // Check for overflows
        require(balances[_to] + _value >= balances[_to]);

        // Create tokens
        balances[_to] += _value;
        totalTokenSupply += _value;

        // Notify listeners 
        Transfer(0, this, _value);
        Transfer(this, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint _value) public only_when_unlocked returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:issue(address,uint256)","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:transferFrom(address,address,uint256)",1.0,4,4,1
"    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(_from, _to, _value);
    }
","    function burnFrom(address _from, uint256 _value) returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x3d7e4eb0facef2aaffaa07b7a61c7c1c49ffa2d4/KEKEcon.sol:KEKEcon:_transfer(address,address,uint256)","0x3d7e4eb0facef2aaffaa07b7a61c7c1c49ffa2d4/KEKEcon.sol:KEKEcon:burnFrom(address,uint256)",0.4262295081967213,1,1,0
"    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[5],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:indexOf(string,string)",0.8,1,1,0
"	modifier approvedContractsOnly ()
	{
		require(approvedContracts[msg.sender]);
		_;
	}
","	function offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)
		{
			Interface c = Interface(_contract);
			c.offerIndexedPieceForSale(_index, _price);
		}
",0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:approvedContractsOnly(),"0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:offerIndexedPieceForSaleByAddress(address,uint256,uint256)",0.3333333333333333,1,1,0
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7/Bgc.sol:Bgc:burnFrom(address,uint256)","0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7/Bgc.sol:Bgc:transfer(address,uint256)",0.8851174934725848,1,1,0
"    function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {
        if(transferIns[_address].length <= 0) return 0;

        for (uint i = 0; i < transferIns[_address].length; i++){
            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;

            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));
            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;

            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));
        }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x1ea976a4abbdbcc67d9b4fd6d5dba23618fb52fd/Aecium.sol:Aecium:getCoinAge(address,uint256)",0x1ea976a4abbdbcc67d9b4fd6d5dba23618fb52fd/Aecium.sol:Aecium:balanceOf(address),0.9444444444444444,4,4,1
"	function	setPOOL_edit_4	(	string	newPOOL_edit_4	)	public	onlyOwner	{	
		inPOOL_edit_4	=	newPOOL_edit_4	;					
	}									
","	function	setPOOL_edit_26	(	string	newPOOL_edit_26	)	public	onlyOwner	{	
		inPOOL_edit_26	=	newPOOL_edit_26	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_4(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_26(string),1.0,4,4,1
"		function	getData_20	()	public	constant	returns	(	string	)	{
			return	inData_20	;						
		}									
","		function	getData_27	()	public	constant	returns	(	string	)	{
			return	inData_27	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_20(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_27(),1.0,4,4,1
"    modifier oraclizeAPI {
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))
            oraclize_setNetwork(networkID_auto);

        if(address(oraclize) != OAR.getAddress())
            oraclize = OraclizeI(OAR.getAddress());

        _;
    }
","    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclizeAPI(),0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setNetworkName(string),1.0,4,4,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            
        totalSupply = totalSupply.sub(_value);                      
        Burn(msg.sender, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
",0x5ab468e962637e4eecd6660f61b5b4a609e66e13/FTWToken.sol:FTWToken:burn(uint256),"0x5ab468e962637e4eecd6660f61b5b4a609e66e13/FTWToken.sol:FTWToken:approve(address,uint256)",0.5714285714285714,1,1,0
"	function withdraw_tokens_for(address _addy) {
		for (uint8 i = contributors[_addy].rounds; i < rounds; i++) {
			withdraw(_addy);
		}
	}
","	function buy_the_tokens(bytes _data) onlyOwner {
		require(!bought_tokens && sale != 0x0);
		bought_tokens = true;
		const_contract_eth_value = this.balance;
		take_fees_eth_dev();
		take_fees_eth_owner();
		const_contract_eth_value = this.balance;
		require(sale.call.gas(msg.gas).value(this.balance)(_data));
	}
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:withdraw_tokens_for(address),0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:buy_the_tokens(bytes),1.0,4,4,1
"    function calculateDevFee(uint256 amount) public view returns(uint256){
        return SafeMath.div(SafeMath.mul(amount,4),100);
    }
","    function seedMarket(uint256 eggs) public payable {
        require(msg.sender == ceoAddress);
        require(marketEggs == 0);
        initialized = true;
        marketEggs = eggs;
    }
",0x8c7f97965f6811e5f1e839ef23d38d2ecd86a445/CrabFarm.sol:CrabFarm:calculateDevFee(uint256),0x8c7f97965f6811e5f1e839ef23d38d2ecd86a445/CrabFarm.sol:CrabFarm:seedMarket(uint256),0.09090909090909093,1,1,0
"    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
","    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }
",0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:burn(uint256),0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:disableWhitelist(address[]),0.35714285714285715,1,1,0
"    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","0x0f5e5b61c47c97235e7109d99e320c3bd0237f3b/ImperialCreditToken.sol:SafeMath:safeMul(uint256,uint256)","0x0f5e5b61c47c97235e7109d99e320c3bd0237f3b/ImperialCreditToken.sol:SafeMath:safeAdd(uint256,uint256)",0.4929859719438878,1,1,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) onlyOwner public
    returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function setAdmin(address addr, bool enabled) onlyOwner public {
        admin[addr]=enabled;
    }
","0x5bfEA7DaA03d28585D5F5307B27bd5c2f0448Fb5/FaceTech.sol:FaceTech:approveAndCall(address,uint256,bytes)","0x5bfEA7DaA03d28585D5F5307B27bd5c2f0448Fb5/FaceTech.sol:FaceTech:setAdmin(address,bool)",0.0020833333333333333,1,1,0
"    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
",0x4bc240a49a83885f2eeb5ba2693be9a560294290/EcomethToken.sol:EcomethToken:canDistr(),"0x4bc240a49a83885f2eeb5ba2693be9a560294290/EcomethToken.sol:EcomethToken:distr(address,uint256)",0.3283582089552239,1,1,0
"	function	setPI_edit_13	(	string	newPI_edit_13	)	public	onlyOwner	{	
		inPI_edit_13	=	newPI_edit_13	;					
	}									
","	function	getPI_edit_24	()	public	constant	returns	(	string	)	{
		return	inPI_edit_24	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_13(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_24(),1.0,4,4,1
"    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x0e8c10d2bb028633684a145c0a6ac39ec63b4bad/BitcoinExchange.sol:Owned:transferOwnership(address),0x0e8c10d2bb028633684a145c0a6ac39ec63b4bad/BitcoinExchange.sol:Owned:onlyOwner(),0.8634920634920635,1,1,0
"    function setAuthority(DSAuthority authority_)
    auth
    {
        authority = authority_;
        LogSetAuthority(authority);
    }
","    modifier auth {
        assert(isAuthorized(msg.sender, msg.sig));
        _;
    }
",0x1a3d7bcc1fb96bb96e02c863f3e03d9bd1a3c229/DSAuth.sol:DSAuth:setAuthority(DSAuthority),0x1a3d7bcc1fb96bb96e02c863f3e03d9bd1a3c229/DSAuth.sol:DSAuth:auth(),0.42857142857142855,1,1,0
"  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x0dffe2e82d6175bc5cb2ef4ef0f67939ecfdbe3e/EplusCoinToken.sol:SafeMath:min256(uint256,uint256)","0x0dffe2e82d6175bc5cb2ef4ef0f67939ecfdbe3e/EplusCoinToken.sol:SafeMath:safeSub(uint256,uint256)",0.02873563218390805,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[1])",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setProof(bytes1),0.8,1,1,0
"    function remove(int8Set storage self, int8 other) public {
        if (contains(self, other)) {
            uint replaceIndex = self.memberIndices[other];
            int8 lastMember = self.members[length(self)-1];
            // overwrite other with the last member and remove last member
            self.members[replaceIndex-1] = lastMember;
            self.members.length--;
            // reflect this change in the indices
            self.memberIndices[lastMember] = replaceIndex;
            delete self.memberIndices[other];
        }
    }
","    function length(int8Set storage self) public view returns (uint) {
        return self.members.length;
    }
","0x1f5cdff41fb9b17996d6f0fca6ab9c5bed96f20f/Prover.sol:Sets:remove(Sets:int8Set,int8)",0x1f5cdff41fb9b17996d6f0fca6ab9c5bed96f20f/Prover.sol:Sets:length(Sets:int8Set),1.0,4,4,1
"    modifier notTooSmallAmountOnly(){
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }
","    function cfi_whitelist(address addr) public constant returns(bool) { return PRIORITY_ADDRESS_LIST.contains(addr); }
",0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:notTooSmallAmountOnly(),0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:cfi_whitelist(address),0.16666666666666666,1,1,0
"		function	getData_33	()	public	constant	returns	(	string	)	{
			return	inData_33	;						
		}									
","		function	getData_23	()	public	constant	returns	(	string	)	{
			return	inData_23	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_33(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_23(),1.0,4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","0x5Be7d692a8aDC3dff8296f5f316a736b02DceF24/ECTCOIN.sol:ECTCOIN:approveAndCall(address,uint256,bytes)",0x5Be7d692a8aDC3dff8296f5f316a736b02DceF24/ECTCOIN.sol:ECTCOIN:burn(uint256),0.7544910179640718,1,1,0
"  function changeFeeTake(uint feeTake_) {
    require(msg.sender == admin);
    require(feeTake_ <= feeTake && feeTake_ >= feeRebate);
    feeTake = feeTake_;
  }
","  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    orders[msg.sender][hash] = true;
    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);
  }
",0x3acce1678985013da47d44423166b206ec967e31/AdexContract.sol:AdexContract:changeFeeTake(uint256),"0x3acce1678985013da47d44423166b206ec967e31/AdexContract.sol:AdexContract:order(address,uint256,address,uint256,uint256,uint256)",0.0,1,1,0
"    function subtr(uint a, uint b) internal pure returns (uint) {
        assert(b <= a);
        return a - b;
    }
","    function increaseApproval(address _spender, uint _addedValue, bytes _data) external returns (bool) {
        increaseApproval(_spender, _addedValue);
        require(_spender.call(_data));
        return true;
    }
","0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:subtr(uint256,uint256)","0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:increaseApproval(address,uint256,bytes)",0.0,1,1,0
"    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }
","    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }
",0x0b983fa1bcbdf24bdbfacb660faa76c586a16c64/Presale.sol:Presale:inState(Presale:State),0x0b983fa1bcbdf24bdbfacb660faa76c586a16c64/Presale.sol:Presale:tokenHoldersOnly(),0.8571428571428571,1,1,0
"  function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
    require(targets.length > 0);

    for (uint i = 0; i < targets.length; i++) {
      require(targets[i] != 0x0);
      frozenAccount[targets[i]] = isFrozen;
      FrozenFunds(targets[i], isFrozen);
    }
  }
","  function symbol() public view returns (string _symbol) {
      return symbol;
  }
","0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:freezeAccounts(address[],bool)",0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:symbol(),1.0,5,5,1
"  function transfer(address _to, uint256 _value) returns (bool success) {
    require(bIsFreezeAll == false);
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function totalSupply() constant returns (uint256 totalSupply) {
	totalSupply = _totalSupply;
  }
","0x01E45B8D0c51f05F17385DD3416fE3aA5BFd89aC/COINBIG.sol:StandardToken:transfer(address,uint256)",0x01E45B8D0c51f05F17385DD3416fE3aA5BFd89aC/COINBIG.sol:StandardToken:totalSupply(),0.0,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
","    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:ecrecovery(bytes32,bytes)",0.8,1,1,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x5a01b24ec723b30de5fb4fca9915927bda0dedb9/SkrumbleStaking.sol:SafeMath:div(uint256,uint256)","0x5a01b24ec723b30de5fb4fca9915927bda0dedb9/SkrumbleStaking.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,5,5,1
"    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","0x6b193e107a773967bd821bcf8218f3548cfa2503/PossContract.sol:SafeMath:safeSub(uint256,uint256)","0x6b193e107a773967bd821bcf8218f3548cfa2503/PossContract.sol:SafeMath:safeAdd(uint256,uint256)",0.983402489626556,5,5,1
"    function EthereumPrivate() public {
        totalSupply = 960000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;           // Give the creator all initial tokens
        name = 'Ethereum Private';                      // Set the name for display purposes
        symbol = 'ETHP';                                // Set the symbol for display purposes
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
",0x6d358ad6eca1461f092659797e8dceb2d5150fa6/EthereumPrivate.sol:EthereumPrivate:EthereumPrivate(),"0x6d358ad6eca1461f092659797e8dceb2d5150fa6/EthereumPrivate.sol:EthereumPrivate:burnFrom(address,uint256)",1.0,5,5,1
"    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
",0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:balanceOf(address),"0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:adminClaimAirdrop(address,uint256)",0.05128205128205128,1,1,0
"  function distributeTokens(address[] addresses, uint256 amount) public returns (bool) {
    require(amount > 0
            && addresses.length > 0
            && frozenAccount[msg.sender] == false
            && now > unlockUnixTime[msg.sender]);

    amount = SafeMath.mul(amount, 1e8);
    uint256 totalAmount = SafeMath.mul(amount, addresses.length);
    require(balances[msg.sender] >= totalAmount);

    for (uint i = 0; i < addresses.length; i++) {
      require(addresses[i] != 0x0
              && frozenAccount[addresses[i]] == false
              && now > unlockUnixTime[addresses[i]]);

      balances[addresses[i]] = SafeMath.add(balances[addresses[i]], amount);
      Transfer(msg.sender, addresses[i], amount);
    }
    balances[msg.sender] = SafeMath.sub(balances[msg.sender], totalAmount);
    return true;
  }
","  function symbol() public view returns (string _symbol) {
      return symbol;
  }
","0x4c54e5ee228b1c917980687a7e54876c340fed7f/Seiyuu.sol:Seiyuu:distributeTokens(address[],uint256)",0x4c54e5ee228b1c917980687a7e54876c340fed7f/Seiyuu.sol:Seiyuu:symbol(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x4add749fcd5a44ecad43dc6f3dafdd306bd931f8/EtherConnect.sol:EtherConnect:transfer(address,uint256)","0x4add749fcd5a44ecad43dc6f3dafdd306bd931f8/EtherConnect.sol:EtherConnect:transferFrom(address,address,uint256)",0.8706697459584296,1,1,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
","0x1f0480a66883de97d2b054929252aae8f664c15c/NePay.sol:NePay:approve(address,uint256)",0x1f0480a66883de97d2b054929252aae8f664c15c/NePay.sol:NePay:burn(uint256),0.4732142857142857,1,1,0
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x4c4d11f7ec61d0cff19a80bb513695bf12177398/MicroMeGameCoin.sol:TokenERC20:TokenERC20(uint256,string,string)","0x4c4d11f7ec61d0cff19a80bb513695bf12177398/MicroMeGameCoin.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.9634703196347032,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","0x0decb54cd44375cb5cb486cec40f209c7d37d26d/SparksterToken.sol:SparksterToken:approveAndCall(address,uint256,bytes)","0x0decb54cd44375cb5cb486cec40f209c7d37d26d/SparksterToken.sol:SparksterToken:transfer(address,uint256)",0.835016835016835,1,1,0
"    function burn(address _from, uint256 _unitAmount) onlyOwner public {
        require(_unitAmount > 0
                && balanceOf[_from] >= _unitAmount);

        balanceOf[_from] = balanceOf[_from].sub(_unitAmount);
        totalSupply = totalSupply.sub(_unitAmount);
        Burn(_from, _unitAmount);
    }
","    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:burn(address,uint256)","0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:transferToAddress(address,uint256,bytes)",0.7857142857142857,1,1,0
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x06dafc2a5fe47fcc9f37b5f91c0c2bd1cf2a9a4c/FlypCrowdsale.sol:Ownable:transferOwnership(address),0x06dafc2a5fe47fcc9f37b5f91c0c2bd1cf2a9a4c/FlypCrowdsale.sol:Ownable:onlyOwner(),0.9899874843554444,5,5,1
"	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}
","	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:getTokenIdsLength(),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:decrementTokenIdsLength(),1.0,5,5,1
"    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }
","    function transferFrom(
         address _from,
         address _to,
         uint256 _amount
     ) public returns (bool success) {
         if (balances[_from] >= _amount
             && allowed[_from][msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             balances[_to] += _amount;
             return true;
         } else {
             return false;
         }
  }
",0x6FDFCe60998725F4cFB4Cc57505A3abDbb6d0646/SelfKeyToken.sol:SelfKeyToken:totalSupply(),"0x6FDFCe60998725F4cFB4Cc57505A3abDbb6d0646/SelfKeyToken.sol:SelfKeyToken:transferFrom(address,address,uint256)",0.38461538461538464,1,1,0
"    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        require(a == 0 || c / a == b);
        return c;
    }
","    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c>=a && c>=b);
        return c;
    }
","0x6bbb3f23c64e840a381e0615635475c56324d784/BEU.sol:SafeMath:safeMul(uint256,uint256)","0x6bbb3f23c64e840a381e0615635475c56324d784/BEU.sol:SafeMath:safeAdd(uint256,uint256)",0.02598091198303288,1,1,0
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x1d28be41db5eaedba0f1070b04117e25e8487670/dCHF.sol:dCHF:balanceOf(address),"0x1d28be41db5eaedba0f1070b04117e25e8487670/dCHF.sol:dCHF:approveAndCall(address,uint256,bytes)",0.921875,1,1,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x6b16eebe4f233236adf960cfffbf5e677e9967d7/FreelanceToken.sol:StandardToken:transfer(address,uint256)","0x6b16eebe4f233236adf960cfffbf5e677e9967d7/FreelanceToken.sol:StandardToken:approve(address,uint256)",0.9742268041237112,5,5,1
"		function	setData_15	(	string	newData_15	)	public	onlyOwner	{	
			inData_15	=	newData_15	;					
		}									
","		function	getData_27	()	public	constant	returns	(	string	)	{
			return	inData_27	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_15(string),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_27(),1.0,5,5,1
"  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }
","  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       throw;
     }
     _;
  }
","0x3a26746ddb79b1b8e4450e3f4ffe3285a307387e/SimpleToken.sol:BasicToken:transfer(address,uint256)",0x3a26746ddb79b1b8e4450e3f4ffe3285a307387e/SimpleToken.sol:BasicToken:onlyPayloadSize(uint256),0.9230769230769232,1,1,0
"    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[5])","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[3],uint256)",1.0,5,5,1
"	function	getPOOL_edit_11	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_11	;						
	}									
","	function	getPOOL_edit_12	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_12	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_11(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_12(),1.0,5,5,1
"    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[3],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[1],uint256)",1.0,5,5,1
"	function	setPOOL_edit_15	(	string	newPOOL_edit_15	)	public	onlyOwner	{	
		inPOOL_edit_15	=	newPOOL_edit_15	;					
	}									
","	function	getPOOL_edit_11	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_11	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_15(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_11(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) noStopped public returns(bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
","    function totalSupply() constant public returns (uint256) {
        return totalSupply;
    }
","0x2a30bbf2d9764223c9afe5ac7c207aa338b9cd1a/HHH4.sol:HHH4:transfer(address,uint256)",0x2a30bbf2d9764223c9afe5ac7c207aa338b9cd1a/HHH4.sol:HHH4:totalSupply(),0.05555555555555555,1,1,0
"    constructor() public {
        supportedInterfaces[0x80ac58cd] = true; // ERC721
    }
","    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {
        _safeTransferFrom(_from, _to, _tokenId, _data);
    }
",0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:constructor(),"0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:safeTransferFrom(address,address,uint256,bytes)",0.2727272727272727,1,1,0
"    function setPrices(uint256 _tokenPrice) onlyOwner public {
        tokenPrice = _tokenPrice;
    }
","    function buy() payable public {
        uint amount = msg.value / tokenPrice;
        require (totalSupply >= amount);
        require(!frozenAccount[msg.sender]);
        totalSupply -= amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
    }
",0x5B5D0fbBd75d4501E5CDc854c445fb0eABcB0AFc/EmrCrowdfund.sol:EmrCrowdfund:setPrices(uint256),0x5B5D0fbBd75d4501E5CDc854c445fb0eABcB0AFc/EmrCrowdfund.sol:EmrCrowdfund:buy(),1.0,5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x2cd21428ff2857f05795b08f000a27d4ced12f0e/MYL.sol:MYL:burn(uint256),"0x2cd21428ff2857f05795b08f000a27d4ced12f0e/MYL.sol:MYL:transferFrom(address,address,uint256)",0.8829039812646371,1,1,0
"  function safeSub (uint256 x, uint256 y)
  constant internal
  returns (uint256 z) {
    assert (x >= y);
    return x - y;
  }
","  function safeMul (uint256 x, uint256 y)
  constant internal
  returns (uint256 z) {
    if (y == 0) return 0; // Prevent division by zero at the next line
    assert (x <= MAX_UINT256 / y);
    return x * y;
  }
","0x6dd4e4aad29a40edd6a409b9c1625186c9855b4d/ParkgeneToken.sol:SafeMath:safeSub(uint256,uint256)","0x6dd4e4aad29a40edd6a409b9c1625186c9855b4d/ParkgeneToken.sol:SafeMath:safeMul(uint256,uint256)",0.4528301886792453,1,1,0
"	function	setPOOL_edit_6	(	string	newPOOL_edit_6	)	public	onlyOwner	{	
		inPOOL_edit_6	=	newPOOL_edit_6	;					
	}									
","	function	setPOOL_edit_5	(	string	newPOOL_edit_5	)	public	onlyOwner	{	
		inPOOL_edit_5	=	newPOOL_edit_5	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_6(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_5(string),0.6666666666666666,1,1,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x5da8f9b476d9ecc3b437264e2919daa51f765365/LogiETHToken.sol:LogiETHToken:approveAndCall(address,uint256,bytes)","0x5da8f9b476d9ecc3b437264e2919daa51f765365/LogiETHToken.sol:LogiETHToken:approve(address,uint256)",0.846307385229541,1,1,0
"  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x2cf2d4919e639b25b806126eb5c97d043ffb0a70/ScienceToken.sol:StandardToken:transferFrom(address,address,uint256)","0x2cf2d4919e639b25b806126eb5c97d043ffb0a70/ScienceToken.sol:StandardToken:approve(address,uint256)",0.903485254691689,1,1,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x3e5dd078b2cdc9a202cec8875efae59a324373f8/KMRCTToken.sol:KMRCTToken:totalSupply(),"0x3e5dd078b2cdc9a202cec8875efae59a324373f8/KMRCTToken.sol:KMRCTToken:approveAndCall(address,uint256,bytes)",0.9781021897810219,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x6be98275cb30e4d64ebe6be942cd87268dfea3a5/BusinessAutomationUnion.sol:BusinessAutomationUnion:transferFrom(address,address,uint256)",0x6be98275cb30e4d64ebe6be942cd87268dfea3a5/BusinessAutomationUnion.sol:BusinessAutomationUnion:balanceOf(address),0.9913793103448276,5,5,1
"  modifier whenPaused {
      require(paused);
    _;
  }
","  modifier whenNotPaused() {
      require(!paused);
    _;
  }
",0x06c9b941f1895e89ec7459975a71d29f2f1456ba/DatumTokenDistributor.sol:Pausable:whenPaused(),0x06c9b941f1895e89ec7459975a71d29f2f1456ba/DatumTokenDistributor.sol:Pausable:whenNotPaused(),0.9795918367346941,5,5,1
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

         if (balances[_from] >= _amount
             && allowed[_from][msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
            return false;
         }
    }
","    function finishDistribute() onlyOwner public returns (bool) {
    distributionFinished = true;
    DistrFinished();
    return true;
    }
","0x0f43e50aa2ec14296a33f68d0c8c605b3acc08dc/TAKLIMAKAN.sol:TAKLIMAKAN:transferFrom(address,address,uint256)",0x0f43e50aa2ec14296a33f68d0c8c605b3acc08dc/TAKLIMAKAN.sol:TAKLIMAKAN:finishDistribute(),0.1076923076923077,1,1,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x2f4f6c055a7c8ab529f5b01f6616164aaeec18ad/EEEToken.sol:SafeMath:sub(uint256,uint256)","0x2f4f6c055a7c8ab529f5b01f6616164aaeec18ad/EEEToken.sol:SafeMath:mul(uint256,uint256)",0.9659477866061292,5,5,1
"    function setName(string _name) onlyOwner public {
        name = _name;
    }
","    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
",0x7e04a8c9b52f3698b3d4f660254b06ff904b48ae/UZEEToken.sol:UZEEToken:setName(string),0x7e04a8c9b52f3698b3d4f660254b06ff904b48ae/UZEEToken.sol:UZEEToken:totalSupply(),0.1,1,1,0
"    function Owned() public {
        owner = msg.sender;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x0fbbfd1243552c8a66ab05c1f9530fb116e9fff4/AlicToken.sol:Owned:Owned(),0x0fbbfd1243552c8a66ab05c1f9530fb116e9fff4/AlicToken.sol:Owned:onlyOwner(),0.8075117370892019,1,1,0
"    function getOwner() external constant returns (address) {
        return owner;
    }
","    function addBlackList (address _evilUser) public onlyOwner {
        isBlackListed[_evilUser] = true;
        AddedBlackList(_evilUser);
    }
",0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:BlackList:getOwner(),0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:BlackList:addBlackList(address),0.14285714285714285,1,1,0
"    function MUBEX() public {
        totalSupply = 500000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;           // Give the creator all initial tokens
        name = 'MUBEX';                      // Set the name for display purposes
        symbol = 'MBX';                                // Set the symbol for display purposes
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
",0x8af9e74991044827449946d334a478b6fe8f5740/MUBEX.sol:MUBEX:MUBEX(),0x8af9e74991044827449946d334a478b6fe8f5740/MUBEX.sol:MUBEX:burn(uint256),1.0,5,5,1
"	function _transferFrom(address _from, address _to, uint256 _value)  internal {
	    require(_to != 0x0);
	    require(balanceOf[_from] >= _value);
	    require(balanceOf[_to] + _value >= balanceOf[_to]);

	    balanceOf[_from] = balanceOf[_from].sub(_value);
	    balanceOf[_to] = balanceOf[_to].add(_value);

	    Transfer(_from, _to, _value);
	}
","	function getCurrentTimestamp() internal view returns (uint256){
	    return now;
	}
","0x4cf526f412a88371e899336bd54388ef50dafaf6/SocialMediaToken.sol:SocialMediaToken:_transferFrom(address,address,uint256)",0x4cf526f412a88371e899336bd54388ef50dafaf6/SocialMediaToken.sol:SocialMediaToken:getCurrentTimestamp(),0.0,1,1,0
"    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
        require((_nbytes > 0) && (_nbytes <= 32));
        bytes memory nbytes = new bytes(1);
        nbytes[0] = byte(_nbytes);
        bytes memory unonce = new bytes(32);
        bytes memory sessionKeyHash = new bytes(32);
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
        assembly {
            mstore(unonce, 0x20)
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
            mstore(sessionKeyHash, 0x20)
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
        }
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];
        bytes32 queryId = oraclize_query(_delay, ""random"", args, _customGasLimit);
        oraclize_randomDS_setCommitment(queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));
        return queryId;
    }
","    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_newRandomDSQuery(uint256,uint256,uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[])",1.0,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x1aD8e98a828D8c460e994F279E35fbE4cf213bA6/CommitGoodToken.sol:SafeMath:sub(uint256,uint256)","0x1aD8e98a828D8c460e994F279E35fbE4cf213bA6/CommitGoodToken.sol:SafeMath:mul(uint256,uint256)",0.5822928490351873,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x6a4e703c8c2bd0d9036e65acf6d476ce38f3d981/GlobalChain.sol:GlobalChain:approve(address,uint256)",0x6a4e703c8c2bd0d9036e65acf6d476ce38f3d981/GlobalChain.sol:GlobalChain:balanceOf(address),0.9682539682539684,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x8a63a921b5d678b4a27dc81e44321923e297b4cf/Doves.sol:Doves:transferAnyERC20Token(address,uint256)",0x8a63a921b5d678b4a27dc81e44321923e297b4cf/Doves.sol:Doves:totalSupply(),0.8585209003215434,1,1,0
"	modifier onlyOwner {
		assert(msg.sender == owner);
		_;
	}
","	function getAffiliate(address refferal) public returns (address)
	{
		return affiliates[refferal];
	}
",0x7f373b93464d093671469be3e4f06a06c3c3a7ca/EthermiumAffiliates.sol:EthermiumAffiliates:onlyOwner(),0x7f373b93464d093671469be3e4f06a06c3c3a7ca/EthermiumAffiliates.sol:EthermiumAffiliates:getAffiliate(address),0.0,1,1,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x3f5d00617ffb9947f7cf1fadee2cc93ee3ab5426/NintendoCoin.sol:NintendoCoin:approve(address,uint256)","0x3f5d00617ffb9947f7cf1fadee2cc93ee3ab5426/NintendoCoin.sol:NintendoCoin:transferFrom(address,address,uint256)",0.3666129898013956,1,1,0
"	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}
","	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:getTokenOwner(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:decrementOwnedArea(address,uint256)",1.0,5,5,1
"    function confirmProposal(ProposalInterface _proposal)
    external
    {
        require(accounts[msg.sender].membership & BOARD != 0);
        Account storage account = accounts[_proposal];
        require(account.membership & PENDING_PROPOSAL != 0);
        account.membership ^= (PROPOSAL | PENDING_PROPOSAL);
        Proposal(_proposal);
    }
","    function isProposal(address _proposal)
    external view
    returns (bool)
    {
        return accounts[_proposal].membership & PROPOSAL != 0;
    }
",0x000000002bb43c83ece652d161ad0fa862129a2c/AccountRegistry.sol:AccountRegistry:confirmProposal(ProposalInterface),0x000000002bb43c83ece652d161ad0fa862129a2c/AccountRegistry.sol:AccountRegistry:isProposal(address),1.0,4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x3dcefbedf17bc3ecea1a40052239da89c22766b8/AGAVE.sol:AGAVE:transferFrom(address,address,uint256)","0x3dcefbedf17bc3ecea1a40052239da89c22766b8/AGAVE.sol:AGAVE:transfer(address,uint256)",0.8747099767981439,2,2,0
"    function ALU(
    ) public {
        totalSupply = 2000000000000000000000000000;                       // Total supply with the decimal amount
        balanceOf[msg.sender] = 2000000000000000000000000000;             // All initial tokens
        name = ""ALIUS"";                                                   // The name for display purposes
        symbol = ""ALU"";                                                   // The symbol for display purposes
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
",0x5db6a84257053b65983cc8ec67ca57ac0aa6603e/ALU.sol:ALU:ALU(),"0x5db6a84257053b65983cc8ec67ca57ac0aa6603e/ALU.sol:ALU:transfer(address,uint256)",1.0,5,5,1
"    function removeNFToken(address _from, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == _from);
        assert(ownerToNFTokenCount[_from] > 0);
        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;
        delete idToOwner[_tokenId];
    }
","    function _burn(address _owner, uint256 _tokenId) validNFToken(_tokenId) internal { 
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }
","0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:removeNFToken(address,uint256)","0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:_burn(address,uint256)",1.0,5,5,1
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 100000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = ""Warh"";                                   // Set the name for display purposes
        symbol = ""Warh"";                               // Set the symbol for display purposes
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x2b4fc40240fb32b1d1881a37c370328fc11ce780/Warh.sol:Warh:TokenERC20(uint256,string,string)",0x2b4fc40240fb32b1d1881a37c370328fc11ce780/Warh.sol:Warh:burn(uint256),1.0,5,5,1
"	function	getPI_edit_13	()	public	constant	returns	(	string	)	{
		return	inPI_edit_13	;						
	}									
","	function	setPI_edit_28	(	string	newPI_edit_28	)	public	onlyOwner	{	
		inPI_edit_28	=	newPI_edit_28	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_13(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_28(string),1.0,5,5,1
"    function transfer(address _to, uint256 _value) public returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x7e68e18fb83a8f1d092a9e4dbf36bd9dc3029ed0/Best1CoinToken.sol:StandardToken:transfer(address,uint256)","0x7e68e18fb83a8f1d092a9e4dbf36bd9dc3029ed0/Best1CoinToken.sol:StandardToken:allowance(address,address)",0.8965517241379308,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x7c85d043bde79c85Ef113a35793B8FB324991F3e/AceFund.sol:StandardToken:transferFrom(address,address,uint256)","0x7c85d043bde79c85Ef113a35793B8FB324991F3e/AceFund.sol:StandardToken:approve(address,uint256)",0.894878706199461,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x1e4300510ef90de505ddbcb77cdc8c4ab3f6d7c9/VITToken.sol:TokenERC20:transfer(address,uint256)","0x1e4300510ef90de505ddbcb77cdc8c4ab3f6d7c9/VITToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8267898383371824,2,2,0
"	function registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly
		{
		if (SHA256HashRegister[_SHA256Hash] == 0x0) {
		   	SHA256HashRegister[_SHA256Hash] = _contract;
			approvedContracts[_contract] = true;
			cantSetReferrer[_artist] = true;
			artworkRegister[_contract].SHA256Hash = _SHA256Hash;
			artworkRegister[_contract].editionSize = _editionSize;
			artworkRegister[_contract].title = _title;
			artworkRegister[_contract].fileLink = _fileLink;
			artworkRegister[_contract].ownerCommission = _ownerCommission;
			artworkRegister[_contract].artist = _artist;
			artworkRegister[_contract].factory = msg.sender;
			artworkRegister[_contract].isIndexed = _indexed;
			artworkRegister[_contract].isOuroboros = _ouroboros;
			artworkIndex[artworkCount] = _contract;
			artistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;
			artistsArtworkCount[_artist]++;
			artworksFactory[_contract] = msg.sender;
			NewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);
			artworkCount++;
			}
			else {throw;}
		}
","	function transfer(address _to, uint256 _amount) returns (bool success) {
		if (balances[msg.sender] >= _amount 
			&& _amount > 0
 		   	&& balances[_to] + _amount > balances[_to]
			&& _to != 0x0)										// use burn() instead
			{
			balances[msg.sender] -= _amount;
			balances[_to] += _amount;
			Transfer(msg.sender, _to, _amount);
 		   	return true;
			}
			else { return false;}
 		 }
","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:registerArtwork(address,bytes32,uint256,string,string,uint256,address,bool,bool)","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:transfer(address,uint256)",1.0,5,5,1
"    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
        if ((_nbytes == 0)||(_nbytes > 32)) throw;
        bytes memory nbytes = new bytes(1);
        nbytes[0] = byte(_nbytes);
        bytes memory unonce = new bytes(32);
        bytes memory sessionKeyHash = new bytes(32);
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
        assembly {
            mstore(unonce, 0x20)
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
            mstore(sessionKeyHash, 0x20)
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
        }
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];
        bytes32 queryId = oraclize_query(_delay, ""random"", args, _customGasLimit);
        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));
        return queryId;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_newRandomDSQuery(uint256,uint256,uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",1.0,5,5,1
"    function setSymbol(string _symbol) isOwner{
        symbol = _symbol;
    }
","    function approve(address _spender, uint256 _value) validAddress returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x6ca0b0bdf42389c197aed000854c1a99c2c740d4/GUIDEToken.sol:GUIDEToken:setSymbol(string),"0x6ca0b0bdf42389c197aed000854c1a99c2c740d4/GUIDEToken.sol:GUIDEToken:approve(address,uint256)",1.0,5,5,1
"  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x01c0ae46166b63db76ffd9296d8d36b203efa75b/INFO.sol:Pausable:pause(),0x01c0ae46166b63db76ffd9296d8d36b203efa75b/INFO.sol:Pausable:whenNotPaused(),0.991150442477876,5,5,1
"    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return query(_timestamp, _datasource, _arg, _gaslimit);
    }
","    function addDSource(string dsname, uint multiplier) {
        addDSource(dsname, 0x00, multiplier);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query_withGasLimit(uint256,string,string,uint256)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:addDSource(string,uint256)",0.5,2,2,0
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function PAYToken() public {
        symbol = ""PAY"";
        name = ""Pay Coin"";
        decimals = 2;
        _totalSupply = 1000000000000 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
","0x5cd0cb65110ecad11eb7880024495c4e6dfb5900/PAYToken.sol:PAYToken:approveAndCall(address,uint256,bytes)",0x5cd0cb65110ecad11eb7880024495c4e6dfb5900/PAYToken.sol:PAYToken:PAYToken(),0.09090909090909093,2,2,0
"    function parseInt(string _a, uint _b) internal returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:parseInt(string,uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[2],uint256)",0.5,2,2,0
"    function keccak(slice self) internal returns (bytes32 ret) {
        assembly {
            ret := sha3(mload(add(self, 32)), mload(self))
        }
    }
","    function empty(slice self) internal returns (bool) {
        return self._len == 0;
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:keccak(strings:slice),0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:empty(strings:slice),1.0,5,5,1
"    modifier canMint() {
        require(!mintingFinished);
        _;
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
",0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:canMint(),0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:totalSupply(),0.06481481481481481,2,2,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2de7299355124fdf75c6622beb5713057847665b/Nordic.sol:StandardToken:allowance(address,address)","0x2de7299355124fdf75c6622beb5713057847665b/Nordic.sol:StandardToken:approve(address,uint256)",0.7185374149659864,2,2,0
"    function getFalconmasterReq() public view returns(uint256){
        return falconmasterReq;
    }
","    function sellEggs() public{
        require(initialized);
        uint256 hasEggs=getMyEggs();
        uint256 eggValue=calculateEggSell(hasEggs);
        uint256 fee=devFee(eggValue);
        // kill one third of the owner's falcons on egg sale
        hatcheryFalcon[msg.sender]=SafeMath.mul(SafeMath.div(hatcheryFalcon[msg.sender],3),2);
        claimedEggs[msg.sender]=0;
        lastHatch[msg.sender]=now;
        marketEggs=SafeMath.add(marketEggs,hasEggs);
        ceoAddress.transfer(fee);
        msg.sender.transfer(SafeMath.sub(eggValue,fee));
    }
",0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:FalconFarmer:getFalconmasterReq(),0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:FalconFarmer:sellEggs(),0.75,1,2,0
"    function getTransactionCount(bool pending, bool executed)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<transactionCount; i++)
            if (   pending && !transactions[i].executed
                || executed && transactions[i].executed)
                count += 1;
    }
","    function getOwners()
        public
        constant
        returns (address[])
    {
        return owners;
    }
","0x4ef7dbc186f8abdd4c24257f2a9ff4fd0b31f843/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getTransactionCount(bool,bool)",0x4ef7dbc186f8abdd4c24257f2a9ff4fd0b31f843/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getOwners(),1.0,5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x6bcc07d83b9c51daf176d617c1b1ede8db26e3a2/QLFY.sol:QLFY:burnFrom(address,uint256)","0x6bcc07d83b9c51daf176d617c1b1ede8db26e3a2/QLFY.sol:QLFY:_transfer(address,address,uint256)",0.8590078328981723,1,2,0
"  function balanceOf(address _owner) constant returns (uint256 balance) {
    return accounts [_owner];
  }
","  function transfer(address _to, uint256 _value) returns (bool success) {
    require(_to != address(0));
    if (accounts [msg.sender] < _value) return false;
    if (_value > 0 && msg.sender != _to) {
      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);
      accounts [_to] = safeAdd (accounts [_to], _value);
    }
    Transfer (msg.sender, _to, _value);
    return true;
  }
",0x4acd666e5e13ca28931a9f582c4e55075803bbd0/GTSToken.sol:AbstractToken:balanceOf(address),"0x4acd666e5e13ca28931a9f582c4e55075803bbd0/GTSToken.sol:AbstractToken:transfer(address,uint256)",0.8055555555555556,1,2,0
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 18000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = ""DavinCoin"";                                   // Set the name for display purposes
        symbol = ""DVC""    ;                          // Set the symbol for display purposes
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x1A966D9EF12E1B779B070010554485f8186C0950/DavinCoin.sol:DavinCoin:TokenERC20(uint256,string,string)","0x1A966D9EF12E1B779B070010554485f8186C0950/DavinCoin.sol:DavinCoin:_transfer(address,address,uint256)",1.0,5,5,1
"  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }
","  modifier onlyReleaseAgent() {
    require(msg.sender == releaseAgent);
    _;
  }
","0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:ReleasableToken:transfer(address,uint256)",0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:ReleasableToken:onlyReleaseAgent(),0.28,1,2,0
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_setProof(bytes1),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[3],uint256)",1.0,5,5,1
"	function unfreeze(uint256 _value) returns (bool success) {
        require (balanceOf[msg.sender] >= _value) ;            // Check if the sender has enough
        require (_value > 0) ;
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
		    balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }
","	function isRestrictedAddress(address _querryAddress) constant returns (bool answer){
		return restrictedAddresses[_querryAddress];
	}
",0x0ef27c7606a021457f161859d4952396aff9a92b/FILC.sol:FILC:unfreeze(uint256),0x0ef27c7606a021457f161859d4952396aff9a92b/FILC.sol:FILC:isRestrictedAddress(address),0.0,1,2,0
"    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }
",0x6e1cee3b2971493e705149e828c2a6102a65cf03/AllCash.sol:AllCash:burn(uint256),"0x6e1cee3b2971493e705149e828c2a6102a65cf03/AllCash.sol:AllCash:transferFrom(address,address,uint256)",0.9047619047619048,1,2,0
"    function disableMinting() public {
        data.disableMinting();
    }
","    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        return data.signedTransfer(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:disableMinting(),"0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:signedTransfer(address,address,uint256,uint256,uint256,bytes,address)",1.0,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x7dd23f3aefcad5b4a1cd7d4d4e77bdc487b52580/MthereumToken.sol:MthereumToken:approveAndCall(address,uint256,bytes)",0x7dd23f3aefcad5b4a1cd7d4d4e77bdc487b52580/MthereumToken.sol:MthereumToken:balanceOf(address),0.9932659932659932,5,5,1
"  function symbol() public view returns (string _symbol) {
      return symbol;
  }
","  function burn(address _from, uint256 _unitAmount) onlyOwner public {
    require(_unitAmount > 0
            && balanceOf(_from) >= _unitAmount);

    balances[_from] = SafeMath.sub(balances[_from], _unitAmount);
    totalSupply = SafeMath.sub(totalSupply, _unitAmount);
    Burn(_from, _unitAmount);
  }
",0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:symbol(),"0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:burn(address,uint256)",0.08888888888888889,2,2,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
","0x0f33a2f6dc77be2134e1537bf919f7d9ef1d225d/MOT.sol:MOT:approve(address,uint256)",0x0f33a2f6dc77be2134e1537bf919f7d9ef1d225d/MOT.sol:MOT:onlyPayloadSize(uint256),0.5892857142857143,1,2,0
"    function oraclize_setNetwork() internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setNetwork(),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",1.0,5,5,1
"	function	getPI_edit_13	()	public	constant	returns	(	string	)	{
		return	inPI_edit_13	;						
	}									
","	function	setPI_edit_33	(	string	newPI_edit_33	)	public	onlyOwner	{	
		inPI_edit_33	=	newPI_edit_33	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_13(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_33(string),1.0,5,5,1
"  function burn(uint256 _value) unfreezed(msg.sender) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    totalSupply = totalSupply.sub(_value);
    emit Burn(msg.sender, _value);
    return true;
  }
","  function isFreezed(address _targetAddress) public constant returns (bool) {
    return frozen[_targetAddress]; 
  }
",0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:burn(uint256),0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:isFreezed(address),0.041666666666666664,1,2,0
"    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }
","    function Noblebit (uint256 _value, uint256 _minReq) public {
        owner = msg.sender;
        value = _value;
        minReq = _minReq;
        balances[msg.sender] = totalDistributed;
    }
",0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:finishDistribution(),"0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:Noblebit(uint256,uint256)",0.2727272727272727,2,2,0
" 	function transferFrom(address _from, address _to, uint256 _amount) notLocked(_from, _amount) returns (bool success)
		{
			if (piecesOwned[_from] >= _amount
				&& allowed[_from][msg.sender] >= _amount
				&& _amount > 0
				&& piecesOwned[_to] + _amount > piecesOwned[_to]
				&& _to != 0x0															// use burn() instead
				&& (_from != lowestAskAddress || piecesOwned[_from] > _amount))
					{
					piecesOwned[_from] -= _amount;
					allowed[_from][msg.sender] -= _amount;
					piecesOwned[_to] += _amount;
					Transfer(_from, _to, _amount);
					return true;
					} else {return false;}
		}
","	function transfer(address _to, uint256 _amount) notLocked(msg.sender, _amount) returns (bool success) {
		if (piecesOwned[msg.sender] >= _amount 
			&& _amount > 0
			&& piecesOwned[_to] + _amount > piecesOwned[_to]
			&& _to != 0x0)																// use burn() instead
			{
			piecesOwned[msg.sender] -= _amount;
			piecesOwned[_to] += _amount;
			Transfer(msg.sender, _to, _amount);
			return true;
			}
			else { return false;}
 		 }
","0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:transferFrom(address,address,uint256)","0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:transfer(address,uint256)",0.5,2,2,0
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x7f288ff5a8055f5f6103a80dd806cf8415e035c7/CFC.sol:Ownable:transferOwnership(address),0x7f288ff5a8055f5f6103a80dd806cf8415e035c7/CFC.sol:Ownable:onlyOwner(),0.9899874843554444,5,5,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
",0x6ed4c5e166cdf59a42b062eb87ad583ad33cfbee/AutoTrustToken.sol:StandardToken:balanceOf(address),"0x6ed4c5e166cdf59a42b062eb87ad583ad33cfbee/AutoTrustToken.sol:StandardToken:transferFrom(address,address,uint256)",0.3437815975733064,2,2,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x7b01b46d606ebfd30cc1581e513d97423ea63f10/AgesToken.sol:StandardToken:transfer(address,uint256)","0x7b01b46d606ebfd30cc1581e513d97423ea63f10/AgesToken.sol:StandardToken:approve(address,uint256)",0.9742268041237112,5,5,1
"   function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }
","    function isContract(address _addr) private returns (bool is_contract) {
      uint length;
      assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
      }
      return (length>0);
    }
",0x7a54fae94b6960d9f7316612eec179078e911769/MoviePass.sol:MoviePass:balanceOf(address),0x7a54fae94b6960d9f7316612eec179078e911769/MoviePass.sol:MoviePass:isContract(address),0.017189079878665317,2,2,0
"    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string,uint256)",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value)
    returns (bool success) {
	require(!frozenAccount[_from]);
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
","  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      emit Freeze ();
    }
  }
","0x5e80ff46592760b3e4668a1dea662839ca9e76ab/XERA.sol:XERA:transferFrom(address,address,uint256)",0x5e80ff46592760b3e4668a1dea662839ca9e76ab/XERA.sol:XERA:freezeTransfers(),0.95,5,5,1
"    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {
        uint minLength = length + toOffset;

        if (to.length < minLength) {
            // Buffer too small
            throw; // Should be a better way?
        }

        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
        uint i = 32 + fromOffset;
        uint j = 32 + toOffset;

        while (i < (32 + fromOffset + length)) {
            assembly {
                let tmp := mload(add(from, i))
                mstore(add(to, j), tmp)
            }
            i += 32;
            j += 32;
        }

        return to;
    }
","    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:copyBytes(bytes,uint256,uint256,bytes,uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:uint2str(uint256),1.0,5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x3c7005a33790edaa82faf1efb76d82f9cedf0b94/VirCoinToken.sol:SafeMath:div(uint256,uint256)","0x3c7005a33790edaa82faf1efb76d82f9cedf0b94/VirCoinToken.sol:SafeMath:mul(uint256,uint256)",0.99009900990099,5,5,1
"  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
","  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       throw;
     }
     _;
  }
",0x1d6df840fdA86a0044c2EF90B5a4bD413315a9c4/AlfaTowerShares.sol:SharesContract:balanceOf(address),0x1d6df840fdA86a0044c2EF90B5a4bD413315a9c4/AlfaTowerShares.sol:SharesContract:onlyPayloadSize(uint256),0.034412955465587036,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused returns (bool success) {
        require(_to != address(0));

        var _allowance = allowed[_from][msg.sender];

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) whenNotPaused returns (bool success) {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x0Ebb614204E47c09B6C3FeB9AAeCad8EE060E23E/CPAYToken.sol:CPAYToken:transferFrom(address,address,uint256)","0x0Ebb614204E47c09B6C3FeB9AAeCad8EE060E23E/CPAYToken.sol:CPAYToken:approve(address,uint256)",0.006097560975609756,2,2,0
"    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmin(x, y);
    }
","    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * WAD + y / 2) / y);
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:rmin(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:wdiv(uint128,uint128)",1.0,5,5,1
"  function burnFrom(address _from, uint256 _value)
    public whenNotPaused
  {
      require(_value <= allowed[_from][msg.sender]);
      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
      _burn(_from, _value);
  }
","  function approve(address _spender,uint256 _value)
    public
    whenNotPaused
    returns (bool)
  {
    return super.approve(_spender, _value);
  }
","0x6AfEDB250FDffdFa82C08DD119f53DEe63d04577/ICOTH.sol:PauseBurnableERC827Token:burnFrom(address,uint256)","0x6AfEDB250FDffdFa82C08DD119f53DEe63d04577/ICOTH.sol:PauseBurnableERC827Token:approve(address,uint256)",1.0,5,5,1
"	function mint(address _to, uint _value) onlyOwner {								
		assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);							
		balances[_to] += _value;							
		totalSupply += _value;							
	}								
","	function approve(address _spender, uint _value) returns (bool success) {								
		allowed[msg.sender][_spender] = _value;							
		Approval(msg.sender, _spender, _value);							
		return true;							
	}								
","0x0f1a5eb596742d2a9316c48c730bc79c48dab652/EN_Plus_VI.sol:EN_Plus_VI:mint(address,uint256)","0x0f1a5eb596742d2a9316c48c730bc79c48dab652/EN_Plus_VI.sol:EN_Plus_VI:approve(address,uint256)",1.0,5,5,1
"	function	setPOOL_edit_33	(	string	newPOOL_edit_33	)	public	onlyOwner	{	
		inPOOL_edit_33	=	newPOOL_edit_33	;					
	}									
","	function	setPOOL_edit_21	(	string	newPOOL_edit_21	)	public	onlyOwner	{	
		inPOOL_edit_21	=	newPOOL_edit_21	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_33(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_21(string),1.0,5,5,1
"    modifier registered{
        require(isRegistered[msg.sender]);
        _;
    }
","    function register() public {
        registerAccount(msg.sender);
    }
",0x0bccc88811ac345c7dcc5958cd5701120de44868/EPLAY.sol:EPLAY:registered(),0x0bccc88811ac345c7dcc5958cd5701120de44868/EPLAY.sol:EPLAY:register(),0.0,2,2,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        // mitigates the ERC20 short address attack
        if(msg.data.length < (2 * 32) + 4) { throw; }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) { throw; }

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","0x0b4ce72a70e87bee66e0f43e9c861366e9d7de19/Pisces_ZodiacToken.sol:Pisces_ZodiacToken:transfer(address,uint256)",0x0b4ce72a70e87bee66e0f43e9c861366e9d7de19/Pisces_ZodiacToken.sol:Pisces_ZodiacToken:withdrawForeignTokens(address),1.0,5,5,1
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[2],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string,uint256)",1.0,5,5,1
"  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }
","  function assert(bool assertion) internal {
    if (!assertion) {
      revert();
    }
  }
","0x1c7675d1224e5ff1ffe6eed18b7e8eece5d9e491/ZTRTokenSale.sol:SafeMath:sub(uint256,uint256)",0x1c7675d1224e5ff1ffe6eed18b7e8eece5d9e491/ZTRTokenSale.sol:SafeMath:assert(bool),0.01904761904761905,2,2,0
"    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }
","    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {
        uint minLength = length + toOffset;

        if (to.length < minLength) {
            // Buffer too small
            throw; // Should be a better way?
        }

        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
        uint i = 32 + fromOffset;
        uint j = 32 + toOffset;

        while (i < (32 + fromOffset + length)) {
            assembly {
                let tmp := mload(add(from, i))
                mstore(add(to, j), tmp)
            }
            i += 32;
            j += 32;
        }

        return to;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_getPrice(string,uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:copyBytes(bytes,uint256,uint256,bytes,uint256)",1.0,5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function DankCoin() {
    //419900000000
        balances[msg.sender] = 80000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 80000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = ""DankCoin"";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = ""DANK"";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 2105000;                                      // Set the price of your token for the ICO (CHANGE THIS)
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    }
","0x7ac2fd14cb9d5cfab29b482d67a43360e448390b/DankCoin.sol:DankCoin:approveAndCall(address,uint256,bytes)",0x7ac2fd14cb9d5cfab29b482d67a43360e448390b/DankCoin.sol:DankCoin:DankCoin(),0.2026359143327842,2,2,0
"  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
","0x02e3083a51e8632e571fbd6a62ac396c10c653ba/EplusCoinToken.sol:SafeMath:safeSub(uint256,uint256)","0x02e3083a51e8632e571fbd6a62ac396c10c653ba/EplusCoinToken.sol:SafeMath:safeAdd(uint256,uint256)",0.9145299145299144,5,5,1
"    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
",0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:transferOwnership(address),"0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:allowance(address,address)",0.1566265060240964,2,2,0
"  function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public payable returns (bool)
  {
    require(_to != address(this));

    super.transferFrom(_from, _to, _value);

    // solium-disable-next-line security/no-call-value
    require(_to.call.value(msg.value)(_data));
    return true;
  }
","  function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
    require(_spender != address(this));

    super.decreaseApproval(_spender, _subtractedValue);

    // solium-disable-next-line security/no-call-value
    require(_spender.call.value(msg.value)(_data));

    return true;
  }
","0x2a22e5cca00a3d63308fa39f29202eb1b39eef52/EDUToken.sol:ERC827Token:transferFromAndCall(address,address,uint256,bytes)","0x2a22e5cca00a3d63308fa39f29202eb1b39eef52/EDUToken.sol:ERC827Token:decreaseApprovalAndCall(address,uint256,bytes)",1.0,5,5,1
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[2],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",1.0,5,5,1
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
",0x7d172c6ab99be1cb8ccb135c95368799352a0e68/Cake.sol:Ownable:onlyOwner(),0x7d172c6ab99be1cb8ccb135c95368799352a0e68/Cake.sol:Ownable:transferOwnership(address),0.04125177809388336,2,2,0
"	function allowance(address _owner, address _spender) constant returns (uint remaining) {								
		return allowed[_owner][_spender];							
	}								
","	function mint(address _to, uint _value) onlyOwner {								
		assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);							
		balances[_to] += _value;							
		totalSupply += _value;							
	}								
","0x8b882c7a1cf7bae9d1226953b7bcf95f974c8359/EuroSibEnergo_CIP_VI_20181220.sol:EuroSibEnergo_CIP_VI_20181220:allowance(address,address)","0x8b882c7a1cf7bae9d1226953b7bcf95f974c8359/EuroSibEnergo_CIP_VI_20181220.sol:EuroSibEnergo_CIP_VI_20181220:mint(address,uint256)",0.011194029850746268,2,2,0
"    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","0x1f4DAa3F749aA4EaA6F94b2c49Bc640C630a916d/SeeToken.sol:SeeToken:setPrices(uint256,uint256)",0x1f4DAa3F749aA4EaA6F94b2c49Bc640C630a916d/SeeToken.sol:SeeToken:buy(),0.6595744680851063,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[2])",1.0,5,5,1
"    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {
        uint minLength = length + toOffset;

        if (to.length < minLength) {
            // Buffer too small
            throw; // Should be a better way?
        }

        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
        uint i = 32 + fromOffset;
        uint j = 32 + toOffset;

        while (i < (32 + fromOffset + length)) {
            assembly {
                let tmp := mload(add(from, i))
                mstore(add(to, j), tmp)
            }
            i += 32;
            j += 32;
        }

        return to;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:copyBytes(bytes,uint256,uint256,bytes,uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)",1.0,5,5,1
"	modifier afterDeadline{ 
	    require(now >= deadline); 
	    _; 
	}
","    function ReceiveBTC(address addr, uint value) public stopInEmergency beforeDeadline ICOactive onlyBy(BTCproxy){
        require(value >= MinimumInvestment());
        uint amount = amountToSend(value);
        if (amount==0){
            revert();
        }else{
            amountRaised += value;
            tokenReward.transfer(addr,amount);
            tokensSold = add(tokensSold,amount);
            ReceivedBTC(addr,value);
        }
    }
",0x6a04f1b8cd341232b59c8bc70a102c45f6b29b38/ICO.sol:ICO:afterDeadline(),"0x6a04f1b8cd341232b59c8bc70a102c45f6b29b38/ICO.sol:ICO:ReceiveBTC(address,uint256)",0.0,2,2,0
"	function	setPOOL_edit_27	(	string	newPOOL_edit_27	)	public	onlyOwner	{	
		inPOOL_edit_27	=	newPOOL_edit_27	;					
	}									
","	function	getPOOL_edit_20	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_20	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_27(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_20(),1.0,5,5,1
"    function approve (address _spender, uint256 _currentValue, uint256 _newValue)
    returns (bool success) {
      if (allowance (msg.sender, _spender) == _currentValue)
        return approve (_spender, _newValue);
      else return false;
    }
","    function setOwner (address _newOwner) {
      require (msg.sender == owner);

      owner = _newOwner;
    }
","0x2cbd64273066bc181c792eaacdc8e5e522ef94d7/VornoxCoinToken.sol:VornoxCoinToken:approve(address,uint256,uint256)",0x2cbd64273066bc181c792eaacdc8e5e522ef94d7/VornoxCoinToken.sol:VornoxCoinToken:setOwner(address),0.6363636363636364,2,2,0
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:transferFrom(address,address,uint256)",0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:onlyOwner(),0.8767123287671232,2,2,0
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x2b83d02bc05d224025c1244889e708a2dd0bad47/GLXToken.sol:Owned:onlyOwner(),0x2b83d02bc05d224025c1244889e708a2dd0bad47/GLXToken.sol:Owned:transferOwnership(address),0.2579421526789948,2,2,0
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x6e123e1bf584a6d6db0810c3d0a6087d654c760b/CLC.sol:TokenERC20:_transfer(address,address,uint256)","0x6e123e1bf584a6d6db0810c3d0a6087d654c760b/CLC.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8782383419689119,2,2,0
"    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,bytes[1])","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[3],uint256)",1.0,5,5,1
"    function changeOwner(address newOwner) internal onlyArtist returns (bool) {
        artist = newOwner;
    }
","    constructor() public {
        totalSupply_ = totalSupply;
        balances[artist] = totalSupply;
        emit Transfer(0x0, artist, totalSupply);
    }
",0x6dde70b51e39f2c2ca50cdb60264212eb2041c7a/Art.sol:Art:changeOwner(address),0x6dde70b51e39f2c2ca50cdb60264212eb2041c7a/Art.sol:Art:constructor(),1.0,4,4,1
"  function claimOwnership() onlyPendingOwner public {
    emit OwnershipTransferred(owner, pendingOwner);
    owner = pendingOwner;
    pendingOwner = address(0);
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    pendingOwner = newOwner;
  }
",0x1a1064ecd8ac2eb44df7d7db610872f49bb1a37a/ICO_Graphene.sol:Claimable:claimOwnership(),0x1a1064ecd8ac2eb44df7d7db610872f49bb1a37a/ICO_Graphene.sol:Claimable:transferOwnership(address),1.0,5,5,1
"    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }
","    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
",0x0b983fa1bcbdf24bdbfacb660faa76c586a16c64/Presale.sol:Presale:sendRefund(),0x0b983fa1bcbdf24bdbfacb660faa76c586a16c64/Presale.sol:Presale:noReentrancy(),0.6666666666666666,2,2,0
"	function protoLEXToken() public {
		balances[msg.sender] = totalSupply;
	}
","	function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
		if (balanceOf(msg.sender) < _value) revert();
		balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
		balances[_to] = safeAdd(balanceOf(_to), _value);
		Transfer(msg.sender, _to, _value, _data);
		return true;
	}
",0x2e208cf41b721c3cb4ac78cc05938619bdccc0d0/protoLEXToken.sol:protoLEXToken:protoLEXToken(),"0x2e208cf41b721c3cb4ac78cc05938619bdccc0d0/protoLEXToken.sol:protoLEXToken:transferToAddress(address,uint256,bytes)",0.045454545454545456,2,2,0
"    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
      uint256 c = a * b;
      assert(a == 0 || c / a == b);
      return c;
    }
","    function div(uint256 a, uint256 b) internal constant returns (uint256) {
      uint256 c = a / b;
      return c;
    }
","0x5ae4b6e5cce8d31bada5bf68416c72b0ce4537b5/EthereumKappa.sol:SafeMath:mul(uint256,uint256)","0x5ae4b6e5cce8d31bada5bf68416c72b0ce4537b5/EthereumKappa.sol:SafeMath:div(uint256,uint256)",0.8524590163934426,1,1,0
"    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[4],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,bytes[],uint256)",1.0,4,4,1
"  function approve (address _spender, uint256 _currentValue, uint256 _newValue)
    public returns (bool success) {
    if (allowance (msg.sender, _spender) == _currentValue)
      return approve (_spender, _newValue);
    else return false;
  }
","  function unfreezeTransfers () public {
    require (msg.sender == owner);

    if (frozen) {
      frozen = false;
      Unfreeze ();
    }
  }
","0x7b0c06043468469967dba22d1af33d77d44056c8/MorpheusToken.sol:MorpheusToken:approve(address,uint256,uint256)",0x7b0c06043468469967dba22d1af33d77d44056c8/MorpheusToken.sol:MorpheusToken:unfreezeTransfers(),0.4545454545454545,1,1,0
"  function increaseApproval(address _spender, uint _addedValue)onlyOwner public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue)onlyOwner public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0df147dfce2f5efdff648070d742bfdf3677b30c/StateofTaiwanToken.sol:StandardToken:increaseApproval(address,uint256)","0x0df147dfce2f5efdff648070d742bfdf3677b30c/StateofTaiwanToken.sol:StandardToken:decreaseApproval(address,uint256)",1.0,4,4,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x5fb9a342ac544ce400a7ef82ec26e731670276e9/BUXCOINMONEYCONTRACT.sol:BUXCOINMONEYCONTRACT:balanceOf(address),"0x5fb9a342ac544ce400a7ef82ec26e731670276e9/BUXCOINMONEYCONTRACT.sol:BUXCOINMONEYCONTRACT:approveAndCall(address,uint256,bytes)",0.921875,1,1,0
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x01d28329619796bae733e849696f80a764422700/BaseTokenSale.sol:SafeMath:sub(uint256,uint256)","0x01d28329619796bae733e849696f80a764422700/BaseTokenSale.sol:SafeMath:add(uint256,uint256)",0.9846765039727582,4,4,1
"    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2d51481469e34ac9fbc42c1990c1f6d0b1a9b65e/WanToken.sol:StandardToken:transferFrom(address,address,uint256)","0x2d51481469e34ac9fbc42c1990c1f6d0b1a9b65e/WanToken.sol:StandardToken:approve(address,uint256)",0.003508771929824561,1,1,0
"  function destroy(address[] tokens) onlyOwner public {

    // Transfer tokens to owner
    for (uint256 i = 0; i < tokens.length; i++) {
      ERC20Basic token = ERC20Basic(tokens[i]);
      uint256 balance = token.balanceOf(this);
      token.transfer(owner, balance);
    }

    // Transfer Eth to owner and terminate contract
    selfdestruct(owner);
  }
","  function TokenDestructible() public payable { }
",0x2c84c27f3b36900b0c599a57e358e9f7ab77f869/DemeterToken.sol:TokenDestructible:destroy(address[]),0x2c84c27f3b36900b0c599a57e358e9f7ab77f869/DemeterToken.sol:TokenDestructible:TokenDestructible(),1.0,4,4,1
"  function setAltDeposit(uint totalAltDeposits) public onlyOwner {
    altDeposits = totalAltDeposits;
  }
","  modifier isUnderHardCap() {
    require(multisigVault.balance + altDeposits <= hardcap);
    _;
  }
",0x007fa227d5d693f7f29e27b1fa028fd2051ed072/ExchangeRate.sol:MainSale:setAltDeposit(uint256),0x007fa227d5d693f7f29e27b1fa028fd2051ed072/ExchangeRate.sol:MainSale:isUnderHardCap(),0.5,1,1,0
"    function unhalt() onlyAdmin {
        halted = false;
    }
","    function buyWithBonus(address inviter) validSale payable {

        require( msg.sender != inviter );

        uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp));
        uint bonus = safeDiv(safeMul(tokens, rate), 100);

        fundAddress.buyRecipient.value(msg.value)(msg.sender); //send Ether to pre-sale contract address

        totalSupply = safeAdd(totalSupply, bonus*2);

        bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus);
        bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus);
        BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus);

    }
",0x3d34cc988d583dd2757acaa18a1e90cfab8b7b1d/MoldCoinBonus.sol:MoldCoinBonus:unhalt(),0x3d34cc988d583dd2757acaa18a1e90cfab8b7b1d/MoldCoinBonus.sol:MoldCoinBonus:buyWithBonus(address),0.0,1,1,0
"  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
","0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:add(uint256,uint256)",0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:assert(bool),0.29347826086956524,1,1,0
"    function sub(uint256 a, uint256 b) internal constant returns(uint256) {
        assert(b <= a);
        return a - b;
    }
","    function mul(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x08bbeaee46dd5628e1e3383cdc09dd38f89e58c6/Quantormass.sol:SafeMath:sub(uint256,uint256)","0x08bbeaee46dd5628e1e3383cdc09dd38f89e58c6/Quantormass.sol:SafeMath:mul(uint256,uint256)",0.7849035187287173,1,1,0
"		function	getData_26	()	public	constant	returns	(	string	)	{
			return	inData_26	;						
		}									
","		function	getData_4	()	public	constant	returns	(	string	)	{
			return	inData_4	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_26(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_4(),1.0,4,4,1
"    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
","    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
",0x5fa1ea99eb3acc1f9e84cf28fde6431b8fdc9dc0/UselessAirdroppedToken.sol:UselessAirdroppedToken:withdraw(),0x5fa1ea99eb3acc1f9e84cf28fde6431b8fdc9dc0/UselessAirdroppedToken.sol:UselessAirdroppedToken:burn(uint256),0.825,1,1,0
"    function Token(string _name, string _symbol, uint8 _decimals, uint _count) {
        name        = _name;
        symbol      = _symbol;
        decimals    = _decimals;
        totalSupply = _count;
        balances[msg.sender] = _count;
    }
","    function unapprove(address _spender)
    { allowances[msg.sender][_spender] = 0; }
","0x7a203102ac51e7202e500b51ab6041aabb9dbe63/CreatorCrowdfunding.sol:Token:Token(string,string,uint8,uint256)",0x7a203102ac51e7202e500b51ab6041aabb9dbe63/CreatorCrowdfunding.sol:Token:unapprove(address),1.0,4,4,1
"    function Owned() public {
        owner = msg.sender;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x1a5f86ec31b884def88f6c08168bfee2fd474139/BitCashPlatform.sol:Owned:Owned(),0x1a5f86ec31b884def88f6c08168bfee2fd474139/BitCashPlatform.sol:Owned:transferOwnership(address),0.7699530516431925,1,1,0
"    function setMinter(Data storage self, address minter) public {
        require(msg.sender == self.owner);
        require(self.mintable);
        MinterUpdated(self.minter, minter);
        self.minter = minter;
    }
","    function signedApproveHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {
        hash = keccak256(signedApproveSig, address(this), tokenOwner, spender, tokens, fee, nonce);
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:setMinter(BTTSLib:Data,address)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:signedApproveHash(BTTSLib:Data,address,address,uint256,uint256,uint256)",1.0,4,4,1
"    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {
        uint256 addTokens = getTotalAmountOfTokens(_weiAmount);
        if (addTokens > balances[owner]) {
            TokenLimitReached(tokenAllocated, addTokens);
            return 0;
        }
        return addTokens;
    }
","    function changeOwner(address _newOwner) onlyOwner public returns (bool){
        require(_newOwner != address(0));
        OwnerChanged(owner, _newOwner);
        owner = _newOwner;
        return true;
    }
",0x02b0cfdc2ce5775feb68be62a7df3bba56598817/EthereumAI.sol:EthereumAI:validPurchaseTokens(uint256),0x02b0cfdc2ce5775feb68be62a7df3bba56598817/EthereumAI.sol:EthereumAI:changeOwner(address),1.0,4,4,1
"    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to !=  address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }
","0x3e8446df3069527e5257fc7b9cf48bcae3754691/EdenToken.sol:EdenToken:_transfer(address,address,uint256)",0x3e8446df3069527e5257fc7b9cf48bcae3754691/EdenToken.sol:EdenToken:burn(uint256),0.3,1,1,0
"    function balanceOf(address addr) constant returns (uint balance) {
        return balances[addr];
    }
","    function distributeDividends() onlyOwner public noEth(){
        for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
        {
            var (key, value) = IterableMapping.iterate_get(data, i);
            uint tmp = balances[dividendAddress] / globalShares * value;
            balances[key] = balances[key].add(tmp);
            Dividends(dividendAddress, key, tmp);
        }
        balances[dividendAddress] = balances[dividendAddress].sub(balances[dividendAddress] / globalShares * globalShares);
    }
",0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:GlobalCoin:balanceOf(address),0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:GlobalCoin:distributeDividends(),0.14285714285714285,1,1,0
"    function name() public view returns (string) {
        return name_;
    }
","    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {
        require(_index < balanceOf(_owner));
        return ownedTokens[_owner][_index];
    }
",0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ETHero:name(),"0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ETHero:tokenOfOwnerByIndex(address,uint256)",0.1111111111111111,1,1,0
"	function	getPI_edit_28	()	public	constant	returns	(	string	)	{
		return	inPI_edit_28	;						
	}									
","	function	getPI_edit_4	()	public	constant	returns	(	string	)	{
		return	inPI_edit_4	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_28(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_4(),0.6666666666666666,1,1,0
"    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
","    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }
","0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:DSAuth:isAuthorized(address,bytes4)",0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:DSAuth:constructor(),0.4117647058823529,1,1,0
"    function balance() constant returns (uint256) {
        return getBalance(msg.sender);
    }
","    function transfer(address _to, uint256 _amount) returns (bool success) {
        initialize(msg.sender);

        if (balances[msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(msg.sender, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
",0x2edd21212d0adba1f7511e57c07435ad946da796/TokenFactoryAirdropCoin.sol:TokenFactoryAirdropCoin:balance(),"0x2edd21212d0adba1f7511e57c07435ad946da796/TokenFactoryAirdropCoin.sol:TokenFactoryAirdropCoin:transfer(address,uint256)",1.0,4,4,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function PJR(
        ) {
        balances[msg.sender] = 120000000000000000000000000;
        totalSupply = 120000000000000000000000000;
        name = ""PJR"";
        decimals = 18;
        symbol = ""PJR"";
    }
","0x2ec43c03e9b46e41d6463cbbb345d1dc48fa959c/PJR.sol:PJR:approveAndCall(address,uint256,bytes)",0x2ec43c03e9b46e41d6463cbbb345d1dc48fa959c/PJR.sol:PJR:PJR(),0.2174629324546952,1,1,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x0f33a2f6dc77be2134e1537bf919f7d9ef1d225d/MOT.sol:MOT:approve(address,uint256)",0x0f33a2f6dc77be2134e1537bf919f7d9ef1d225d/MOT.sol:MOT:onlyOwner(),0.5892857142857143,1,1,0
"    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
","    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
","0x4bc240a49a83885f2eeb5ba2693be9a560294290/EcomethToken.sol:EcomethToken:adminClaimAirdropMultiple(address[],uint256)","0x4bc240a49a83885f2eeb5ba2693be9a560294290/EcomethToken.sol:EcomethToken:distr(address,uint256)",1.0,4,4,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function LIFECOIN() public {
        symbol = ""LFC"";
        name = ""LIFECOIN Token"";
        decimals = 18;
        _totalSupply = 3000000000000000000000000000000;
        balances[0xD133cc957d41C0cd62ed6175155B2E54F951eA79] = _totalSupply;
        Transfer(address(0), 0xD133cc957d41C0cd62ed6175155B2E54F951eA79, _totalSupply);
    }
","0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa/LIFECOIN.sol:LIFECOIN:approve(address,uint256)",0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa/LIFECOIN.sol:LIFECOIN:LIFECOIN(),0.473015873015873,1,1,0
"	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}
","	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}
",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpContracts:getBdpImageStorage(address[16]),0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpContracts:getBdpControllerHelper(address[16]),1.0,4,4,1
"  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function div(uint a, uint b) internal returns (uint) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x6f7a4bac3315b5082f793161a22e26666d22717f/YeedToken.sol:SafeMath:mul(uint256,uint256)","0x6f7a4bac3315b5082f793161a22e26666d22717f/YeedToken.sol:SafeMath:div(uint256,uint256)",0.10557768924302788,1,1,0
"    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        // minimum contribution
        require( msg.value >= MIN_CONTRIBUTION );

        require( msg.value > 0 );

        // get baseline number of tokens
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
",0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:balanceOf(address),0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:getTokens(),0.05384615384615385,1,1,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }
","0x4d09c5e758ca68be27240f29fb681e5a5341ca98/Hotc.sol:StandardToken:allowance(address,address)","0x4d09c5e758ca68be27240f29fb681e5a5341ca98/Hotc.sol:StandardToken:transferFrom(address,address,uint256)",0.2891156462585034,1,1,0
"    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function TIMEDEX () public {
        owner = msg.sender;
        uint256 devTokens = 100000000e8;
        distr(owner, devTokens);
    }
",0x7f664f61dc14db9aec51c56426a8875553691c19/TIMEDEX.sol:TIMEDEX:getTokens(),0x7f664f61dc14db9aec51c56426a8875553691c19/TIMEDEX.sol:TIMEDEX:TIMEDEX(),0.047619047619047616,1,1,0
"    function getMyNormalDragons() public view returns(uint256) {
        return SafeMath.add(normalDragon[msg.sender], premiumDragons[msg.sender]);
    }
","    function sellEggs() public {
        require(initialized);
        uint256 hasEggs = getMyEggs();
        uint256 eggValue = calculateEggSell(hasEggs);
        uint256 fee = calculatePercentage(eggValue, 20);
        userReferralEggs[msg.sender] = 0;
        lastHatch[msg.sender]=now;
        marketEggs=SafeMath.add(marketEggs,hasEggs);
        ceoEtherBalance += fee;
        msg.sender.transfer(SafeMath.sub(eggValue,fee));
    }
",0x5bd2cecdc30656adc2ce23812dce369ccca3bbbd/EtherMorty.sol:EtherMorty:getMyNormalDragons(),0x5bd2cecdc30656adc2ce23812dce369ccca3bbbd/EtherMorty.sol:EtherMorty:sellEggs(),0.0,1,1,0
"	function setImageOwner(uint256 _imageId, address _owner) public {
		BdpImage.setImageOwner(contracts, _imageId, _owner);
	}
","	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageWidth(_imageId);
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:setImageOwner(uint256,address)",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageWidth(uint256),1.0,4,4,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x5db4792f5e76f8b3150e9c4f42825ace7eb08dd2/ESlotsToken.sol:SafeMath:mul(uint256,uint256)","0x5db4792f5e76f8b3150e9c4f42825ace7eb08dd2/ESlotsToken.sol:SafeMath:div(uint256,uint256)",0.6934189406099518,1,1,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x5c8e340c3e9124cf75d5b600f21af1320b42d4a2/LetItPlayTokenPromo.sol:StandardToken:decreaseApproval(address,uint256)","0x5c8e340c3e9124cf75d5b600f21af1320b42d4a2/LetItPlayTokenPromo.sol:StandardToken:approve(address,uint256)",0.8907363420427553,1,1,0
"		function	setCmd	(	uint256	newCmd	)	public	onlyOwner	{	
			Cmd	=	newCmd	;					
		}									
","		function	getDepositary_function_control	()	public	constant	returns	(	uint256	)	{
			return	Depositary_function_control	;						
		}									
",0x0e1bebe6b75595d3c7fb99550757e310bc2edf2a/LLV_v30_12.sol:LLV_v30_12:setCmd(uint256),0x0e1bebe6b75595d3c7fb99550757e310bc2edf2a/LLV_v30_12.sol:LLV_v30_12:getDepositary_function_control(),1.0,4,4,1
"    function _transfer(address _from, address _to, uint256 _tokenId) internal {
        ownerCardCount[_to]++;
        // transfer ownership
        cardToOwner[_tokenId] = _to;

        ownerCardCount[_from]--;
        // clear any previously approved ownership exchange
        
        delete cardApprovals[_tokenId];
       
        // Emit the transfer event.
        Transfer(_from, _to, _tokenId);
    }
","    function ownerOf(uint256 _tokenId)
        public
        view
        returns (address _owner)
    {
        return cardToOwner[_tokenId];
    }
","0x7cbfbe8b4872b2932446b90b7e3e03f6ae6e32da/Etherchicks.sol:CardOwnership:_transfer(address,address,uint256)",0x7cbfbe8b4872b2932446b90b7e3e03f6ae6e32da/Etherchicks.sol:CardOwnership:ownerOf(uint256),1.0,4,4,1
"  function withdrawToken(address token, uint amount) public {
    require(token != 0);
    require(tokens[token][msg.sender] >= amount);
    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);
    require(IToken(token).transfer(msg.sender, amount));
    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);
  }
","  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    if (!(
      (orders[user][hash] || ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", hash), v, r, s) == user) &&
      block.number <= expires
      )) {
      return 0;
    }
    uint[2] memory available;
    available[0] = amountGet.sub(orderFills[user][hash]);
    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;
    if (available[0] < available[1]) {
      return available[0];
    } else {
      return available[1];
    }
  }
","0x2f13fa06c0efd2a5c4cf2175a0467084672e648b/MarketPlace.sol:MarketPlace:withdrawToken(address,uint256)","0x2f13fa06c0efd2a5c4cf2175a0467084672e648b/MarketPlace.sol:MarketPlace:availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)",0.16666666666666666,1,1,0
"	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}
","	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}
",0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:getLastRegionId(),"0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:setRegionUrl(uint256,uint8[128])",0.6,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[4])",1.0,4,4,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function BOND() public {
        symbol = ""BND"";
        name = ""BOND"";
        decimals = 5;
        _totalSupply = 85000000000000;
        balances[0xED7d4bC3ea331A559b9c2036161DB2AD0933f638] = _totalSupply;
        Transfer(address(0), 0xED7d4bC3ea331A559b9c2036161DB2AD0933f638, _totalSupply);
    }
","0x4ee697e33d72bce48c2170bfc009d801933fcb10/BOND.sol:BOND:transfer(address,uint256)",0x4ee697e33d72bce48c2170bfc009d801933fcb10/BOND.sol:BOND:BOND(),0.3201581027667984,1,2,0
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
","0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:transfer(address,uint256)",0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:finishDistribution(),0.463768115942029,1,2,0
"    constructor() {
        totalSupply = 5000000; //5 MILLION TOKENS
        balanceOf[msg.sender] = totalSupply;
        name = ""TBC""; 
        symbol = ""TBC""; 
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
",0x1c66bb904ceaa80aa224193728d459b109115ec2/TBC.sol:TBC:constructor(),0x1c66bb904ceaa80aa224193728d459b109115ec2/TBC.sol:TBC:burn(uint256),1.0,4,4,1
"    function validPurchase() internal constant returns (bool) {
        uint256 current = block.number;

        bool withinPeriod = current >= startBlock && current <= endBlock;
        bool minPurchase = msg.value >= minContrib;

        // add total wei raised
        uint256 totalWeiRaised = weiRaised.add(msg.value);
        bool withinCap = totalWeiRaised <= totalEtherCap;

        // check all 3 conditions met
        return withinPeriod && minPurchase && withinCap;
    }
","    function setEndBlock(uint256 _endBlock) onlyOwner public {
        endBlock = _endBlock;
    }
",0x4C5651c4f59B3E92E67d993b7B969F9aF861380f/FaradTokenSwap.sol:FaradTokenSwap:validPurchase(),0x4C5651c4f59B3E92E67d993b7B969F9aF861380f/FaradTokenSwap.sol:FaradTokenSwap:setEndBlock(uint256),0.6666666666666666,1,2,0
"    function transfer(address _to, uint _value, bytes _data)
    onlyPayloadSize(2 * 32) 
    public
    returns (bool success) 
    {
        require(_to != address(0));
        if (balances[msg.sender] >= _value && _value > 0) {
            // Standard function transfer similar to ERC20 transfer with no _data .
            // Added due to backwards compatibility reasons .
            uint codeLength;

            assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
            }
            balances[msg.sender] = safeSub(balances[msg.sender], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            if(codeLength>0) {
                ContractReceiver receiver = ContractReceiver(_to);
                receiver.tokenFallback(msg.sender, _value, _data);
            }
            emit Transfer(msg.sender, _to, _value, _data);
            return true;
        }else{return false;}

    }
","    function transfer(address _to, uint _value) 
    onlyPayloadSize(2 * 32) 
    public
    returns (bool success)
    {
        require(_to != address(0));
        if (balances[msg.sender] >= _value && _value > 0) {
            uint codeLength;
            bytes memory empty;
            assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
            }

            balances[msg.sender] = safeSub(balances[msg.sender], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            if(codeLength>0) {
                ContractReceiver receiver = ContractReceiver(_to);
                receiver.tokenFallback(msg.sender, _value, empty);
            }
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }

    }
","0x7b7b239e7fc2b4680f5cf469ecb968bd94bb38aa/CoSoundToken.sol:StandardToken:transfer(address,uint256,bytes)","0x7b7b239e7fc2b4680f5cf469ecb968bd94bb38aa/CoSoundToken.sol:StandardToken:transfer(address,uint256)",1.0,4,4,1
"		function	retrait_1				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_1.transfer(User_1, Standard_1)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		function	setID_control	(	uint256	newID_control	)	public	onlyOwner	{	
			ID_control	=	newID_control	;					
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_1(),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setID_control(uint256),1.0,4,4,1
"  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }
","  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
","0x4b958074cee6546e29cdb3c43494e7425b85f59c/CareerChainPrivateSale.sol:Crowdsale:_processPurchase(address,uint256)",0x4b958074cee6546e29cdb3c43494e7425b85f59c/CareerChainPrivateSale.sol:Crowdsale:_forwardFunds(),0.972972972972973,4,4,1
"  function transfer(address _to, uint256 _value) rejectTokensToContract(_to) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }
","  function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }
","0x05c3617cbf1304b9260aa61ec960f115d67becea/CBIX.sol:CBIX:transfer(address,uint256)","0x05c3617cbf1304b9260aa61ec960f115d67becea/CBIX.sol:CBIX:increaseApproval(address,uint256)",1.0,4,4,1
"     function approve(address _spender, uint256 _amount) returns (bool success) {
         allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
         return true;
     }
","     modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x2fd41f516fac94ed08e156f489f56ca3a80b04d0/EBTC.sol:EBTC:approve(address,uint256)",0x2fd41f516fac94ed08e156f489f56ca3a80b04d0/EBTC.sol:EBTC:onlyOwner(),0.18181818181818185,1,1,0
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }
","0x3e7203ef349c04b8cb46ebbfcb8ec046d7196504/NZOCrowdsale.sol:SafeMath:mul(uint256,uint256)","0x3e7203ef349c04b8cb46ebbfcb8ec046d7196504/NZOCrowdsale.sol:SafeMath:max64(uint64,uint64)",0.026229508196721308,1,1,0
"    function transfer(address _to, uint _value)
    onlyPayloadSize(2)
    returns (bool success) {
       success = controller.transfer(msg.sender, _to, _value);
        if (success) {
            Transfer(msg.sender, _to, _value);
        }
    }
","    function setController(address _c) onlyOwner notFinalized {
        controller = Controller(_c);
    }
","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Token:transfer(address,uint256)",0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Token:setController(address),1.0,4,4,1
"	function	setPI_edit_25	(	string	newPI_edit_25	)	public	onlyOwner	{	
		inPI_edit_25	=	newPI_edit_25	;					
	}									
","	function	getPI_edit_24	()	public	constant	returns	(	string	)	{
		return	inPI_edit_24	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_25(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_24(),1.0,4,4,1
"  function sub(uint256 a, uint256 b) pure internal  returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) pure internal  returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4/TokenLock.sol:SafeMath:sub(uint256,uint256)","0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4/TokenLock.sol:SafeMath:mul(uint256,uint256)",0.7849035187287173,1,1,0
"	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) && _width > 0 && _height > 0 && _partsCount > 0 && _imageDescriptor > 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}
","	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:createImage(address,uint256,uint16,uint16,uint16,uint16)",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:getNextImageId(),1.0,4,4,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) external {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
",0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:onlyOwner(),"0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:adminClaimAirdropMultiple(address[],uint256)",0.0004741583688952111,1,1,0
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
","      function afterCrowdSale() public onlyOwner {
        require( hasEnded() && !isSoleout());
        balanceOf[owner] = balanceOf[owner] + CROWD_SUPPLY - currentSupply;
        currentSupply = CROWD_SUPPLY;
      }
","0x4beea326249b0d9866c3d4d6559bcad2cd979372/SLPC_ERC20Token.sol:SLPC_ERC20Token:burnFrom(address,uint256)",0x4beea326249b0d9866c3d4d6559bcad2cd979372/SLPC_ERC20Token.sol:SLPC_ERC20Token:afterCrowdSale(),0.0026109660574412533,1,1,0
"    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x6cfba3c7b4c944bdc9442c91d67d35d7c27fa430/OrphanToken.sol:SafeMath:max64(uint64,uint64)","0x6cfba3c7b4c944bdc9442c91d67d35d7c27fa430/OrphanToken.sol:SafeMath:mul(uint256,uint256)",0.2702702702702703,1,1,0
"  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:mul(uint256,uint256)","0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:max256(uint256,uint256)",0.18326693227091634,1,1,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
",0x7d3d1185ac96a0e5b5260511a73a9e1695d7eae7/HabibiCrowdsale.sol:BasicToken:totalSupply(),0x7d3d1185ac96a0e5b5260511a73a9e1695d7eae7/HabibiCrowdsale.sol:BasicToken:balanceOf(address),0.44639376218323584,1,1,0
"    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);  
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true; }
","0x6fa8b7532cae4e8feedadfb4a757a43ae5243165/BING.sol:BING:_transfer(address,address,uint256)","0x6fa8b7532cae4e8feedadfb4a757a43ae5243165/BING.sol:BING:transferFrom(address,address,uint256)",0.9430051813471504,4,4,1
"  function Ownable() public {
    owner = msg.sender;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x3b1D8701397AB3Cf86F10B0ef03854cFa06a2FA3/CxNcontract.sol:Ownable:Ownable(),0x3b1D8701397AB3Cf86F10B0ef03854cFa06a2FA3/CxNcontract.sol:Ownable:onlyOwner(),0.9294003868471954,4,4,1
"	function	getPOOL_edit_34	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_34	;						
	}									
","	function	setPOOL_edit_22	(	string	newPOOL_edit_22	)	public	onlyOwner	{	
		inPOOL_edit_22	=	newPOOL_edit_22	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_34(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_22(string),1.0,4,4,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function ColaToken() {
        balances[msg.sender] = 6000000000000000;
        _totalSupply = 6000000000000000;
        name = 'Colacoin';
        symbol = 'COLA';
        decimals = 8;
        owner = msg.sender;
    }
",0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:balanceOf(address),0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:ColaToken(),0.0005055611729019212,1,1,0
"    function setCLIForGas(uint newCLIAmount) onlyOwner public {
        CLIForGas = newCLIAmount;
    }
","     modifier canMint() {
    if(mintingFinished) revert();
    _;
  }
",0x5e441B5C140034B179E2FabC96F1a29e14dBc47A/ClimateCoinToken.sol:ClimateCoinToken:setCLIForGas(uint256),0x5e441B5C140034B179E2FabC96F1a29e14dBc47A/ClimateCoinToken.sol:ClimateCoinToken:canMint(),0.0,1,1,0
"    function approve(address _spender, uint256 _value) isRunning validAddress public returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    function stop() ownerOnly public {
        stopped = true;
    }
","0x3aca71c508e06dc6b2758dab6eb20f7654572fb7/DrepToken.sol:DrepToken:approve(address,uint256)",0x3aca71c508e06dc6b2758dab6eb20f7654572fb7/DrepToken.sol:DrepToken:stop(),0.0,1,1,0
"    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
","    constructor() public {
        owner = msg.sender;
    }
",0x7e04a8c9b52f3698b3d4f660254b06ff904b48ae/UZEEToken.sol:Common:_transferOwnership(address),0x7e04a8c9b52f3698b3d4f660254b06ff904b48ae/UZEEToken.sol:Common:constructor(),1.0,4,4,1
"    function burn(uint256 _value) public returns(bool) {
        require(balances[msg.sender] >= _value);   // Check if the sender has enough
        balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender
        totalSupply = totalSupply.sub(_value);                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool) {
        if (approve(_spender, _value)) {
            TokenRecipient spender = TokenRecipient(_spender);
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        return false;
    }
",0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:burn(uint256),"0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.26666666666666666,2,2,0
"    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
","0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:doAirdrop(address,uint256)",0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:updateTokensPerEth(uint256),1.0,5,5,1
"    function SGD_Omnidollar() public {
        symbol = ""SGDO"";
        name = ""SGD_Omnidollar"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000;
        balances[0x6d8d30e6c418E322Fb20b9F01115858cDF1e979E] = _totalSupply;
        Transfer(address(0), 0x6d8d30e6c418E322Fb20b9F01115858cDF1e979E, _totalSupply);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x6fffcf5405ad1be9a73dae9b8706f655df50908b/SGD_Omnidollar.sol:SGD_Omnidollar:SGD_Omnidollar(),"0x6fffcf5405ad1be9a73dae9b8706f655df50908b/SGD_Omnidollar.sol:SGD_Omnidollar:allowance(address,address)",1.0,5,5,1
"	function getUsers() view public returns(address[]){
	return userAccounts;
	}
","	function transfer(address _to, uint256 _value) onlyOwner returns (bool success) {
        require (_to != 0x0);
        require (users[owner].balance >= _value);
        if (users[owner].balance >= _value && _value > 0) {
            if(totalSupply <= reserve){
                users[owner].balance += totalSupply;
                return false;
            }
            
            users[owner].balance -= _value;
            users[_to].balance += _value;
            totalSupply -= _value;
            Transfer(owner, _to, _value);
            return true;
        } else { return false; }
    }
",0x6dfd861fb01a99197fbeb01609c2c362f349b525/LumenCoin.sol:LumenCoin:getUsers(),"0x6dfd861fb01a99197fbeb01609c2c362f349b525/LumenCoin.sol:LumenCoin:transfer(address,uint256)",1.0,5,5,1
"    function parseInt(string _a) internal pure returns (uint) {
        return parseInt(_a, 0);
    }
","    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {
        uint minLength = length + toOffset;

        // Buffer too small
        require(to.length >= minLength); // Should be a better way?

        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
        uint i = 32 + fromOffset;
        uint j = 32 + toOffset;

        while (i < (32 + fromOffset + length)) {
            assembly {
                let tmp := mload(add(from, i))
                mstore(add(to, j), tmp)
            }
            i += 32;
            j += 32;
        }

        return to;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseInt(string),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:copyBytes(bytes,uint256,uint256,bytes,uint256)",0.8,1,1,0
"    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;

        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);

        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);

        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = byte(1); //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);

        if (sigok == false) return false;


        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";

        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);

        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);

        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);

        return sigok;
    }
","    function strCompare(string _a, string _b) internal pure returns (int) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        uint minLength = a.length;
        if (b.length < minLength) minLength = b.length;
        for (uint i = 0; i < minLength; i ++)
            if (a[i] < b[i])
                return -1;
            else if (a[i] > b[i])
                return 1;
        if (a.length < b.length)
            return -1;
        else if (a.length > b.length)
            return 1;
        else
            return 0;
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:strCompare(string,string)",1.0,5,5,1
"    function getEggsSinceLastHatch(address adr) public view returns(uint256){
        uint256 secondsPassed=min(EGGS_TO_HATCH_1SHRIMP,SafeMath.sub(now,lastHatch[adr]));
        return SafeMath.mul(secondsPassed,hatcheryShrimp[adr]);
    }
","    function seedMarket(uint256 eggs) public payable{
        require(marketEggs==0);
        initialized=true;
        marketEggs=eggs;
    }
",0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:getEggsSinceLastHatch(address),0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:seedMarket(uint256),0.6875,1,1,0
"    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
","    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        return super.approve(_spender, _value);
    }
","0x1Db10d198C2D66A8767e7aDde7FA5E5Bf2D57604/CrowdsalePhase1.sol:PausableToken:decreaseApproval(address,uint256)","0x1Db10d198C2D66A8767e7aDde7FA5E5Bf2D57604/CrowdsalePhase1.sol:PausableToken:approve(address,uint256)",1.0,5,5,1
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x1a018ff6042863614e0e88cd615412588fd0a2da/CTCToken.sol:StandardToken:approve(address,uint256)","0x1a018ff6042863614e0e88cd615412588fd0a2da/CTCToken.sol:StandardToken:transferFrom(address,address,uint256)",0.36178207192699946,1,1,0
"    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + RAY / 2) / RAY);
    }
","    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {
        // This famous algorithm is called ""exponentiation by squaring""
        // and calculates x^n with x as fixed-point and n as regular unsigned.
        //
        // It's O(log n), instead of O(n) for naive repeated multiplication.
        //
        // These facts are why it works:
        //
        //  If n is even, then x^n = (x^2)^(n/2).
        //  If n is odd,  then x^n = x * x^(n-1),
        //   and applying the equation for even x gives
        //    x^n = x * (x^2)^((n-1) / 2).
        //
        //  Also, EVM division is flooring and
        //    floor[(n-1) / 2] = floor[n / 2].

        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:rmul(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:rpow(uint128,uint64)",0.6666666666666666,1,1,0
"  function addToken(address _to, uint256 _tokenId) private {
    require(tokenOwner[_tokenId] == address(0));
    tokenOwner[_tokenId] = _to;
    uint256 length = balanceOf(_to);
    ownedTokens[_to].push(_tokenId);
    ownedTokensIndex[_tokenId] = length;
    totalTokens = totalTokens.add(1);
  }
","  function approvedFor(uint256 _tokenId) public view returns (address) {
    return tokenApprovals[_tokenId];
  }
","0x7a1503bc08d49c122a4681d2df9a915dce6066c3/HarmToken.sol:ERC721Token:addToken(address,uint256)",0x7a1503bc08d49c122a4681d2df9a915dce6066c3/HarmToken.sol:ERC721Token:approvedFor(uint256),1.0,5,5,1
"    function transfer(address _to, uint _value, bytes _data) {
        // Standard function transfer similar to ERC20 transfer with no _data .
        // Added due to backwards compatibility reasons .
        uint codeLength;

        assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        Transfer(msg.sender, _to, _value, _data);
    }
","    function balanceOf(address _owner) constant returns (uint balance) {
        return balances[_owner];
    }
","0x1a85180ce3012e7715b913dd585afdf1a10f3025/PajCoin223.sol:ERC223Token:transfer(address,uint256,bytes)",0x1a85180ce3012e7715b913dd585afdf1a10f3025/PajCoin223.sol:ERC223Token:balanceOf(address),0.6666666666666666,1,1,0
"  function burn(uint256 _value) public returns (bool success) 
      {
          require (balanceOf[msg.sender] > _value);                             // Check if the sender has enough
          balanceOf[msg.sender] -= _value;                                      // Subtract from the sender
          totalSupply -= _value;                                                // Updates totalSupply
          Burn(msg.sender, _value);
          return true;
      }
","  function approve(address _spender, uint256 _value) public returns (bool success) 
      {
          allowance[msg.sender][_spender] = _value;
          return true;
      }
",0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:burn(uint256),"0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:approve(address,uint256)",0.9323671497584541,1,1,0
"    function getBalance(address _a) internal constant returns(uint256)
    {
        if( currentTotalSupply < totalSupply ){
            if( touched[_a] )
                return balances[_a];
            else
                return balances[_a].add( startBalance );
        } else {
            return balances[_a];
        }
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return getBalance( _owner );
    }
",0x5d0fa08aeb173ade44b0cf7f31d506d8e04f0ac8/DAPPToken.sol:DAPPToken:getBalance(address),0x5d0fa08aeb173ade44b0cf7f31d506d8e04f0ac8/DAPPToken.sol:DAPPToken:balanceOf(address),1.0,5,5,1
"    function seedMarket(uint256 eggs) public payable {
        require(marketEggs == 0);
        initialized = true;
        marketEggs = eggs;
    }
","    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }
",0x6c4ca515f04722d079862a03dec1e5c011491e12/ToadFarmer.sol:ToadFarmer:seedMarket(uint256),0x6c4ca515f04722d079862a03dec1e5c011491e12/ToadFarmer.sol:ToadFarmer:getBalance(),0.18181818181818185,1,1,0
"    function join(slice self, slice[] parts) internal returns (string) {
        if (parts.length == 0)
            return """";

        uint length = self._len * (parts.length - 1);
        for(uint i = 0; i < parts.length; i++)
            length += parts[i]._len;

        var ret = new string(length);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        for(i = 0; i < parts.length; i++) {
            memcpy(retptr, parts[i]._ptr, parts[i]._len);
            retptr += parts[i]._len;
            if (i < parts.length - 1) {
                memcpy(retptr, self._ptr, self._len);
                retptr += self._len;
            }
        }

        return ret;
    }
","    function rsplit(slice self, slice needle, slice token) internal returns (slice) {
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);
        token._ptr = ptr;
        token._len = self._len - (ptr - self._ptr);
        if (ptr == self._ptr) {
            // Not found
            self._len = 0;
        } else {
            self._len -= token._len + needle._len;
        }
        return token;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:join(strings:slice,strings:slice[])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:rsplit(strings:slice,strings:slice,strings:slice)",1.0,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc/PEPEso.sol:PEPEso:allowance(address,address)",0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc/PEPEso.sol:PEPEso:totalSupply(),0.8297872340425532,1,1,0
"  function tokensToWei(uint256 _tokenAmount) public view returns (uint256) {
    require(tokenNAVMicroUSD != uint256(0));
    require(weiPerUSD != uint256(0));
    return _tokenAmount.mul(tokenNAVMicroUSD).mul(weiPerUSD).div(million);
  }
","  function addToWhitelist(address _beneficiary) public onlyBy(kycAdmin) {
    whitelist[_beneficiary] = true;
    emit AddToWhitelist(_beneficiary);
  }
",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:tokensToWei(uint256),0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:addToWhitelist(address),1.0,5,5,1
"	function	getData_8	()	public	constant	returns	(	string	)	{
		return	inData_8	;						
	}									
","	function	setData_5	(	string	newData_5	)	public	onlyOwner	{	
		inData_5	=	newData_5	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_8(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_5(string),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

         if (balances[_from] >= _amount
             && allowed[_from][msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
            return false;
         }
    }
","    function distributeTKLN(address[] addresses, uint256 _value) onlyOwner canDistr public {
         for (uint i = 0; i < addresses.length; i++) {
             balances[owner] -= _value;
             balances[addresses[i]] += _value;
             emit Transfer(owner, addresses[i], _value);
         }
    }
","0x0f43e50aa2ec14296a33f68d0c8c605b3acc08dc/TAKLIMAKAN.sol:TAKLIMAKAN:transferFrom(address,address,uint256)","0x0f43e50aa2ec14296a33f68d0c8c605b3acc08dc/TAKLIMAKAN.sol:TAKLIMAKAN:distributeTKLN(address[],uint256)",0.061538461538461535,1,1,0
"    function MyJioCoin() public {
        symbol = ""MYJIO"";
        name = ""MyJioCoin"";
        decimals = 8;
        _totalSupply = 1000000000 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
",0x7fab901ef74f95327d36640c02fafeb6d4cb4be7/MyJioCoin.sol:MyJioCoin:MyJioCoin(),"0x7fab901ef74f95327d36640c02fafeb6d4cb4be7/MyJioCoin.sol:MyJioCoin:transfer(address,uint256)",0.9393939393939394,1,1,0
"	function transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) 
		{
			Interface c = Interface(_contract);
			c.transfer(_to, _amount);
		}
","	function offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)
		{
			Interface c = Interface(_contract);
			c.offerPieceForSale(_price);
		}
","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:transferByAddress(address,uint256,address)","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:offerPieceForSaleByAddress(address,uint256)",1.0,5,5,1
"    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
","0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:adminClaimAirdrop(address,uint256)",0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:updateTokensPerEth(uint256),1.0,5,5,1
"	function	getCmd	()	public	constant	returns	(	uint256	)	{
		return	Cmd	;						
	}									
","	function	retrait_2				()	public	{		
		require(	msg.sender == User_2			);				
		require(	Securities_2.transfer(User_1, Standard_2)			);				
		require(	ID == ID_control			);				
		require(	Cmd == Cmd_control			);				
		require(	Depositary_function == Depositary_function_control			);				
	}									
",0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:getCmd(),0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:retrait_2(),1.0,5,5,1
"    function airdrop(address[] _addrs, uint256[] _values) public returns (bool success) {
        return _transferMultiple(msg.sender, _addrs, _values);
    }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x4b30d120fca686ba384a275064548446dfd8c850/STBToken.sol:STBToken:airdrop(address[],uint256[])","0x4b30d120fca686ba384a275064548446dfd8c850/STBToken.sol:STBToken:allowance(address,address)",1.0,5,5,1
"    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(amount <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
","0x2cc40acbdd5c20273a0567b260b820aa21102291/Pheonix.sol:Pheonix:distribution(address[],uint256)",0x2cc40acbdd5c20273a0567b260b820aa21102291/Pheonix.sol:Pheonix:burn(uint256),1.0,5,5,1
"	function increaseApproval(address spender, uint256 value) public returns (bool) {
		allowed[msg.sender][spender] = allowed[msg.sender][spender].add(value);
		emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
		return true;
	}
","	function transfer(address to, uint256 value) public returns (bool) {
		internalTransfer(msg.sender, to, value);
		emit Transfer(msg.sender, to, value);
		return true;
	}
","0x1fc3f8470470ed4436ac0692bbffc69b28d24fd5/GangnamToken.sol:GangnamToken:increaseApproval(address,uint256)","0x1fc3f8470470ed4436ac0692bbffc69b28d24fd5/GangnamToken.sol:GangnamToken:transfer(address,uint256)",0.0,1,1,0
"    function ecrecoverFromSig(bytes32 hash, bytes sig) public pure returns (address recoveredAddress) {
        bytes32 r;
        bytes32 s;
        uint8 v;
        if (sig.length != 65) return address(0);
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))
        }
        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]
        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27) {
          v += 27;
        }
        if (v != 27 && v != 28) return address(0);
        return ecrecover(hash, v, r, s);
    }
","    function acceptOwnership(Data storage self) public {
        require(msg.sender == self.newOwner);
        OwnershipTransferred(self.owner, self.newOwner);
        self.owner = self.newOwner;
        self.newOwner = address(0);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:ecrecoverFromSig(bytes32,bytes)",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:acceptOwnership(BTTSLib:Data),0.1111111111111111,1,1,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x5e900fa9fe49120c091e571a09c79fd17f630524/POMATOKEN.sol:StandardToken:allowance(address,address)",0x5e900fa9fe49120c091e571a09c79fd17f630524/POMATOKEN.sol:StandardToken:balanceOf(address),0.4974489795918368,1,1,0
"    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[3],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[])",1.0,5,5,1
"    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint decimalUnits
    ) public {
        owner = msg.sender;
        name = tokenName;
        symbol = tokenSymbol; 
        decimals = decimalUnits;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5/HeavenlyHoundCoin.sol:HeavenlyHoundCoin:constructor(uint256,string,string,uint256)","0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5/HeavenlyHoundCoin.sol:HeavenlyHoundCoin:approve(address,uint256)",0.7647058823529411,1,1,0
"    function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {
        require( _recipients.length > 0 && _recipients.length == _values.length);

        uint total = 0;
        for(uint i = 0; i < _values.length; i++){
            total = total.add(_values[i]);
        }
        require(total <= balances[msg.sender]);

        uint64 _now = uint64(now);
        for(uint j = 0; j < _recipients.length; j++){
            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);
            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));
            Transfer(msg.sender, _recipients[j], _values[j]);
        }

        balances[msg.sender] = balances[msg.sender].sub(total);
        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));

        return true;
    }
","    function annualInterest() constant returns(uint interest) {
        uint _now = now;
        interest = maxMintProofOfStake;
        if((_now.sub(stakeStartTime)).div(1 years) == 0) {
            interest = (770 * maxMintProofOfStake).div(100);
        } else if((_now.sub(stakeStartTime)).div(1 years) == 1){
            interest = (435 * maxMintProofOfStake).div(100);
        }
    }
","0x7aeace15f7d9a8e0ae3a1418d8360c6f41927552/ZNCoin.sol:ZNCoin:batchTransfer(address[],uint256[])",0x7aeace15f7d9a8e0ae3a1418d8360c6f41927552/ZNCoin.sol:ZNCoin:annualInterest(),0.6875,1,1,0
"	function	setPOOL_edit_23	(	string	newPOOL_edit_23	)	public	onlyOwner	{	
		inPOOL_edit_23	=	newPOOL_edit_23	;					
	}									
","	function	getPOOL_edit_9	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_9	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_23(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_9(),1.0,5,5,1
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
",0x6e40178330c43081c5a8815ed40e9e36b0089495/Hubcoin.sol:Ownable:onlyOwner(),0x6e40178330c43081c5a8815ed40e9e36b0089495/Hubcoin.sol:Ownable:transferOwnership(address),0.15979137031768612,1,1,0
"    modifier withPerm(bytes32 _perm) {
        bool isOwner = msg.sender == ISecurityToken(securityToken).owner();
        bool isFactory = msg.sender == factory;
        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), ""Permission check failed"");
        _;
    }
","    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {
        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), ""Unable to take fee"");
        return true;
    }
",0x0da7ed8789348ac40937cf6ae8ff521eee43816c/EtherDividendCheckpointFactory.sol:IModule:withPerm(bytes32),0x0da7ed8789348ac40937cf6ae8ff521eee43816c/EtherDividendCheckpointFactory.sol:IModule:takeFee(uint256),1.0,5,5,1
"    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
        return oraclize.setCustomGasPrice(gasPrice);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setCustomGasPrice(uint256),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[2])",1.0,5,5,1
"	function	getPOOL_edit_33	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_33	;						
	}									
","	function	getPOOL_edit_3	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_3	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_33(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_3(),0.6666666666666666,1,1,0
"    function withdrawFunds(address _token) public returns (bool success) {
        require(msg.sender == owner);
        if (_token == address(0)) {
            owner.transfer(this.balance);
        }
        else {
            Token ERC20 = Token(_token);
            ERC20.transfer(owner, ERC20.balanceOf(this));
        }
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0);
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        Transfer(_from, _to, _amount);
        return true;
    }
",0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a/RocketCoin.sol:RocketCoin:withdrawFunds(address),"0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a/RocketCoin.sol:RocketCoin:transferFrom(address,address,uint256)",0.0,1,1,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x0ff7ae69784f1e25f10d7f086502a0b3ad803927/bitcoinforceToken.sol:bitcoinforceToken:burn(uint256),"0x0ff7ae69784f1e25f10d7f086502a0b3ad803927/bitcoinforceToken.sol:bitcoinforceToken:approveAndCall(address,uint256,bytes)",0.8849765258215962,1,1,0
"  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6f2057f83c05378f22a15b72a424367cb40abc1b/TokenCSR.sol:StandardToken:decreaseApproval(address,uint256)","0x6f2057f83c05378f22a15b72a424367cb40abc1b/TokenCSR.sol:StandardToken:approve(address,uint256)",0.8907363420427553,1,1,0
"	function transfer(address _to, uint256 _value)
		when_owns(msg.sender, _value)
		when_liquid
		returns (bool)
	{
		Transfer(msg.sender, _to, _value);
		accounts[msg.sender].balance -= _value;
		accounts[_to].balance += _value;

		return true;
	}
","	function balanceOf(address _who) constant returns (uint256) {
		return accounts[_who].balance;
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:transfer(address,uint256)",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:balanceOf(address),1.0,5,5,1
"	function	getData_10	()	public	constant	returns	(	string	)	{
		return	inData_10	;						
	}									
","	function	setData_21	(	string	newData_21	)	public	onlyOwner	{	
		inData_21	=	newData_21	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_10(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_21(string),1.0,5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","0x7a60dc5bab99ae642600e1db97e3c775fa3544c6/FDSToken.sol:BasicToken:transfer(address,uint256)",0x7a60dc5bab99ae642600e1db97e3c775fa3544c6/FDSToken.sol:BasicToken:totalSupply(),0.6110325318246109,1,1,0
"    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x + y) >= x);
    }
","    function radd(uint128 x, uint128 y) constant internal returns (uint128) {
        return hadd(x, y);
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:hadd(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:radd(uint128,uint128)",1.0,5,5,1
"  function owned() {
    owner = msg.sender;
  }
","  function transferOwnership(address newOwner) onlyOwner {
    owner = newOwner;
  }
",0x3ac96bbe8b60d715fd818b3fe242edf9def20571/MyBoToken.sol:owned:owned(),0x3ac96bbe8b60d715fd818b3fe242edf9def20571/MyBoToken.sol:owned:transferOwnership(address),0.7576687116564417,1,1,0
"    function getDeposited(address _investor) public view returns (uint256){
        return deposited[_investor];
    }
","    function finalize() public onlyOwner inState(State.Active) returns (bool result) {
        result = false;
        state = State.Closed;
        wallet.transfer(this.balance);
        finishMinting();
        Finalized();
        result = true;
    }
",0x08ae1da2daba9555061771e27aa6cc83a38f929c/ASTCrowdsale.sol:ASTCrowdsale:getDeposited(address),0x08ae1da2daba9555061771e27aa6cc83a38f929c/ASTCrowdsale.sol:ASTCrowdsale:finalize(),0.25,1,1,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
",0x3afa1902b1f8a802abc18e5ad982d1bcd34afe22/GSToken.sol:BasicToken:totalSupply(),"0x3afa1902b1f8a802abc18e5ad982d1bcd34afe22/GSToken.sol:BasicToken:transfer(address,uint256)",0.8421052631578947,1,1,0
"    function buyEggs() public payable{
        require(initialized);
        uint256 eggsBought=calculateEggBuy(msg.value,SafeMath.sub(this.balance,msg.value));
        eggsBought=SafeMath.sub(eggsBought,devFee(eggsBought));
        ceoAddress.transfer(devFee(msg.value));
        claimedEggs[msg.sender]=SafeMath.add(claimedEggs[msg.sender],eggsBought);
    }
","    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public view returns(uint256){
        //(PSN*bs)/(PSNH+((PSN*rs+PSNH*rt)/rt));
        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));
    }
",0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:buyEggs(),"0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:calculateTrade(uint256,uint256,uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
","0x0d1c63e12fde9e5cada3e272576183aba9cfeda2/ZenswapNetworkToken.sol:ZenswapNetworkToken:approve(address,uint256)","0x0d1c63e12fde9e5cada3e272576183aba9cfeda2/ZenswapNetworkToken.sol:ZenswapNetworkToken:burnFrom(address,uint256)",0.7441860465116279,1,1,0
"    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[4])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x7dd7f56d697cc0f2b52bd55c057f378f1fe6ab4b/STEAK.sol:StandardToken:transferFrom(address,address,uint256)","0x7dd7f56d697cc0f2b52bd55c057f378f1fe6ab4b/STEAK.sol:StandardToken:increaseApproval(address,uint256)",0.8315363881401617,1,1,0
"    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_cbAddress(),0.8,1,1,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
	}
","    function MDPToken(
        ) {
        totalSupply = 6600000000000000;                        // Update total supply (100000 for example)
        balances[msg.sender] = totalSupply;                    // Give the creator all initial tokens (100000 for example)
		name = ""MDP Token"";                                   // Set the name for display purposes
        decimals = 7;                            // Amount of decimals for display purposes
        symbol = ""MDP"";                               // Set the symbol for display purposes
    }
","0x3cfc5c7fa8db91de8efd633998097f8e96eff043/MDPToken.sol:MDPToken:approveAndCall(address,uint256,bytes)",0x3cfc5c7fa8db91de8efd633998097f8e96eff043/MDPToken.sol:MDPToken:MDPToken(),0.0016474464579901151,1,1,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
",0x2adb36d2ff04d5afa12d8334ffc9a367852906b9/BitcoinSinhalaToken.sol:BitcoinSinhalaToken:totalSupply(),"0x2adb36d2ff04d5afa12d8334ffc9a367852906b9/BitcoinSinhalaToken.sol:BitcoinSinhalaToken:transferFrom(address,address,uint256)",0.8175182481751825,1,2,0
"	function	getPOOL_edit_6	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_6	;						
	}									
","	function	setPOOL_edit_6	(	string	newPOOL_edit_6	)	public	onlyOwner	{	
		inPOOL_edit_6	=	newPOOL_edit_6	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_6(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_6(string),1.0,5,5,1
"    function transfer(address _to, uint256 _value) public returns(bool) {
        return _transfer(msg.sender, _to, _value);
    }
","    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowances[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowances[msg.sender][_spender] = 0;
        } else {
            allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);
        return true;
    }
","0x5c30b130f9c0d52a22fa447209afedbbc9d4788f/RRRR_Token.sol:TokenERC20:transfer(address,uint256)","0x5c30b130f9c0d52a22fa447209afedbbc9d4788f/RRRR_Token.sol:TokenERC20:decreaseApproval(address,uint256)",0.4166666666666667,1,2,0
"    function calculateEggBuy(uint256 eth,uint256 contractBalance) public view returns(uint256){
        return calculateTrade(eth,contractBalance,marketEggs);
    }
","    function getBalance() public view returns(uint256){
        return this.balance;
    }
","0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:calculateEggBuy(uint256,uint256)",0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:getBalance(),0.6111111111111112,1,2,0
"    function queryN_fnc(uint _timestamp, string _datasource, bytes _args, function() external _fnc, uint _gaslimit)
    costs(_datasource, _gaslimit)
    payable
    returns (bytes32 _id) {
        if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)||address(_fnc) != msg.sender) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        LogN_fnc(msg.sender, _id, _timestamp, _datasource, _args, _fnc, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
","    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return query(_timestamp, _datasource, _arg, _gaslimit);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN_fnc(uint256,string,bytes,function(),uint256)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query_withGasLimit(uint256,string,string,uint256)",1.0,5,5,1
"	function symbol() public view returns (string _symbol) {
		return symbol;
	}
","	function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isUnlocked returns (bool success) {
		if(isContract(_to)) {
			if (balanceOf(msg.sender) < _value) revert();
			balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
			balances[_to] = safeAdd(balanceOf(_to), _value);
			assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
			Transfer(msg.sender, _to, _value, _data);
			return true;
		}
		else {
			return transferToAddress(_to, _value, _data);
		}
	}
",0x4ceae42d5fb3bd6956b2463fdd4a2209382d722c/AUMXToken.sol:AUMXToken:symbol(),"0x4ceae42d5fb3bd6956b2463fdd4a2209382d722c/AUMXToken.sol:AUMXToken:transfer(address,uint256,bytes,string)",0.24444444444444444,1,2,0
"    function transferOwnership(address _newOwner) onlyOwner public {
      if(!canRenounce){
        require(_newOwner != address(0));
      }
      emit OwnershipTransferred(owner, _newOwner);
      owner = _newOwner;
    }
","    constructor() public {
      owner = msg.sender;
    }
",0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:Ownable:transferOwnership(address),0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:Ownable:constructor(),0.5714285714285714,1,2,0
"  function transferFrom(address _from, address _to, uint _value) public returns (bool) {
    var _allowance = allowed[_from][msg.sender];
    
    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function burn(uint256 _value) public returns (bool){
    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;
    totalSupply = safeSub(totalSupply, _value);
    Transfer(msg.sender, 0x0, _value);
    return true;
  }
","0x7b7524fdf31b31fa4c1d463f490dcbdc07e63557/InternationalFarmersToken.sol:InternationalFarmersToken:transferFrom(address,address,uint256)",0x7b7524fdf31b31fa4c1d463f490dcbdc07e63557/InternationalFarmersToken.sol:InternationalFarmersToken:burn(uint256),0.09615384615384616,1,2,0
"  function balanceOf(address _owner) constant public returns (uint256 balance) {
    return tokenBalances[_owner];
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= tokenBalances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    tokenBalances[_from] = tokenBalances[_from].sub(_value);
    tokenBalances[_to] = tokenBalances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
",0x6ee48ae8bca95e9567aff9669d3119c96362a77c/BEEFJERKY.sol:BEEFJERKY:balanceOf(address),"0x6ee48ae8bca95e9567aff9669d3119c96362a77c/BEEFJERKY.sol:BEEFJERKY:transferFrom(address,address,uint256)",0.3333333333333333,1,2,0
"	function	getData_9	()	public	constant	returns	(	string	)	{
		return	inData_9	;						
	}									
","	function	setData_9	(	string	newData_9	)	public	onlyOwner	{	
		inData_9	=	newData_9	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_9(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_9(string),1.0,5,5,1
"    modifier saleIsOn() {
    	require(now > start && now < start + period * 1 days);
    	_;
    }
","    function finishMinting() public onlyOwner {
	uint issuedTokenSupply = token.totalSupply();
	uint restrictedTokens = issuedTokenSupply.mul(restrictedPercent).div(100 - restrictedPercent);
	token.mint(restricted, restrictedTokens);
        token.finishMinting();
    }
",0x4a152dd76d1919779190feea11edd06c00fed4e0/TttestaryToken.sol:Crowdsale:saleIsOn(),0x4a152dd76d1919779190feea11edd06c00fed4e0/TttestaryToken.sol:Crowdsale:finishMinting(),0.10526315789473684,1,2,0
"    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:ecrecovery(bytes32,bytes)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)",0.4444444444444444,1,2,0
"    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint _value) public returns (bool success) {

        // Only allow transfer once unlocked
        // Once it is unlocked, it is unlocked forever and no one can lock again
        require(unlocked);

        //standard function transfer similar to ERC20 transfer with no _data
        //added due to backwards compatibility reasons
        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }
",0x02dbe2f315e059743376abcd22ab4908ea9fb02d/EDOGE.sol:EDOGE:balanceOf(address),"0x02dbe2f315e059743376abcd22ab4908ea9fb02d/EDOGE.sol:EDOGE:transfer(address,uint256)",0.008594539939332659,1,2,0
"    function isContract(address _addr) private returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
","    function mintToken(address target, uint256 mintedAmount) onlyOwner{
    balances[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(0, this, mintedAmount);
    Transfer(this, target, mintedAmount);
  }
",0x2e2fc8569d3ba251965bf8ad85e2f55c37612718/CHN.sol:CHN:isContract(address),"0x2e2fc8569d3ba251965bf8ad85e2f55c37612718/CHN.sol:CHN:mintToken(address,uint256)",0.017543859649122806,1,2,0
"    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
        return oraclize.setCustomGasPrice(gasPrice);
    }
","    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setCustomGasPrice(uint256),0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getNetworkName(),1.0,5,5,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x2e954cfc5cb4f089f5f3d7331449861249106d85/WithCoin.sol:WithCoin:approve(address,uint256)",0x2e954cfc5cb4f089f5f3d7331449861249106d85/WithCoin.sol:WithCoin:totalSupply(),0.8634920634920635,1,2,0
"  modifier canMint() {
    require(!mintingFinished);
    _;
  }
","  function mint(
    address _to,
    uint256 _amount
  )
    hasMintPermission
    canMint
    public
    returns (bool)
  {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  }
",0x8aefbc7df185694f19fe1da7f499e95069761766/WOLFEXToken.sol:MintableToken:canMint(),"0x8aefbc7df185694f19fe1da7f499e95069761766/WOLFEXToken.sol:MintableToken:mint(address,uint256)",0.6358024691358025,1,2,0
"    function queryN(uint _timestamp, string _datasource, bytes _args)
    payable
    returns (bytes32 _id) {
        return queryN(_timestamp, _datasource, _args, 200000);
    }
","    function query(uint _timestamp, string _datasource, string _arg, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return query1(_timestamp, _datasource, _arg, _gaslimit);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN(uint256,string,bytes)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query(uint256,string,string,uint256)",1.0,5,5,1
"  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0a13c213d5148ccae7517c5d0ecfbaa18199e739/GlobalSuperGameCoin.sol:StandardToken:transferFrom(address,address,uint256)","0x0a13c213d5148ccae7517c5d0ecfbaa18199e739/GlobalSuperGameCoin.sol:StandardToken:decreaseApproval(address,uint256)",0.8431635388739946,1,2,0
"    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:canDistr(),"0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:approve(address,uint256)",0.9104477611940298,1,2,0
"   function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }
","0x3E9Da0c1888B89c89d3b518324d831fCDa33e761/STLHToken.sol:STLHToken:transfer(address,uint256)",0x3E9Da0c1888B89c89d3b518324d831fCDa33e761/STLHToken.sol:STLHToken:balanceOf(address),0.7931034482758621,1,2,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x2e606bbb20381b671ea8bba1e88988d09082fcee/TestToken123.sol:StandardToken:decreaseApproval(address,uint256)","0x2e606bbb20381b671ea8bba1e88988d09082fcee/TestToken123.sol:StandardToken:allowance(address,address)",0.9466192170818504,1,1,0
"	function	getData_5	()	public	constant	returns	(	string	)	{	
		return	inData_5	;							
	}										
","		function	setDepositary_function_control	(	uint256	newDepositary_function_control	)	public	onlyOwner	{	
			Depositary_function_control	=	newDepositary_function_control	;					
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_5(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setDepositary_function_control(uint256),0.0,1,1,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x3b145cacdf91021cae905e4d6d2e0dce436d43cb/Zillion.sol:SafeMath:div(uint256,uint256)","0x3b145cacdf91021cae905e4d6d2e0dce436d43cb/Zillion.sol:SafeMath:mul(uint256,uint256)",0.99009900990099,5,5,1
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x3b07a0f3a9dee1144532fca548bf31afaeba0290/OSNToken.sol:StandardToken:approve(address,uint256)","0x3b07a0f3a9dee1144532fca548bf31afaeba0290/OSNToken.sol:StandardToken:increaseApproval(address,uint256)",0.4008574490889603,1,1,0
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x02b7b8e795abdae90b48a00f720ca9f5a07802d1/YSSYBToken.sol:TokenERC20:TokenERC20(uint256,string,string)","0x02b7b8e795abdae90b48a00f720ca9f5a07802d1/YSSYBToken.sol:TokenERC20:transfer(address,uint256)",0.8630136986301371,1,1,0
"    modifier canTransfer(address _sender) {

        if(!released) {
            if(!transferAgents[_sender]) {
                revert();
            }
        }
        _;
    }
","    function transfer(address _to, uint256 _value) canTransfer(msg.sender) public returns (bool success) {        
        return super.transfer(_to, _value);
    }
",0x1b20d171d65245d0996989c9792d1051d5b47672/SUREToken.sol:SUREToken:canTransfer(address),"0x1b20d171d65245d0996989c9792d1051d5b47672/SUREToken.sol:SUREToken:transfer(address,uint256)",1.0,5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] = balanceOf[_from].sub(_value);                         
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             
        totalSupply = totalSupply.sub(_value);                              
        Burn(_from, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x7f738ffbde7ecac18d31ecba1e9b6eef5b9214b7/InfluToken.sol:InfluToken:burnFrom(address,uint256)","0x7f738ffbde7ecac18d31ecba1e9b6eef5b9214b7/InfluToken.sol:InfluToken:approve(address,uint256)",0.8,1,1,0
"    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[4])",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setNetwork(uint8),0.8,1,1,0
"    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","0x3c4432278fc4d6b23112393cd80d82edc8f24e39/CryptoDiamondCoin.sol:CryptoDiamondCoin:doAirdrop(address,uint256)",0x3c4432278fc4d6b23112393cd80d82edc8f24e39/CryptoDiamondCoin.sol:CryptoDiamondCoin:balanceOf(address),1.0,5,5,1
"    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
",0x3c4432278fc4d6b23112393cd80d82edc8f24e39/CryptoDiamondCoin.sol:CryptoDiamondCoin:transferOwnership(address),"0x3c4432278fc4d6b23112393cd80d82edc8f24e39/CryptoDiamondCoin.sol:CryptoDiamondCoin:allowance(address,address)",0.1566265060240964,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[2],uint256)",1.0,5,5,1
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return rewardBalances[_owner];
    }
","    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= rewardBalances[msg.sender]);

        // SafeMath.sub will throw an error if there is not enough balance.
        rewardBalances[msg.sender] = rewardBalances[msg.sender].sub(_value);
        rewardBalances[_to] = rewardBalances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x3af70f8772fadd33b18eb1bdf9475ea727817391/ReferToken.sol:ReferTokenERC20Basic:balanceOf(address),"0x3af70f8772fadd33b18eb1bdf9475ea727817391/ReferToken.sol:ReferTokenERC20Basic:transfer(address,uint256)",0.22300706357214933,1,2,0
"    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }
","    function decimals() public constant returns (uint8 decimals) { decimals; }
",0x5bb5b32cb114c7f558a3f5b0933dcfa74be9611a/KickcityCrowdsale.sol:IERC20Token:totalSupply(),0x5bb5b32cb114c7f558a3f5b0933dcfa74be9611a/KickcityCrowdsale.sol:IERC20Token:decimals(),0.1097560975609756,1,1,0
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function transferOwnership(address newOwner) onlyOwner public {
      require(newOwner != address(0));
      OwnershipTransferred(owner, newOwner);
      owner = newOwner;
    }
","0x4beea326249b0d9866c3d4d6559bcad2cd979372/SLPC_ERC20Token.sol:SLPC_ERC20Token:_transfer(address,address,uint256)",0x4beea326249b0d9866c3d4d6559bcad2cd979372/SLPC_ERC20Token.sol:SLPC_ERC20Token:transferOwnership(address),0.0025906735751295338,1,1,0
"    function withdraw(uint amount) public {
        if (isOwner() && now >= openDate) {
            uint max = deposits[msg.sender];
            if (amount <= max && max > 0) {
                msg.sender.transfer(amount);
            }
        }
    }
","    function setup(uint _openDate) public {
        Owner = msg.sender;
        openDate = _openDate;
    }
",0x4ba0d338a7c41cc12778e0a2fa6df2361e8d8465/ICO_Hold.sol:ICO_Hold:withdraw(uint256),0x4ba0d338a7c41cc12778e0a2fa6df2361e8d8465/ICO_Hold.sol:ICO_Hold:setup(uint256),0.5,1,1,0
"  function transferTokensFromContract(address _to, uint256 _amount) private {
    traded_token_balance = traded_token_balance.sub(_amount);
    require(Token(traded_token).transfer(_to,_amount));
  }
","  function transferTokensThroughProxyToContract(address _from, address _to, uint256 _amount) private {

    traded_token_balance = traded_token_balance.add(_amount);

    require(Token(traded_token).transferFrom(_from,_to,_amount));
     
  }  
","0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:transferTokensFromContract(address,uint256)","0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:transferTokensThroughProxyToContract(address,address,uint256)",1.0,5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
",0x1a86b24ca84aa7049a974bb6db83f0bd80c60713/DCoin.sol:TokenERC20:burn(uint256),"0x1a86b24ca84aa7049a974bb6db83f0bd80c60713/DCoin.sol:TokenERC20:_transfer(address,address,uint256)",0.7981220657276995,1,1,0
"function burnToken(address target, uint tokens) returns (bool result){ 
        balances[target] -= tokens;
	totalSupply_ = safeSub(totalSupply_, tokens);
        Transfer(owner, target, tokens);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x04da1cd6498986015f700397a8b4bfbaa70c9399/GuneToken.sol:GuneToken:burnToken(address,uint256)","0x04da1cd6498986015f700397a8b4bfbaa70c9399/GuneToken.sol:GuneToken:allowance(address,address)",1.0,5,5,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4ee18f80c4c6e1e7ecb32f2fb6393486924679ac/Etheriumhit.sol:StandardToken:increaseApproval(address,uint256)","0x4ee18f80c4c6e1e7ecb32f2fb6393486924679ac/Etheriumhit.sol:StandardToken:decreaseApproval(address,uint256)",1.0,5,5,1
"    function MultiSigWallet(address[] _owners, uint _required)
        public
        validRequirement(_owners.length, _required)
    {
        for (uint i=0; i<_owners.length; i++) {
            require(!isOwner[_owners[i]] && _owners[i] != 0);
            isOwner[_owners[i]] = true;
        }
        owners = _owners;
        required = _required;
    }
","    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }
","0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:MultiSigWallet(address[],uint256)",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:addOwner(address),1.0,5,5,1
"		function	getID	()	public	constant	returns	(	uint256	)	{
			return	ID	;						
		}									
","	function	getData_4	()	public	constant	returns	(	string	)	{	
		return	inData_4	;							
	}										
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getID(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_4(),0.0,1,1,0
"  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
","0x2d6669c810bf1444d2e5e7f4cfc56a4c10cf7a2a/HYIPToken.sol:StandardToken:approve(address,uint256)",0x2d6669c810bf1444d2e5e7f4cfc56a4c10cf7a2a/HYIPToken.sol:StandardToken:balanceOf(address),0.2697368421052632,1,2,0
"  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {
    require(_spender != address(this));

    super.approve(_spender, _value);

    require(_spender.call(_data));

    return true;
  }
","  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));

    super.transfer(_to, _value);

    require(_to.call(_data));
    return true;
  }
","0x5c9362bea20046bbc2f6e73e264b91e067e17693/PalliumToken.sol:ERC827Token:approve(address,uint256,bytes)","0x5c9362bea20046bbc2f6e73e264b91e067e17693/PalliumToken.sol:ERC827Token:transfer(address,uint256,bytes)",1.0,5,5,1
"	function	getPOOL_edit_23	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_23	;						
	}									
","	function	setPOOL_edit_22	(	string	newPOOL_edit_22	)	public	onlyOwner	{	
		inPOOL_edit_22	=	newPOOL_edit_22	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_23(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_22(string),1.0,5,5,1
"  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x00e9bcfab52c108505411849faba90e83c98101b/GTSTOKEN.sol:SafeMath:max256(uint256,uint256)","0x00e9bcfab52c108505411849faba90e83c98101b/GTSTOKEN.sol:SafeMath:mul(uint256,uint256)",0.5257142857142857,1,1,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x6bc2adef424c32cf1e15789f010ea16a753587ac/LEBRON.sol:LEBRON:transferFrom(address,address,uint256)","0x6bc2adef424c32cf1e15789f010ea16a753587ac/LEBRON.sol:LEBRON:allowance(address,address)",0.9913793103448276,5,5,1
"    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmax(x, y);
    }
","    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {
        return x >= y ? x : y;
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:rmax(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:hmax(uint128,uint128)",1.0,5,5,1
"	function	getPI_edit_5	()	public	constant	returns	(	string	)	{
		return	inPI_edit_5	;						
	}									
","	function	PI_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_5(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:PI_EDIT_1(),0.5,1,1,0
"    function HARITECOIN() public {
        balanceOf[msg.sender] = totalSupply;
    }
","    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
",0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:HARITECOIN(),0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:isContract(address),0.14285714285714285,1,1,0
"  modifier onlyReleaseAgent() {
    require(msg.sender == releaseAgent);
    _;
  }
","  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
",0x1d6f351406c50fdf5c45a53ae17f9de092a32f19/FRNCoin.sol:ReleasableToken:onlyReleaseAgent(),"0x1d6f351406c50fdf5c45a53ae17f9de092a32f19/FRNCoin.sol:ReleasableToken:setTransferAgent(address,bool)",0.3125,1,1,0
"    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {
        require(self.mintable);
        require(msg.sender == self.minter || msg.sender == self.owner);
        if (lockAccount) {
            self.accountLocked[tokenOwner] = true;
        }
        self.balances[tokenOwner] = safeAdd(self.balances[tokenOwner], tokens);
        self.totalSupply = safeAdd(self.totalSupply, tokens);
        Mint(tokenOwner, tokens, lockAccount);
        Transfer(address(0), tokenOwner, tokens);
        return true;
    }
","    function signedTransferFromHash(Data storage /*self*/, address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {
        hash = keccak256(signedTransferFromSig, address(this), spender, from, to, tokens, fee, nonce);
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:mint(BTTSLib:Data,address,uint256,bool)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:signedTransferFromHash(BTTSLib:Data,address,address,address,uint256,uint256,uint256)",1.0,5,5,1
"	function etherProceeds() external
		onlyOwner
	{
		if(!msg.sender.send(this.balance)) revert();
	}
","  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}
",0x2e2625d38ec84cbc13117fa1a74e4266b5e94318/FJH.sol:FJH:etherProceeds(),"0x2e2625d38ec84cbc13117fa1a74e4266b5e94318/FJH.sol:FJH:approve(address,uint256)",0.9565217391304348,5,5,1
"    function remove(bytes32Set storage self, bytes32 other) public {
        if (contains(self, other)) {
            uint replaceIndex = self.memberIndices[other];
            bytes32 lastMember = self.members[length(self)-1];
            // overwrite other with the last member and remove last member
            self.members[replaceIndex-1] = lastMember;
            self.members.length--;
            // reflect this change in the indices
            self.memberIndices[lastMember] = replaceIndex;
            delete self.memberIndices[other];
        }
    }
","    function insert(byteSet storage self, byte other) public {
        if (!contains(self, other)) {
            assert(length(self) < 2**256-1);
            self.members.push(other);
            self.memberIndices[other] = length(self);
        }
    }
","0x1f5cdff41fb9b17996d6f0fca6ab9c5bed96f20f/Prover.sol:Sets:remove(Sets:bytes32Set,bytes32)","0x1f5cdff41fb9b17996d6f0fca6ab9c5bed96f20f/Prover.sol:Sets:insert(Sets:byteSet,bytes1)",0.0,1,1,0
"  function seed_eth() public payable only_admin() {
    require(!eth_is_seeded);
    require(msg.value == eth_seed_amount);
    set_eth_as_seeded();
    deposit_eth(); 
  }
","  function set_eth_as_seeded() private {
    eth_is_seeded = true;
  }
",0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:seed_eth(),0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:set_eth_as_seeded(),1.0,5,5,1
"    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
","    function Owned() public {
        owner = msg.sender;
    }
",0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:Owned:acceptOwnership(),0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:Owned:Owned(),0.8112094395280236,1,1,0
"  function setHouseAddress(address _house) onlyOwner public {
    house = _house;
  }
","  function random(uint256 upper) private returns (uint256 randomNumber) {
    return maxRandom() % upper;
  }
",0x5caeebfab3cd8655e04692351237efb7462c9d8f/VfSE_Lottery.sol:VfSE_Lottery:setHouseAddress(address),0x5caeebfab3cd8655e04692351237efb7462c9d8f/VfSE_Lottery.sol:VfSE_Lottery:random(uint256),0.0,1,1,0
"    function isPaused () onlyOwner public view returns(bool) {
        return paused;
    }
","    function _forwardFunds() internal {
        vault.deposit.value(msg.value)(msg.sender);
    }
",0x2c1e693ccc537c8c98c73fac0262cd7e18a3ad60/LandSale.sol:LandSale:isPaused(),0x2c1e693ccc537c8c98c73fac0262cd7e18a3ad60/LandSale.sol:LandSale:_forwardFunds(),0.0,1,1,0
"  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x0df6f67b17c515b5a78b1b38fa9d6c171f65abf3/AtrantSimpleCoinToken.sol:StandardToken:approve(address,uint256)","0x0df6f67b17c515b5a78b1b38fa9d6c171f65abf3/AtrantSimpleCoinToken.sol:StandardToken:transferFrom(address,address,uint256)",0.6604938271604939,1,1,0
"  	function transfer(address _to, uint256 _value) public  returns (bool)
 	{
		require(_to != address(0));
		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	}
","  	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) 
  	{
		require(_to != address(0));
		uint256 _allowance = allowed[_from][msg.sender];
		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = _allowance.sub(_value);
		Transfer(_from, _to, _value);
		return true;
  	}
","0x2a5294b5d15c582eb33b9dae0e271d9003d26826/BTMC.sol:BTMC:transfer(address,uint256)","0x2a5294b5d15c582eb33b9dae0e271d9003d26826/BTMC.sol:BTMC:transferFrom(address,address,uint256)",0.2298136645962733,1,1,0
"    function finishDistribution() onlyOwner public returns (bool) {
    distributionFinished = true;
    DistrFinished();
    return true;
    }
","    modifier onlyOwner { 
        require(msg.sender == owner);
        _;
    }
",0x3b5e99da4df32b933e9887ef58b740a06ad38961/Learn.sol:Learn:finishDistribution(),0x3b5e99da4df32b933e9887ef58b740a06ad38961/Learn.sol:Learn:onlyOwner(),1.0,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
","0x5eab901c61b4c4775349e6bb6e78ce3f4d496b0d/LBL.sol:LBL:_transfer(address,address,uint256)","0x5eab901c61b4c4775349e6bb6e78ce3f4d496b0d/LBL.sol:LBL:burnFrom(address,uint256)",0.8501291989664083,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value) active returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value && _value > 0);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) active returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:transferFrom(address,address,uint256)","0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:approve(address,uint256)",0.8687350835322196,1,1,0
"  function add(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","  function mul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x6e939629f97cdadf6d6d2f3f1d675383e0046039/DatumTokenDistributor.sol:SafeMath:add(uint256,uint256)","0x6e939629f97cdadf6d6d2f3f1d675383e0046039/DatumTokenDistributor.sol:SafeMath:mul(uint256,uint256)",0.9293478260869564,1,1,0
"  function addTokenTo(address _to, uint256 _tokenId) internal {
    super.addTokenTo(_to, _tokenId);
    uint256 length = ownedTokens[_to].length;
    ownedTokens[_to].push(_tokenId);
    ownedTokensIndex[_tokenId] = length;
  }
","  function _burn(address _owner, uint256 _tokenId) internal {
    super._burn(_owner, _tokenId);

    // Clear metadata (if any)
    if (bytes(tokenURIs[_tokenId]).length != 0) {
      delete tokenURIs[_tokenId];
    }

    // Reorg all tokens array
    uint256 tokenIndex = allTokensIndex[_tokenId];
    uint256 lastTokenIndex = allTokens.length.sub(1);
    uint256 lastToken = allTokens[lastTokenIndex];

    allTokens[tokenIndex] = lastToken;
    allTokens[lastTokenIndex] = 0;

    allTokens.length--;
    allTokensIndex[_tokenId] = 0;
    allTokensIndex[lastToken] = tokenIndex;
  }
","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721Token:addTokenTo(address,uint256)","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721Token:_burn(address,uint256)",1.0,5,5,1
"  function mint(uint256 _amount) onlyOwnerOrMintDelegate public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[msg.sender] = balances[msg.sender].add(_amount);

    // Call events
    Mint(msg.sender, _amount);
    Transfer(address(0), msg.sender, _amount);

    return true;
  }
","  modifier onlyOwnerOrBurnDelegate() {
    bool allowedToBurn = false;

    if(msg.sender==owner) {
      allowedToBurn = true;
    }
    else {
      for(uint i=0; i<burnDelegates.length; i++) {
        if(burnDelegates[i]==msg.sender) {
          allowedToBurn = true;
          break;
        }
      }
    }

    require(allowedToBurn==true);
    _;
  }
",0x4eea6844a4dc5bf3127decf034b3f4a7211ef2e7/Trident.sol:Trident:mint(uint256),0x4eea6844a4dc5bf3127decf034b3f4a7211ef2e7/Trident.sol:Trident:onlyOwnerOrBurnDelegate(),0.5,1,1,0
"function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
","function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
","0x5a82de3515fc4a4db9ba9e869f269a1e85300092/BTCx.sol:TokenERC20:approve(address,uint256)","0x5a82de3515fc4a4db9ba9e869f269a1e85300092/BTCx.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8964059196617337,1,1,0
"    function tokensByZecTx(string _txId) public constant returns (uint256) {
        return _tokensByTx(Currency.ZEC, _txId);
    }
","    function tokensByWavesTx(string _txId) public constant returns (uint256) {
        return _tokensByTx(Currency.WAVES, _txId);
    }
",0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:tokensByZecTx(string),0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:tokensByWavesTx(string),1.0,5,5,1
"	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}
","	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getImageHeight(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:setImageWidth(uint256,uint16)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }     
","    function totalSupply() constant returns (uint256 totalSupply) {
        return _totalSupply;
    }
","0x4eefc1fc753fc09bf78dc19291372ab5efa23356/GEM.sol:GEM:transferFrom(address,address,uint256)",0x4eefc1fc753fc09bf78dc19291372ab5efa23356/GEM.sol:GEM:totalSupply(),0.011111111111111113,1,1,0
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
","    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }
","0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:transferFrom(address,address,uint256)","0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:distributeAmounts(address[],uint256[])",0.25,1,1,0
"    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) internal canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from);
        require(_to != address(0));

        _transfer(_to, _tokenId);

        if (_to.isContract()) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(retval == MAGIC_ON_ERC721_RECEIVED);
        }
    }
","    function _mint(address _to, uint256 _tokenId) internal {
        require(_to != address(0));
        require(_tokenId != 0);
        require(idToOwner[_tokenId] == address(0));

        addNFToken(_to, _tokenId);

        emit Transfer(address(0), _to, _tokenId);
    }
","0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d/EtheremonAdventureItem.sol:NFToken:_safeTransferFrom(address,address,uint256,bytes)","0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d/EtheremonAdventureItem.sol:NFToken:_mint(address,uint256)",1.0,5,5,1
"  function transfer(address _to, uint256 _value) whenNotPaused returns (bool) {
    require(!isFrozen(msg.sender));
    require(!isFrozen(_to));
    return super.transfer(_to, _value);
  }
","  function unfreeze(address _addr) onlyModerator {
      frozen[_addr] = false;
  }
","0x7ca5a1730d94c813905c5c31b6fd27131a8869ff/EVXTestToken.sol:evxModeratedToken:transfer(address,uint256)",0x7ca5a1730d94c813905c5c31b6fd27131a8869ff/EVXTestToken.sol:evxModeratedToken:unfreeze(address),1.0,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x3d7c5223825cc58bfa07b9484935ad76e1741a2b/JoshuaCoin.sol:JoshuaCoin:transferAnyERC20Token(address,uint256)",0x3d7c5223825cc58bfa07b9484935ad76e1741a2b/JoshuaCoin.sol:JoshuaCoin:balanceOf(address),0.9453376205787779,5,5,1
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:transfer(address,uint256)","0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:approve(address,uint256)",0.7971014492753623,1,1,0
"    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
",0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:withdraw(),"0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:allowance(address,address)",1.0,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x6daa2ca19196291f162e11174f21da3c64b83094/CitizenOne.sol:SafeMath:sub(uint256,uint256)","0x6daa2ca19196291f162e11174f21da3c64b83094/CitizenOne.sol:SafeMath:mul(uint256,uint256)",0.9659477866061292,5,5,1
"     function approve(address _spender, uint256 _amount) returns (bool success) {
         allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
         return true;
     }
","     modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x7e9d62e1ff4e34096f91ee0153222ab81f7184f0/ELTC.sol:ELTC:approve(address,uint256)",0x7e9d62e1ff4e34096f91ee0153222ab81f7184f0/ELTC.sol:ELTC:onlyOwner(),0.18181818181818185,1,1,0
"    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x8acd341e4c0f1c329ae33cb4eaac39e3c1f2c210/INMCOIN.sol:INMCOIN:finishMinting(),"0x8acd341e4c0f1c329ae33cb4eaac39e3c1f2c210/INMCOIN.sol:INMCOIN:approve(address,uint256)",0.07575757575757576,1,1,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x2eba1b1f993e54ae0ba1abee4630fb9ae7528a96/CryptoKotik.sol:CryptoKotik:transferFrom(address,address,uint256)",0x2eba1b1f993e54ae0ba1abee4630fb9ae7528a96/CryptoKotik.sol:CryptoKotik:totalSupply(),0.9655172413793104,5,5,1
"    function stop() auth  {
        stopped = true;
    }
","    modifier stoppable {
        assert (!stopped);
        _;
    }
",0x0f1ed66c251bcb52ecf7e67ac64bb72482048adb/SEER.sol:SEER:stop(),0x0f1ed66c251bcb52ecf7e67ac64bb72482048adb/SEER.sol:SEER:stoppable(),0.26666666666666666,1,1,0
"    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[])",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:uint2str(uint256),0.8,1,1,0
"  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function approveAndCall(address _spender, uint256 _value, bytes _extraData){    
      TokenSpender spender = TokenSpender(_spender);
      if (approve(_spender, _value)) {
          spender.receiveApproval(msg.sender, _value, this, _extraData);
      }
  }
","0x8bada5bc5cbc107f01c9a11e93cf0641b2851b95/Crowdsale.sol:RLC:transfer(address,uint256)","0x8bada5bc5cbc107f01c9a11e93cf0641b2851b95/Crowdsale.sol:RLC:approveAndCall(address,uint256,bytes)",0.00816326530612245,1,1,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af/archercoin.sol:TokenERC20:burn(uint256),"0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af/archercoin.sol:TokenERC20:transferFrom(address,address,uint256)",0.8826291079812206,1,1,0
"    function setInitialApplicationAddress(address _ownerAddress) public onlyDeployer requireNotInitialised {
        owner = _ownerAddress;
    }
","    function getApplicationState() public view returns (uint8) {
        return ApplicationEntityABI(owner).CurrentEntityState();
    }
",0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:setInitialApplicationAddress(address),0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:getApplicationState(),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[2])",1.0,5,5,1
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x4a45b693af2500b5167ca17eb5de03f708447534/MITT.sol:StandardToken:approve(address,uint256)","0x4a45b693af2500b5167ca17eb5de03f708447534/MITT.sol:StandardToken:allowance(address,address)",0.8695652173913043,1,1,0
"	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}
","	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}
","0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:setRegionCurrentPixelPrice(uint256,uint256)","0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:setRegionPurchasedPixelPrice(uint256,uint256)",1.0,5,5,1
"	function	getPOOL_edit_31	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_31	;						
	}									
","	function	getPOOL_edit_24	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_24	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_31(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_24(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns 
    (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value; 
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","0x0c024ebb8532a0516114e386e892793dae99d574/CNBCoin.sol:StandardToken:transfer(address,uint256)","0x0c024ebb8532a0516114e386e892793dae99d574/CNBCoin.sol:StandardToken:transferFrom(address,address,uint256)",0.3678160919540229,1,1,0
"  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x3f0624d68a16f19428584333c1871cdfba0ba870/DatCrowdPreSale.sol:StandardToken:approve(address,uint256)","0x3f0624d68a16f19428584333c1871cdfba0ba870/DatCrowdPreSale.sol:StandardToken:allowance(address,address)",0.9382716049382716,1,1,0
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x7b06ad092541635cf83a1ff03daf713269d94a15/IouRootsPresaleToken.sol:SafeMath:add(uint256,uint256)","0x7b06ad092541635cf83a1ff03daf713269d94a15/IouRootsPresaleToken.sol:SafeMath:mul(uint256,uint256)",0.7943820224719101,1,1,0
"    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a * b;
        assert(a == 0 || (c / a) == b);
        return c;
    }
","    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
","0x07a58629AAF3e1A0d07D8f43114B76BD5EEe3B91/insChainToken.sol:Safe:safeMultiply(uint256,uint256)","0x07a58629AAF3e1A0d07D8f43114B76BD5EEe3B91/insChainToken.sol:Safe:safeAdd(uint256,uint256)",0.021512385919165586,1,1,0
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x0d1c63e12fde9e5cada3e272576183aba9cfeda2/ZenswapNetworkToken.sol:ZenswapNetworkToken:burnFrom(address,uint256)","0x0d1c63e12fde9e5cada3e272576183aba9cfeda2/ZenswapNetworkToken.sol:ZenswapNetworkToken:transfer(address,uint256)",0.8851174934725848,1,1,0
"    modifier onlyTokenManager() {
        require(msg.sender == tokenManager);
        _;
    }
","    function setPresalePhase(Phase _nextPhase) public onlyTokenManager {
        bool canSwitchPhase
            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)
            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)
            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)
                && _nextPhase == Phase.Migrating
                && crowdsaleManager != 0x0)
            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)
            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated
                && totalSupply == 0);
        
        require(canSwitchPhase);
        currentPhase = _nextPhase;
        PhaseSwitch(_nextPhase);
    }
",0x6D85320c086aeE2eCD2693855fb2164c494fd251/ATP.sol:ATP:onlyTokenManager(),0x6D85320c086aeE2eCD2693855fb2164c494fd251/ATP.sol:ATP:setPresalePhase(ATP:Phase),0.5,1,1,0
"    function setLock(bool _lock) onlyOwner public{
        lock = _lock;
    }
","    modifier isLock {
        require(!lock);
        _;
    }
",0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5/HeavenlyHoundCoin.sol:HeavenlyHoundCoin:setLock(bool),0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5/HeavenlyHoundCoin.sol:HeavenlyHoundCoin:isLock(),0.9090909090909092,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function Facebook() public {
        symbol = ""FB"";
        name = ""Facebook "";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9] = _totalSupply;
        Transfer(address(0), 0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9, _totalSupply);
    }
","0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:approve(address,uint256)",0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:Facebook(),0.37777777777777777,1,1,0
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);

        // Check for overflows
        require(balanceOf[_to].add(_value) > balanceOf[_to]);

        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from].add(balanceOf[_to]);

        // Subtract from the sender
        balanceOf[_from] = balanceOf[_from].sub(_value);

        // Add the same to the recipient
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x3d442cb873635ac9993ba86d0bcf6d00f526c6a0/CinociCoin.sol:TokenERC20:_transfer(address,address,uint256)","0x3d442cb873635ac9993ba86d0bcf6d00f526c6a0/CinociCoin.sol:TokenERC20:approve(address,uint256)",0.3809523809523809,1,1,0
"	function	getID	()	public	constant	returns	(	uint256	)	{
		return	ID	;						
	}									
","	function	getDepositary_function	()	public	constant	returns	(	uint256	)	{
		return	Depositary_function	;						
	}									
",0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:getID(),0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:getDepositary_function(),1.0,5,5,1
"    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {
        return oraclize.setConfig(config);
    }
","    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setConfig(bytes32),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[1])",1.0,5,5,1
"    function setPrices(uint256 _buyPrice) onlyOwner public {
        buyPrice = _buyPrice;
    }
","    function _transfer(address _from, address _to, uint256 _value) isLock internal {
        require (_to != address(0));                        // Prevent transfer to 0x0 address. Use burn() instead
        require (balances[_from] >= _value);                // Check if the sender has enough
        require (balances[_to] + _value > balances[_to]);   // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        //require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balances[_from] = balances[_from].sub(_value);      // Subtract from the sender
        balances[_to] = balances[_to].add(_value);          // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }
",0x2be21024ee10ffcf293d927bee1375c1048dca4b/NetkillerAdvancedToken.sol:NetkillerAdvancedToken:setPrices(uint256),"0x2be21024ee10ffcf293d927bee1375c1048dca4b/NetkillerAdvancedToken.sol:NetkillerAdvancedToken:_transfer(address,address,uint256)",1.0,5,5,1
"    function radd(uint128 x, uint128 y) constant internal returns (uint128) {
        return hadd(x, y);
    }
","    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {
        return hsub(x, y);
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:radd(uint128,uint128)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:rsub(uint128,uint128)",1.0,5,5,1
"    function setEndtDate(uint256 _endDate) isCreator public {
        endDate = _endDate;
    }
","    function setOwner(address _owner) isCreator public {
        owner = _owner;
    }
",0x6f049db0edbcd2e41bc14ae4f3bdf44f2c40e1c8/RXPSale.sol:RXPSale:setEndtDate(uint256),0x6f049db0edbcd2e41bc14ae4f3bdf44f2c40e1c8/RXPSale.sol:RXPSale:setOwner(address),1.0,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","0x1a9d7ee82cc595d2ea6dc877fc5b3bd8462887b0/Mobilla.sol:Mobilla:allowance(address,address)","0x1a9d7ee82cc595d2ea6dc877fc5b3bd8462887b0/Mobilla.sol:Mobilla:transfer(address,uint256)",0.7598784194528876,1,1,0
"  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","0x8a113a57e74aef531bee8de7e16e604916f053ac/ClipperCoin.sol:SafeMath:max64(uint64,uint64)","0x8a113a57e74aef531bee8de7e16e604916f053ac/ClipperCoin.sol:SafeMath:max256(uint256,uint256)",0.9864864864864864,5,5,1
"    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
","    function fortunecoin() TokenERC20() public {}
",0x6b966351e9f09ee60072c1778247b7af817a9073/fortunecoin.sol:fortunecoin:sell(uint256),0x6b966351e9f09ee60072c1778247b7af817a9073/fortunecoin.sol:fortunecoin:fortunecoin(),0.06779661016949153,1,1,0
"  function decimals() constant returns (uint8 _decimals) {
      return decimals;
  }
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
",0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:decimals(),"0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:allowance(address,address)",0.4888888888888889,1,1,0
"    function createTokens() public payable {
        require(msg.value > 0);
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        
        //_totalSupply = _totalSupply.add(tokens);
        
        owner.transfer(msg.value);
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
",0x7c8db6eefa66f5fca3343bd10f7d4932b0c152f7/GigsToken.sol:GigsToken:createTokens(),"0x7c8db6eefa66f5fca3343bd10f7d4932b0c152f7/GigsToken.sol:GigsToken:allowance(address,address)",1.0,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x0fbbfd1243552c8a66ab05c1f9530fb116e9fff4/AlicToken.sol:AlicToken:approveAndCall(address,uint256,bytes)","0x0fbbfd1243552c8a66ab05c1f9530fb116e9fff4/AlicToken.sol:AlicToken:transferFrom(address,address,uint256)",0.7744107744107744,1,1,0
"	function mint(address _who, uint _value)
		only_owner
		public
	{
		accounts[_who].balance += _value;
		totalSupply += _value;
		Minted(_who, _value);
	}
","	modifier when_owns(address _owner, uint _amount) {
		require (accounts[_owner].balance >= _amount);
		_;
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:mint(address,uint256)","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:when_owns(address,uint256)",1.0,5,5,1
"	function mint(address _who, uint _value)
		only_owner
		public
	{
		accounts[_who].balance += _value;
		totalSupply += _value;
		Minted(_who, _value);
	}
","	modifier when_owns(address _owner, uint _amount) {
		require (accounts[_owner].balance >= _amount);
		_;
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:mint(address,uint256)","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:when_owns(address,uint256)",1.0,5,5,1
"    function transferIcoship(address _newIco) onlyOwner {
        ico = _newIco;
    }
","    function transferOwnership(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
",0x7b6054262d9ac537110a434ae75c880192faac25/StarToken.sol:Owned:transferIcoship(address),0x7b6054262d9ac537110a434ae75c880192faac25/StarToken.sol:Owned:transferOwnership(address),1.0,5,5,1
"      function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
      }
","      function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
      }
","0x1a42ed4d873c298e729ac83a3ad41de66e99a6f2/SocialMediaIncomeCrowdsale.sol:StandardToken:allowance(address,address)","0x1a42ed4d873c298e729ac83a3ad41de66e99a6f2/SocialMediaIncomeCrowdsale.sol:StandardToken:increaseApproval(address,uint256)",0.35339366515837106,1,1,0
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x1beef31946fbbb40b877a72e4ae04a8d1a5cee06/Parachute.sol:Parachute:approveAndCall(address,uint256,bytes)","0x1beef31946fbbb40b877a72e4ae04a8d1a5cee06/Parachute.sol:Parachute:allowance(address,address)",1.0,5,5,1
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
",0x6e7c9606ac5bcc0123ee97f8399e6f28aafb70e0/SqueezerToken.sol:BasicToken:totalSupply(),0x6e7c9606ac5bcc0123ee97f8399e6f28aafb70e0/SqueezerToken.sol:BasicToken:balanceOf(address),0.44639376218323584,1,1,0
"    function burn(uint _value) external {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = subtr(balances[burner], _value);
        totalSupply = subtr(totalSupply, _value);
        emit Burn(burner, _value);
        emit Transfer(burner, address(0), _value);
    }
","    function transfer(address _to, uint _value, bytes _data) public returns (bool) {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = subtr(balances[msg.sender], _value);
        balances[_to] = addit(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        if (isContract(_to)) {
            TokenReceiver receiver = TokenReceiver(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        return true;
    }
",0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:burn(uint256),"0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:transfer(address,uint256,bytes)",0.0,1,1,0
"  constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
","  function transfer(address _to, uint256 _value) public onlyTransferable returns (bool) {
      return super.transfer(_to, _value);
  }
",0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2/HUMPresale.sol:HUMToken:constructor(address),"0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2/HUMPresale.sol:HUMToken:transfer(address,uint256)",0.0,1,1,0
"   function sub(uint a, uint b) internal pure returns (uint) {
      assert(b <= a);
      return a - b;
   }
","   function mul(uint a, uint b) internal pure returns (uint) {
     if (a == 0) {
        return 0;
      }

      uint c = a * b;
      assert(c / a == b);
      return c;
   }
","0x04f2e7221fdb1b52a68169b25793e51478ff0329/Cappasity.sol:SafeMath:sub(uint256,uint256)","0x04f2e7221fdb1b52a68169b25793e51478ff0329/Cappasity.sol:SafeMath:mul(uint256,uint256)",0.7619047619047619,1,1,0
"    function getCooldownIndexFromGeneration(uint16 _generation) public view returns (uint16)
    {
        uint16 result = _generation;
        if (result > getCooldownIndexCount()) {
            result = uint16(getCooldownIndexCount() - 1);
        }
        return result;
    }
","    function getCooldownEndTimeFromIndex(uint16 _cooldownIndex) public view returns (uint40)
    {
        return uint40(now + cooldowns[_cooldownIndex]);
    }
",0x0f1e2ffd515c24b3ed0a4a9df0f02e86d6755e03/Config.sol:Config:getCooldownIndexFromGeneration(uint16),0x0f1e2ffd515c24b3ed0a4a9df0f02e86d6755e03/Config.sol:Config:getCooldownEndTimeFromIndex(uint16),1.0,5,5,1
"    function increaseApproval(address _spender, uint _addedValue)
    returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));

        uint256 _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // require (_value <= _allowance);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","0x3ccb4b3bb15d4b8911cd7f57a6479e21daf4c68c/IRBToken.sol:StandardToken:increaseApproval(address,uint256)","0x3ccb4b3bb15d4b8911cd7f57a6479e21daf4c68c/IRBToken.sol:StandardToken:transferFrom(address,address,uint256)",0.1597051597051597,1,1,0
"    function remove(int8Set storage self, int8 other) {
        if (contains(self, other)) {
            uint replaceIndex = self.memberIndices[other];
            int8 lastMember = self.members[length(self)-1];
            // overwrite other with the last member and remove last member
            self.members[replaceIndex-1] = lastMember;
            self.members.length--;
            // reflect this change in the indices
            self.memberIndices[lastMember] = replaceIndex;
            delete self.memberIndices[other];
        }
    }
","    function insert(int8Set storage self, int8 other) {
        if (!contains(self, other)) {
            self.members.push(other);
            self.memberIndices[other] = length(self);
        }
    }
","0x4e61847e3b0c5786e81c8cd477c4af76b5f7098f/Sets.sol:Sets:remove(Sets:int8Set,int8)","0x4e61847e3b0c5786e81c8cd477c4af76b5f7098f/Sets.sol:Sets:insert(Sets:int8Set,int8)",0.5,1,1,0
"    function zecId() public constant returns (uint8) {
        return uint8(Currency.ZEC);
    }
","    function isSaleOver() public constant returns (bool) {
        return getNow() > endTime;
    }
",0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:zecId(),0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:isSaleOver(),0.0,1,1,0
"    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) revert();           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows
        if (frozenAccount[msg.sender]) revert();                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
","    function buy() payable {
        if(isSelling == false) revert();
        uint amount = msg.value * buyRate;                  // calculates the amount
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[owner] -= amount;                         // subtracts amount from seller's balance
        Transfer(owner, msg.sender, amount);                // execute an event reflecting the change
    }
","0x8A99ED8a1b204903Ee46e733f2c1286F6d20b177/FujintoToken.sol:FujintoToken:transfer(address,uint256)",0x8A99ED8a1b204903Ee46e733f2c1286F6d20b177/FujintoToken.sol:FujintoToken:buy(),0.08333333333333333,1,1,0
"  modifier onlyOwner {
    require(msg.sender == owner);
     _;
  }
","  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {
    require(_value <= allowed[_from][msg.sender]);
    require (_value <= balances[_from]);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
",0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:onlyOwner(),"0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:transferFrom(address,address,uint256)",0.001422475106685633,1,1,0
"    function addTrader(address _trader) public onlyOwner {
        traders[_trader] = true;
    }
","    function tokenURI() external view returns (string) {
        return tokenURI_;
    }
",0x1f1625cfb65e968496afe3379d14fd28eb6be917/Cake.sol:Cake:addTrader(address),0x1f1625cfb65e968496afe3379d14fd28eb6be917/Cake.sol:Cake:tokenURI(),0.5,1,1,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x7f58a73fdc40a5be5a65b3462d4bff37ad97adcd/DistributeTokens.sol:Ownable:onlyOwner(),0x7f58a73fdc40a5be5a65b3462d4bff37ad97adcd/DistributeTokens.sol:Ownable:transferOwnership(address),0.3750592697961119,1,1,0
"   function approve (address _spender, uint256 _value) returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    emit Approval (msg.sender, _spender, _value);
    return true;
  }
","  function balanceOf(address _owner) constant returns (uint256 balance) {
    return accounts [_owner];
  }
","0x0b39295cbcbc798fd726d5ddf329e53cf4bdee6d/IHODLToken.sol:AbstractToken:approve(address,uint256)",0x0b39295cbcbc798fd726d5ddf329e53cf4bdee6d/IHODLToken.sol:AbstractToken:balanceOf(address),0.016577540106951873,1,1,0
"  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        throw;
    }
    _;
  }
","  modifier onlyReleaseAgent() {
    if(msg.sender != releaseAgent) {
        throw;
    }
    _;
  }
",0x4dfD2a190EcE60E12977942c858A70644e4b18dD/CrowdsaleTokenExt.sol:ReleasableToken:inReleaseState(bool),0x4dfD2a190EcE60E12977942c858A70644e4b18dD/CrowdsaleTokenExt.sol:ReleasableToken:onlyReleaseAgent(),1.0,5,5,1
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        remaining = allowed[_owner][_spender];
    }
","    function isNotContract(address _addr) private view returns (bool) {
        uint length;
        assembly {
        /* retrieve the size of the code on target address, this needs assembly */
        length := extcodesize(_addr)
        }
        return (length == 0);
    }
","0x1d8f2e2dcb8dc87a7befe662a11a8e5895abfb1f/BTC2.sol:BTC2:allowance(address,address)",0x1d8f2e2dcb8dc87a7befe662a11a8e5895abfb1f/BTC2.sol:BTC2:isNotContract(address),0.8,1,1,0
"    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function stra2cbor(string[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[2])",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:stra2cbor(string[]),0.8,1,1,0
"    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","    function sell(uint256 amount) public {
		require(sellPrice >=0);  // check if sellprice is greater than 0
        require(this.balance >= amount/sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, owner, amount);              // makes the transfers
        msg.sender.transfer(amount / sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
","0x8b98f64c83147e498a0f66dc071348d3daeee051/MyAdvancedToken.sol:MyAdvancedToken:mintToken(address,uint256)",0x8b98f64c83147e498a0f66dc071348d3daeee051/MyAdvancedToken.sol:MyAdvancedToken:sell(uint256),0.0,1,1,0
"    modifier onlyRegisteredProvider(){
        if (!providerRegistry[msg.sender]) throw;
        _;
    }
","    function cancelSubscriptionOffer(uint offerId) public returns (bool) {
        Subscription storage offer = subscriptions[offerId];
        assert (_isOffer(offer));
        assert (offer.transferTo == msg.sender || owner == msg.sender); //only service provider or platform owner is allowed to cancel the offer
        if (offer.expireOn>now){
            offer.expireOn = now;
            OfferCanceled(offerId, msg.sender);
            return true;
        }
        if (isContract(msg.sender)) { return false; }
        else { throw; }
    }
",0x7a7bd6aead42b852fa7949c1e167bad5eff78415/SubscriptionModuleImpl.sol:SubscriptionModuleImpl:onlyRegisteredProvider(),0x7a7bd6aead42b852fa7949c1e167bad5eff78415/SubscriptionModuleImpl.sol:SubscriptionModuleImpl:cancelSubscriptionOffer(uint256),0.0,1,1,0
"    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {

        // Only allow transfer once unlocked
        // Once it is unlocked, it is unlocked forever and no one can lock again
        require(unlocked);

        if (isContract(_to)) {
            if (balanceOf(msg.sender) < _value) {
                revert();
            }
            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
            balances[_to] = safeAdd(balanceOf(_to), _value);
            ContractReceiver receiver = ContractReceiver(_to);
            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
            Transfer(msg.sender, _to, _value, _data);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function Pharamore() public {

        // Security check in case EVM has future flaw or exploit to call constructor multiple times
        // Ensure token gets created once only
        require(tokenCreated == false);
        tokenCreated = true;

        owner = msg.sender;
        balances[owner] = totalSupply;

        // Final sanity check to ensure owner balance is greater than zero
        require(balances[owner] > 0);
    }
","0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:transfer(address,uint256,bytes,string)",0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:Pharamore(),0.2727272727272727,1,1,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x1f24dbc4140d74eec3d15644f5e28da66960dab9/Controller.sol:Ownable:onlyOwner(),0x1f24dbc4140d74eec3d15644f5e28da66960dab9/Controller.sol:Ownable:Ownable(),0.4556661925082978,1,2,0
"    function IncentToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }
","    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
",0x3ff8c78e266395D08f41Ef1631391f0050D48081/WavesEthereumSwap.sol:IncentToken:IncentToken(),"0x3ff8c78e266395D08f41Ef1631391f0050D48081/WavesEthereumSwap.sol:IncentToken:approve(address,uint256)",0.6,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value > 0);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
","    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }
","0x6c34e27bdaf41ca4cced04d0d2bc8d83eaefd5fe/ROKToken.sol:TokenERC20:transferFrom(address,address,uint256)",0x6c34e27bdaf41ca4cced04d0d2bc8d83eaefd5fe/ROKToken.sol:TokenERC20:balanceOf(address),0.03664921465968586,1,2,0
"    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } 
        else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:StandardToken:decreaseApproval(address,uint256)","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:StandardToken:allowance(address,address)",0.9477434679334916,5,5,1
"    function setTransferStatus (uint status) public  onlyOwner                 // Set transfer status
    {
        allowTransferToken = status;
    }   
","    function sellOffline(address rec_address,uint256 token_amount) public onlyOwner 
    {
        if (remaining > 0)
        {
            uint finalTokens =  (token_amount  * (10 ** 18));              
            if(finalTokens < remaining)
                {
                    remaining = remaining - finalTokens;
                    _transfer(owner,rec_address, finalTokens);    
                    TransferSell(owner, rec_address, finalTokens,'Offline');
                }
            else
                {
                    revert();
                }
        }
        else
        {
            revert();
        }        
    }
",0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:setTransferStatus(uint256),"0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:sellOffline(address,uint256)",1.0,5,5,1
"    function owned() public{
        owner = msg.sender;
    }
","    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
",0x6a47cdde561a27dffc6ebc70d368e2e10e9c468c/JPPreICO.sol:owned:owned(),0x6a47cdde561a27dffc6ebc70d368e2e10e9c468c/JPPreICO.sol:owned:transferOwnership(address),0.7576687116564417,2,2,0
"    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return data.allowed[tokenOwner][spender];
    }
","    function transferable() public view returns (bool) {
        return data.transferable;
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:allowance(address,address)",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:transferable(),1.0,5,5,1
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;

        bytes32 sigr;
        bytes32 sigs;

        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }


        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(keccak256(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(keccak256(pubkey)) == signer);
        }
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setProof(bytes1),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:verifySig(bytes32,bytes,bytes)",1.0,5,5,1
"    function BlockChainZB(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","0x7c540fd1f0da5dab21024de3f3748625ac022a98/BlockChainZB.sol:BlockChainZB:BlockChainZB(uint256,string,string)","0x7c540fd1f0da5dab21024de3f3748625ac022a98/BlockChainZB.sol:BlockChainZB:approve(address,uint256)",0.045454545454545456,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x5e99ff20c437adbb0f503f0b33ba8aa0f9661a9d/DeveryPresale.sol:ERC20Token:allowance(address,address)",0x5e99ff20c437adbb0f503f0b33ba8aa0f9661a9d/DeveryPresale.sol:ERC20Token:balanceOf(address),0.9696048632218844,5,5,1
"    function totalSupply() constant returns (uint256 _totalSupply) {
        return totalSupply;
    }
","    function balanceOf(address _owner) constant returns (uint balance) {
        return balances[_owner];
    }
",0x3F937666359555684192d7445D995fF358F02E21/SDD_Erc223Token.sol:SDD_Erc223Token:totalSupply(),0x3F937666359555684192d7445D995fF358F02E21/SDD_Erc223Token.sol:SDD_Erc223Token:balanceOf(address),0.5842696629213483,2,2,0
"  function _burn(address _owner, uint256 _tokenId) internal {
    clearApproval(_owner, _tokenId);
    removeTokenFrom(_owner, _tokenId);
    emit Transfer(_owner, address(0), _tokenId);
  }
","  function approve(address _to, uint256 _tokenId) public {
    address owner = ownerOf(_tokenId);
    require(_to != owner);
    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));

    if (getApproved(_tokenId) != address(0) || _to != address(0)) {
      tokenApprovals[_tokenId] = _to;
      emit Approval(owner, _to, _tokenId);
    }
  }
","0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721BasicToken:_burn(address,uint256)","0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721BasicToken:approve(address,uint256)",0.6666666666666666,2,2,0
"    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2)
    payable
    external
    returns (bytes32 _id)
    {
        return query2(_timestamp, _datasource, _arg1, _arg2, 200000);
    }
","    function addDSource(string dsname, byte proofType, uint multiplier)
    public
    {
        onlyadmin();
        bytes32 dsname_hash = sha3(dsname, proofType);
        dsources[dsources.length++] = dsname_hash;
        price_multiplier[dsname_hash] = multiplier;
    }
","0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:query2(uint256,string,string,string)","0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:addDSource(string,bytes1,uint256)",1.0,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x6af777c884f426b7a2f2d71cd8fff12e07762171/MajestyAssetsJunction.sol:MajestyAssetsJunction:transferAnyERC20Token(address,uint256)",0x6af777c884f426b7a2f2d71cd8fff12e07762171/MajestyAssetsJunction.sol:MajestyAssetsJunction:totalSupply(),0.8585209003215434,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value)
    returns (bool success) {
	require(!frozenAccount[_from]);
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
","  function setOwner(address _newOwner) {
    require (msg.sender == owner);

    owner = _newOwner;
  }
","0x0bbe475e18aca9c34026efe5393c90ac08c23183/SRGToken.sol:SRGToken:transferFrom(address,address,uint256)",0x0bbe475e18aca9c34026efe5393c90ac08c23183/SRGToken.sol:SRGToken:setOwner(address),0.9,2,2,0
"  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x7f7f160b56291ec333734c9718af71f0af009f52/HODL_ICO.sol:Pausable:pause(),0x7f7f160b56291ec333734c9718af71f0af009f52/HODL_ICO.sol:Pausable:whenNotPaused(),0.991150442477876,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);                               // Prevent transfer to 0x0 address.
        require(balanceOf[_from] >= _value);               // Check if the sender has enough.
        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows.
        require(!frozenAccount[_from]);                    // Check if sender is frozen.
        require(!frozenAccount[_to]);                      // Check if recipient is frozen.
		balanceOf[_from] -= _value; // Subtracts _value tokens from the sender.
        balanceOf[_to]   += _value; // Adds the same amount to the recipient.
        _updateTokensAvailable(balanceOf[this]); // Update the balance of tokens available if necessary.
        Transfer(_from, _to, _value); // Notifies the blockchain about the transfer.
    }
","    function refillTokens(uint256 _value) public onlyOwner{
        // Owner sends tokens to the contract.
        _transfer(msg.sender, this, _value);
    }
","0x4f800a45631f2c74ef2d37201adf417b3b90ad3c/HormitechToken.sol:HormitechToken:_transfer(address,address,uint256)",0x4f800a45631f2c74ef2d37201adf417b3b90ad3c/HormitechToken.sol:HormitechToken:refillTokens(uint256),0.00909090909090909,2,2,0
"  function add(uint _a, uint _b) internal pure returns (uint c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
","  function sub(uint _a, uint _b) internal pure returns (uint) {
    assert(_b <= _a);
    return _a - _b;
  }
","0x7d4d05abcadbdbf877c5cd5eb9dac6ddaa17ff89/BECCToken.sol:SafeMath:add(uint256,uint256)","0x7d4d05abcadbdbf877c5cd5eb9dac6ddaa17ff89/BECCToken.sol:SafeMath:sub(uint256,uint256)",0.9438202247191012,5,5,1
"    function mintForCreatorsPool(uint256 _value) public {
        require(isCreatorsPool[msg.sender]);
        require(_value != 0);
        creatorsPoolMintQuota = creatorsPoolMintQuota.sub(_value);
        supply = supply.add(_value);
        balances[msg.sender] = balances[msg.sender].add(_value);
        Transfer(0x0, msg.sender, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        _transfer(_from, _to, _value);
        return true;
    }
",0x02f61fd266da6e8b102d4121f5ce7b992640cf98/LikeCoin.sol:LikeCoin:mintForCreatorsPool(uint256),"0x02f61fd266da6e8b102d4121f5ce7b992640cf98/LikeCoin.sol:LikeCoin:transferFrom(address,address,uint256)",0.0,2,2,0
"    function freezeAccount(address target, bool freeze) public{
        require(msg.sender == owner);
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function City(uint256 initialSupply, string tokenName, string tokenSymbol) public{
        owner = msg.sender;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
","0x08a2246DCB48DB6a5a9e1F6bC082752FCEDdD106/City.sol:City:freezeAccount(address,bool)","0x08a2246DCB48DB6a5a9e1F6bC082752FCEDdD106/City.sol:City:City(uint256,string,string)",0.0,2,2,0
"  function externalPurchase(address _beneficiary, string _currency, uint256 _value, uint256 _amount, uint256 _txid) public {
    require(owner != address(0));
    require(msg.sender == owner); //  Only owner can issue tokens in exchange for external payment
    require(isICOActive() || postICOSale);
    require(token.whitelist(_beneficiary));

    require(_amount >= minimumPurchase);

    // Cannot exceed total allocated supply for the ICO
    // reverting allows a smaller purchase to pass in the future, up to the icoTokenCap
    if (isICOActive() && token.totalSupply().add(_amount) > icoTokenCap) revert();

    // Update total amount raised from purchases via external sales
    externalFundsRaised[currencyToHash(_currency)] = externalFundsRaised[currencyToHash(_currency)].add(_value);

    // Issue the tokens
    token.mint(_beneficiary, _amount); // will revert if tokenCap is reached
    emit ExternalTokenPurchase(_beneficiary, _currency, _value, _amount, _txid);
  }
","  function isICOActive() public view returns(bool) {
    return icoStart != 0 && now <= icoStart.add(icoDuration);
  }
","0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreCrowdsale:externalPurchase(address,string,uint256,uint256,uint256)",0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreCrowdsale:isICOActive(),1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function ControlledToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        )  {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }
","0x2ad180cbaffbc97237f572148fc1b283b68d8861/IZXToken.sol:ControlledToken:allowance(address,address)","0x2ad180cbaffbc97237f572148fc1b283b68d8861/IZXToken.sol:ControlledToken:ControlledToken(uint256,string,uint8,string)",0.009353741496598641,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x7e4e0f9b3a5272314ee037a81a09553470801457/BBBB.sol:BBBB:transfer(address,uint256)","0x7e4e0f9b3a5272314ee037a81a09553470801457/BBBB.sol:BBBB:burnFrom(address,uint256)",0.7829099307159353,2,2,0
"	function	getData_1	()	public	constant	returns	(	string	)	{	
		return	inData_1	;							
	}										
","		function	setDepositary_function_control	(	uint256	newDepositary_function_control	)	public	onlyOwner	{	
			Depositary_function_control	=	newDepositary_function_control	;					
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_1(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setDepositary_function_control(uint256),0.0,2,2,0
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x4c3838477114171d73dc677f808415acc5bbdd05/PGGToken.sol:SafeMath:mul(uint256,uint256)","0x4c3838477114171d73dc677f808415acc5bbdd05/PGGToken.sol:SafeMath:add(uint256,uint256)",0.9272131147540984,2,2,0
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x5dbbf0451f49ccee96a4ab9a530094b35e377f1b/GILLIONTOKEN.sol:GILLIONTOKEN:transfer(address,uint256)","0x5dbbf0451f49ccee96a4ab9a530094b35e377f1b/GILLIONTOKEN.sol:GILLIONTOKEN:allowance(address,address)",0.9881422924901184,5,5,1
"  constructor() public DSAuth() {
    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;
    owner = controllerAddress;
    LogSetOwner(controllerAddress);*/
  }
","  function subCoinBalance(address addr, uint amount) public auth returns (bool) {
    coinBalances[addr] = sub(coinBalances[addr], amount);

    return true;
  }
",0x6cd30c3964d04adcfc6a2a3b6031e21d94d3d91f/IkuraAuthority.sol:IkuraStorage:constructor(),"0x6cd30c3964d04adcfc6a2a3b6031e21d94d3d91f/IkuraAuthority.sol:IkuraStorage:subCoinBalance(address,uint256)",0.0,2,2,0
"   function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }
","0x0c7992d46f6b01e6cfcd26e7e2c45157d250ba48/WFC.sol:WFC:transfer(address,uint256)",0x0c7992d46f6b01e6cfcd26e7e2c45157d250ba48/WFC.sol:WFC:balanceOf(address),0.7931034482758621,2,2,0
"    function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
        require(targets.length > 0);

        for (uint j = 0; j < targets.length; j++) {
            require(targets[j] != 0x0);
            frozenAccount[targets[j]] = isFrozen;
            FrozenFunds(targets[j], isFrozen);
        }
    }
","    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }
","0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:freezeAccounts(address[],bool)","0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:transfer(address,uint256)",0.9411764705882352,5,5,1
"    function devFee(uint256 amount) public view returns(uint256){
        return SafeMath.div(SafeMath.mul(amount,4),100);
    }
","    function getFreeFalcon() public payable{
        require(initialized);
        require(msg.value==0.001 ether); //similar to mining fee, prevents bots
        ceoAddress.transfer(msg.value); //falconmaster gets this entrance fee
        require(hatcheryFalcon[msg.sender]==0);
        lastHatch[msg.sender]=now;
        hatcheryFalcon[msg.sender]=STARTING_FALCON;
    }
",0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:FalconFarmer:devFee(uint256),0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:FalconFarmer:getFreeFalcon(),0.18181818181818185,2,2,0
"    function owned() public {
        owner = msg.sender;
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
",0x7c3e0b97c050b32fc1127096537b6c77230d21fe/RoyalPanties.sol:owned:owned(),0x7c3e0b97c050b32fc1127096537b6c77230d21fe/RoyalPanties.sol:owned:transferOwnership(address),0.7576687116564417,2,2,0
"    function div(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a / b;
        return c;
    }
","    function mul(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x5a278520af82ecd29ab6ad6f132c7fd6865d6454/SupremeCoin.sol:SafeMath:div(uint256,uint256)","0x5a278520af82ecd29ab6ad6f132c7fd6865d6454/SupremeCoin.sol:SafeMath:mul(uint256,uint256)",0.99009900990099,5,5,1
"    function len(slice self) internal returns (uint) {
        // Starting at ptr-31 means the LSB will be the byte we care about
        var ptr = self._ptr - 31;
        var end = ptr + self._len;
        for (uint len = 0; ptr < end; len++) {
            uint8 b;
            assembly { b := and(mload(ptr), 0xFF) }
            if (b < 0x80) {
                ptr += 1;
            } else if(b < 0xE0) {
                ptr += 2;
            } else if(b < 0xF0) {
                ptr += 3;
            } else if(b < 0xF8) {
                ptr += 4;
            } else if(b < 0xFC) {
                ptr += 5;
            } else {
                ptr += 6;
            }
        }
        return len;
    }
","    function contains(slice self, slice needle) internal returns (bool) {
        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:len(strings:slice),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:contains(strings:slice,strings:slice)",1.0,5,5,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x2e127da05768e3e1609569dc5fa2494e4e97d1cb/PrinceberkToken.sol:PrinceberkToken:approve(address,uint256)","0x2e127da05768e3e1609569dc5fa2494e4e97d1cb/PrinceberkToken.sol:PrinceberkToken:allowance(address,address)",0.9777777777777776,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x6ffeb92890ca49eec56425baf2e38e82deab79b8/EthereumEmerald.sol:EthereumEmerald:approveAndCall(address,uint256,bytes)","0x6ffeb92890ca49eec56425baf2e38e82deab79b8/EthereumEmerald.sol:EthereumEmerald:transferFrom(address,address,uint256)",0.7744107744107744,2,2,0
"  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    require(_to != ownerOf(_tokenId));
    require(ownerOf(_tokenId) == _from);

    clearApproval(_from, _tokenId);
    removeToken(_from, _tokenId);
    addToken(_to, _tokenId);
    Transfer(_from, _to, _tokenId);
  }
","  function ownerOf(uint256 _tokenId) public view returns (address) {
    address owner = tokenOwner[_tokenId];
    require(owner != address(0));
    return owner;
  }
","0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:ERC721Token:clearApprovalAndTransfer(address,address,uint256)",0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:ERC721Token:ownerOf(uint256),0.6,2,2,0
"    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        require(_value <= allowed[_from][msg.sender]);
        require(_value <= balances[_from]);
        require(vestingEnded(_from));

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
","0x4AFEa0F1252335E5E6be870139de87725e16560b/NatminToken.sol:NatminToken:allowance(address,address)","0x4AFEa0F1252335E5E6be870139de87725e16560b/NatminToken.sol:NatminToken:transferFrom(address,address,uint256)",0.29549319727891155,2,2,0
"    function SIPCToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","0x2a3ba8a83bbbc3c3c9ea8c786b8e0d536d36919a/SIPCToken.sol:SIPCToken:SIPCToken(uint256,string,string)","0x2a3ba8a83bbbc3c3c9ea8c786b8e0d536d36919a/SIPCToken.sol:SIPCToken:setPrices(uint256,uint256)",0.5166666666666667,2,2,0
"    function mul(uint a, uint b) internal pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }
","    function div(uint a, uint b) internal pure returns (uint c) {

        require(b > 0);

        c = a / b;

    }
","0x7bb09bc8ade747178e95b1d035ecbeebbb18cfee/CryptoValleyAlliance.sol:SafeMath:mul(uint256,uint256)","0x7bb09bc8ade747178e95b1d035ecbeebbb18cfee/CryptoValleyAlliance.sol:SafeMath:div(uint256,uint256)",0.7459584295612008,2,2,0
"    modifier onlyOwner()  {
        require(msg.sender == owner);
        _;
    }
","    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x2f05e1c76549f09670fe0a163fc6332caab6c022/USDBCoin.sol:Ownable:onlyOwner(),0x2f05e1c76549f09670fe0a163fc6332caab6c022/USDBCoin.sol:Ownable:transferOwnership(address),0.15979137031768612,2,2,0
"    function transfer(address _to, uint256 _value) active returns (bool success) {
        require(_to != address(0));
        require(_value > 0);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function addToActiveGroup(address a) onlyAdmin {
        activeGroup[a] = true;
    }
","0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:transfer(address,uint256)",0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:addToActiveGroup(address),0.0,2,2,0
"  function delAdmin(address addr)
    public
    onlyAdmin
  {
    removeRole(addr, ROLE_ADMIN);
  }
","  function computeTokens(uint256 _cents) public view returns (uint256) {
    uint256 tokens = _cents.mul(10 ** 18).div(tokenPriceInCents);
    (uint256 bonusPercent, ) = computeBonuses(_cents);
    uint256 bonusTokens = tokens.mul(bonusPercent).div(100);
    if (_cents >= minDepositInCents) {
      return tokens.add(bonusTokens);
    }
  }
",0x5ac3c4518ebaec379f9dd0e60e4b72f1eb432592/VeraCrowdsale.sol:VeraCrowdsale:delAdmin(address),0x5ac3c4518ebaec379f9dd0e60e4b72f1eb432592/VeraCrowdsale.sol:VeraCrowdsale:computeTokens(uint256),0.5,2,2,0
"  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x2a5851fa4f8c015f7c563c22fde9c2d862dea954/XRT.sol:SafeMath:safeSub(uint256,uint256)","0x2a5851fa4f8c015f7c563c22fde9c2d862dea954/XRT.sol:SafeMath:safeMul(uint256,uint256)",0.9572649572649572,5,5,1
"    function setAssetStates() internal {
        // Asset States
        EntityStates[""__IGNORED__""]     = 0;
        EntityStates[""NEW""]             = 1;
        // Funding Stage States
        RecordStates[""__IGNORED__""]     = 0;
    }
","    modifier requireSettingsApplied() {
        require(_settingsApplied == true);
        _;
    }
",0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:setAssetStates(),0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:requireSettingsApplied(),1.0,5,5,1
"  function complete_sell_exchange(uint256 _amount_give) private {

    uint256 amount_get_ = get_amount_sell(_amount_give);


    // this is the amount that is transferred to the seller -minus the commision ANYWAY (even if admin_commission_activated is False) 
    uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_);
    
    transferTokensThroughProxyToContract(msg.sender,this,_amount_give);


    // the commission is transferred to admin only if admin_commission_activated, but the commission is subtracted anyway
    if(admin_commission_activated) {
      transferETHFromContract(msg.sender,amount_get_minus_commission_);

      uint256 admin_commission_ = amount_get_ - amount_get_minus_commission_;

      transferETHFromContract(admin, admin_commission_);     

    }
    else {
      transferETHFromContract(msg.sender,amount_get_);
    }
  }
","  function seed_eth() public payable only_admin {

    require(!eth_is_seeded);

    require(msg.value == eth_seed_amount);
 
    set_eth_as_seeded();

    deposit_eth(); 

  }
",0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:complete_sell_exchange(uint256),0x7ca03c6a5af86d037c83d2e19e65841efea69b55/TokenLiquidityContract.sol:TokenLiquidityContract:seed_eth(),0.0,2,2,0
"    function sell(uint256 amount) public {
        uint256 ethAmount = amount.div(sellExchangeRate);
        require(!stopSell);
        require(this.balance >= ethAmount);      
        require(ethAmount >= 1);      

        require(balances[msg.sender] >= amount);                 
        require(balances[owner] + amount > balances[owner]);       
        require(!frozenAccount[msg.sender]);                       
        require(!_isUserInternalLock());                                          

        balances[owner] = balances[owner].add(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);

        soldSupply = soldSupply.sub(amount);
        sellSupply = sellSupply.add(amount);

        Transfer(msg.sender, owner, amount);

        msg.sender.transfer(ethAmount); 
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (!isOwner()) {
            require (allowTransfers);
            require(!frozenAccount[_from]);                                         
            require(!frozenAccount[_to]);                                        
            require(!_isUserInternalLock());                                       
        }
        return super.transferFrom(_from, _to, _value);
    }
",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:sell(uint256),"0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:transferFrom(address,address,uint256)",1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x0b5cba1bc5ec084e82fadc4e2c3a43a94660b6c4/GlobalBusinessSystem.sol:SafeMath:mul(uint256,uint256)","0x0b5cba1bc5ec084e82fadc4e2c3a43a94660b6c4/GlobalBusinessSystem.sol:SafeMath:add(uint256,uint256)",0.9272131147540984,2,2,0
"	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}
","	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}
","0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:setImageDescriptor(uint256,uint16)",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:deleteImage(uint256),1.0,5,5,1
"    function setProofType(byte _proofType)
    external
    {
        addr_proofType[msg.sender] = _proofType;
    }
","    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit)
    payable
    public
    returns (bytes32 _id)
    {
        costs(_datasource, _gaslimit);
    	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:setProofType(bytes1),"0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:query2(uint256,string,string,string,uint256)",1.0,5,5,1
"    function sell(uint256 amount) public {
        uint256 ethAmount = amount.div(sellExchangeRate);
        require(!stopSell);
        require(this.balance >= ethAmount);      
        require(ethAmount >= 1);      

        require(balances[msg.sender] >= amount);                 
        require(balances[owner] + amount > balances[owner]);       
        require(!frozenAccount[msg.sender]);                       
        require(!_isUserInternalLock());                                          

        balances[owner] = balances[owner].add(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);

        soldSupply = soldSupply.sub(amount);
        sellSupply = sellSupply.add(amount);

        Transfer(msg.sender, owner, amount);

        msg.sender.transfer(ethAmount); 
    }
","    function setSymbol(string _symbol) onlyOwner public {
        symbol = _symbol;
    }
",0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:sell(uint256),0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:setSymbol(string),0.0,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4d0CdAD789cF3F4b770C5B86dCED6D198bF69EaE/HyperToken.sol:StandardToken:transferFrom(address,address,uint256)","0x4d0CdAD789cF3F4b770C5B86dCED6D198bF69EaE/HyperToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8544474393530997,2,2,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x3ffc7b7fa29462677d8bada5af4eb94cf76dd88a/ICOStartSale.sol:SafeMath:div(uint256,uint256)","0x3ffc7b7fa29462677d8bada5af4eb94cf76dd88a/ICOStartSale.sol:SafeMath:mul(uint256,uint256)",0.9870525514089872,5,5,1
"	function enableBonus() {
		require(msg.sender == owner); 
		bonusAllowed = true;
	}
","	function disableBonus() {
		require(msg.sender == owner);
		bonusAllowed = false;
	}   
",0x5ca5c12893A50Cf2561C218f9d44825c0083DaB6/ETHACE.sol:ETHACE:enableBonus(),0x5ca5c12893A50Cf2561C218f9d44825c0083DaB6/ETHACE.sol:ETHACE:disableBonus(),1.0,5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2/Poge.sol:Poge:burnFrom(address,uint256)",0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2/Poge.sol:Poge:burn(uint256),1.0,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function BergCoin() public {
        symbol = ""BERG"";
        name = ""BergCoin"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0x6319d9F67035c273DC5508De67BB5458495B6169] = _totalSupply;
        Transfer(address(0), 0x6319d9F67035c273DC5508De67BB5458495B6169, _totalSupply);
    }
","0x0e0f0a5e118d2e96ac65b819db3e089e089269c4/BergCoin.sol:BergCoin:allowance(address,address)",0x0e0f0a5e118d2e96ac65b819db3e089e089269c4/BergCoin.sol:BergCoin:BergCoin(),0.2917933130699088,2,2,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x04b602c678efac6023d64faa53879fb3fbdfb236/Bevium.sol:SafeMath:add(uint256,uint256)","0x04b602c678efac6023d64faa53879fb3fbdfb236/Bevium.sol:SafeMath:div(uint256,uint256)",0.20450704225352112,2,2,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x04a8371d32148c1d28b35a84af105838a0a18bdc/T3SVToken.sol:SafeMath:sub(uint256,uint256)","0x04a8371d32148c1d28b35a84af105838a0a18bdc/T3SVToken.sol:SafeMath:div(uint256,uint256)",0.20488081725312146,2,2,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x5c2978a171033a19c1a455c84875f3609dab0a7e/ETYCSale.sol:StandardToken:decreaseApproval(address,uint256)","0x5c2978a171033a19c1a455c84875f3609dab0a7e/ETYCSale.sol:StandardToken:allowance(address,address)",0.9466192170818504,5,5,1
"    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
      
    }
","    function BOXICOIN() {

         initialSupply = 10000000000;
        name =""BOXICOIN"";
        decimals = 2;
        symbol = ""BXC"";
        
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
                                   
    }
","0x4F09Ea83feeD21ccA65F51A4CAAE1E6D212F5C50/BOXICOIN.sol:BOXICOIN:transfer(address,uint256)",0x4F09Ea83feeD21ccA65F51A4CAAE1E6D212F5C50/BOXICOIN.sol:BOXICOIN:BOXICOIN(),0.8518518518518519,2,2,0
"  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
","0x2a139536228b9CEa9c6e4E184F6a8F00937384e9/ICOTokenExtended.sol:PausableToken:transfer(address,uint256)","0x2a139536228b9CEa9c6e4E184F6a8F00937384e9/ICOTokenExtended.sol:PausableToken:approve(address,uint256)",0.9007092198581559,2,2,0
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x3f9862ad3456d08ac8b984422dfff1e48d3debe1/CelticsCoin.sol:CelticsCoin:approveAndCall(address,uint256,bytes)","0x3f9862ad3456d08ac8b984422dfff1e48d3debe1/CelticsCoin.sol:CelticsCoin:allowance(address,address)",1.0,5,5,1
"    function add(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function sub(uint256 a, uint256 b) internal constant returns(uint256) {
        assert(b <= a);
        return a - b;
    }
","0x4dc14b53712beebade9576345d541ad17dddb2d0/GoldEthereum.sol:SafeMath:add(uint256,uint256)","0x4dc14b53712beebade9576345d541ad17dddb2d0/GoldEthereum.sol:SafeMath:sub(uint256,uint256)",0.9747191011235956,5,5,1
"    function getFreeBanker() public payable{
        require(initialized);
        require(msg.value==0.001 ether); //similar to mining fee, prevents bots
        ceoAddress.transfer(msg.value); //bankermaster gets this entrance fee
        require(hatcheryBanker[msg.sender]==0);
        lastHatch[msg.sender]=now;
        hatcheryBanker[msg.sender]=STARTING_BANKER;
    }
","    function getBalance() public view returns(uint256){
        return this.balance;
    }
",0x6cd6215a23890630f39400ce37e3cb5d31304b8c/BankerFarmer.sol:BankerFarmer:getFreeBanker(),0x6cd6215a23890630f39400ce37e3cb5d31304b8c/BankerFarmer.sol:BankerFarmer:getBalance(),0.75,2,2,0
"    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
","    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
","0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:adminClaimAirdropMultiple(address[],uint256)","0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:adminClaimAirdrop(address,uint256)",1.0,5,5,1
"	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i < _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}
","	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}
",0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpPriceStorage:appendPricePoints(uint64[]),0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpPriceStorage:setPricePoints(uint64[]),1.0,5,5,1
"    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
",0x2af6139c39c05e0597c0ac12c60b303c38aa69e7/HIT.sol:HIT:canDistr(),"0x2af6139c39c05e0597c0ac12c60b303c38aa69e7/HIT.sol:HIT:getTokenBalance(address,address)",0.8059701492537313,2,2,0
"    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_cbAddress(),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[3],uint256)",1.0,5,5,1
"    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);
    }
","    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash) {
        return data.signedApproveAndCallHash(tokenOwner, spender, tokens, _data, fee, nonce);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedTransferFromCheck(address,address,address,uint256,uint256,uint256,bytes,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedApproveAndCallHash(address,address,uint256,bytes,uint256,uint256)",1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x2e402fdb7259a4919aca0b06610896bf1f1a72a3/GucciCoin.sol:StandardToken:transfer(address,uint256)","0x2e402fdb7259a4919aca0b06610896bf1f1a72a3/GucciCoin.sol:StandardToken:allowance(address,address)",0.9776632302405498,5,5,1
"    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","0x00b9034425e357bf61b4abeb22299ec4a62c725b/Essence.sol:Essence:mintToken(address,uint256)","0x00b9034425e357bf61b4abeb22299ec4a62c725b/Essence.sol:Essence:freezeAccount(address,bool)",0.8166666666666667,2,2,0
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x2af6139c39c05e0597c0ac12c60b303c38aa69e7/HIT.sol:HIT:onlyWhitelist(),0x2af6139c39c05e0597c0ac12c60b303c38aa69e7/HIT.sol:HIT:onlyOwner(),0.9444444444444444,5,5,1
"    function transfer(address _to, uint256 _value) public returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }
","0x0f8c94e34de4ccd378ed53d5622039d39f74fded/Faucet.sol:StandardToken:transfer(address,uint256)","0x0f8c94e34de4ccd378ed53d5622039d39f74fded/Faucet.sol:StandardToken:transferFrom(address,address,uint256)",0.5402298850574713,2,2,0
"    function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) {
        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress);
        return uint8(genNum % (maxRandom - min + 1)+min);
    }
","    function safeSubtract(uint x, uint y) pure internal returns(uint) {
      assert(x >= y);
      uint z = x - y;
      return z;
    }
","0x6d2e76213615925c5fc436565b5ee788ee0e86dc/AngelCardData.sol:SafeMath:getRandomNumber(uint16,uint8,address)","0x6d2e76213615925c5fc436565b5ee788ee0e86dc/AngelCardData.sol:SafeMath:safeSubtract(uint256,uint256)",1.0,5,5,1
"    constructor(string _name, string _symbol, uint _totalSupply) public {
		name = _name;
		symbol = _symbol;
		decimals = 18;
		totalSupply = _totalSupply * (10 ** uint256(decimals));
		balances[msg.sender] = totalSupply;
	}
","	function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
		if(balanceOf(msg.sender) < value) revert();

		balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);
		if (isContract(to)) {
            assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
        }
        emit Transfer(msg.sender, to, value, data);
        return true;
	}
","0x1bb2e2e063a58368a592857b0abe8b4a827e5a07/MyToken.sol:MyToken:constructor(string,string,uint256)","0x1bb2e2e063a58368a592857b0abe8b4a827e5a07/MyToken.sol:MyToken:transfer(address,uint256,bytes,string)",0.0,2,2,0
"    function addDSource(string dsname, byte proofType, uint multiplier) onlyadmin {
        bytes32 dsname_hash = sha3(dsname, proofType);
        dsources[dsources.length++] = dsname_hash;
        price_multiplier[dsname_hash] = multiplier;
    }
","    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _args, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return queryN(_timestamp, _datasource, _args, _gaslimit);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:addDSource(string,bytes1,uint256)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN_withGasLimit(uint256,string,bytes,uint256)",1.0,5,5,1
"    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {
        require(_unitAmount > 0);

        totalSupply = totalSupply.add(_unitAmount);
        balanceOf[_to] = balanceOf[_to].add(_unitAmount);
        Mint(_to, _unitAmount);
        Transfer(address(0), _to, _unitAmount);
        return true;
    }
","    function distributeAirdrop(address[] addresses, uint256 amount) public returns (bool) {
        require(amount > 0
                && addresses.length > 0
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        amount = amount.mul(1e8);
        uint256 totalAmount = amount.mul(addresses.length);
        require(balanceOf[msg.sender] >= totalAmount);

        for (uint j = 0; j < addresses.length; j++) {
            require(addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amount);
            Transfer(msg.sender, addresses[j], amount);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:mint(address,uint256)","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:distributeAirdrop(address[],uint256)",0.6875,2,2,0
"    function setStart(uint newStart) onlyOwner {
        start = newStart;
    }
","    function Start() constant returns (uint) {
        return start;
    }
",0x06a18ecf4fb238a47c146c926d3017bd3737364e/DAICO.sol:Crowdsale:setStart(uint256),0x06a18ecf4fb238a47c146c926d3017bd3737364e/DAICO.sol:Crowdsale:Start(),0.3333333333333333,2,2,0
"    function strCompare(string _a, string _b) internal returns (int) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        uint minLength = a.length;
        if (b.length < minLength) minLength = b.length;
        for (uint i = 0; i < minLength; i ++)
            if (a[i] < b[i])
                return -1;
            else if (a[i] > b[i])
                return 1;
        if (a.length < b.length)
            return -1;
        else if (a.length > b.length)
            return 1;
        else
            return 0;
    }
","    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strCompare(string,string)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_setNetworkName(string),0.8,2,2,0
"    function donate()
    isOpenToPublic()
    public 
    payable
    {
        donateToWhale(msg.value);
    }
","   modifier isOpenToPublic()
    {
        require(openToPublic);
        _;
    }
",0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:donate(),0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:isOpenToPublic(),1.0,5,5,1
"    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
","    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
",0x1fBf025AD94ddE79f88732F79966A9A435F2772f/BLITZQUIZ.sol:BLITZQUIZ:StopGame(),"0x1fBf025AD94ddE79f88732F79966A9A435F2772f/BLITZQUIZ.sol:BLITZQUIZ:StartGame(string,string)",0.9333333333333332,5,5,1
"		function	Admin_4				(				
			address	_User_4		,					
			IERC20Token	_Securities_4		,					
			uint256	_Standard_4							
		)									
			public	onlyOwner							
		{									
			User_4		=	_User_4		;			
			Securities_4		=	_Securities_4		;			
			Standard_4		=	_Standard_4		;			
		}									
","		function	instruct_1				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_1.transfer(User_1, Standard_1)			);				
			require(	arg_1 == arg_1_input			);				
			require(	arg_2 == arg_2_input			);				
			require(	arg_3 == arg_3_input			);				
		}									
","0x0f3b5a069c3116cdcb926fc114bd270555a16009/BOT_ELEMENT_2.sol:BOT_ELEMENT_2:Admin_4(address,IERC20Token,uint256)",0x0f3b5a069c3116cdcb926fc114bd270555a16009/BOT_ELEMENT_2.sol:BOT_ELEMENT_2:instruct_1(),0.125,2,2,0
"  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
","  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x5d5f815cc79d3660b3b40817fd39af516c975d53/URAToken.sol:StandardToken:allowance(address,address)","0x5d5f815cc79d3660b3b40817fd39af516c975d53/URAToken.sol:StandardToken:transferFrom(address,address,uint256)",0.3221719457013575,2,2,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function CriptaliaRewards() public {
        symbol = ""CRIPTRE"";
        name = ""CRIPTALIA REWARDS"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[msg.sender] = _totalSupply;
        Transfer(address(0), msg.sender, _totalSupply);
    }
","0x2c821a3ce3b5c0a471862eb63a2ef99a4d285d43/CriptaliaRewards.sol:CriptaliaRewards:transferFrom(address,address,uint256)",0x2c821a3ce3b5c0a471862eb63a2ef99a4d285d43/CriptaliaRewards.sol:CriptaliaRewards:CriptaliaRewards(),0.008620689655172414,2,2,0
"  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4b958074cee6546e29cdb3c43494e7425b85f59c/CareerChainPrivateSale.sol:StandardToken:allowance(address,address)","0x4b958074cee6546e29cdb3c43494e7425b85f59c/CareerChainPrivateSale.sol:StandardToken:increaseApproval(address,uint256)",0.3542986425339367,2,2,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require (now < 1527897540);      // 1st June 2018 11:59PM UTC
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x7e9e431a0b8c4d532c745b1043c7fa29a48d4fba/eosDACToken.sol:eosDACToken:transferFrom(address,address,uint256)","0x7e9e431a0b8c4d532c745b1043c7fa29a48d4fba/eosDACToken.sol:eosDACToken:approve(address,uint256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strConcat(string,string,string,string)",0.8,2,2,0
"    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
","    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getNetworkName(),0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setNetwork(uint8),1.0,5,5,1
"  modifier onlyCFO() {
    require(msg.sender == CFO);
    _;
  }
","  function GeneNuggetsToken() public {}
",0x6c7bbd8b6c32512dd36d8eecdb3ed4429eb8a85d/GeneNuggetsToken.sol:GeneNuggetsToken:onlyCFO(),0x6c7bbd8b6c32512dd36d8eecdb3ed4429eb8a85d/GeneNuggetsToken.sol:GeneNuggetsToken:GeneNuggetsToken(),0.0,2,2,0
"  function setSecondAddressBalance(address _SecondAddressBalance) onlyOwner public {
    SecondAddressBalance = _SecondAddressBalance;
  }
","  function getPlayers() public view returns (address[]) {
    return players;
  }
",0x5caeebfab3cd8655e04692351237efb7462c9d8f/VfSE_Lottery.sol:VfSE_Lottery:setSecondAddressBalance(address),0x5caeebfab3cd8655e04692351237efb7462c9d8f/VfSE_Lottery.sol:VfSE_Lottery:getPlayers(),0.0,2,2,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","     function mint(address wallet, address buyer, uint256 tokenAmount) public onlyOwner {
      require(tokenBalances[wallet] >= tokenAmount);               // checks if it has enough to sell
      tokenBalances[buyer] = tokenBalances[buyer].add(tokenAmount);                  // adds the amount to buyer's balance
      tokenBalances[wallet] = tokenBalances[wallet].sub(tokenAmount);                        // subtracts amount from seller's balance
      Transfer(wallet, buyer, tokenAmount); 
      _totalSupply = _totalSupply.sub(tokenAmount);
    }
","0x1c43535d06b494a1d6cb7cb550f5689161303aaa/HypeRideToken.sol:HypeRideToken:decreaseApproval(address,uint256)","0x1c43535d06b494a1d6cb7cb550f5689161303aaa/HypeRideToken.sol:HypeRideToken:mint(address,address,uint256)",0.0035587188612099642,2,2,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x3bf5f07786b2f52bacc8bc0fbc5d31deee667f67/ChainKey.sol:ChainKey:approve(address,uint256)","0x3bf5f07786b2f52bacc8bc0fbc5d31deee667f67/ChainKey.sol:ChainKey:_transfer(address,address,uint256)",0.733615221987315,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);
    }
","    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];       
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[1],uint256)",1.0,5,5,1
"    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:indexOf(string,string)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:ecrecovery(bytes32,bytes)",0.8,2,2,0
"    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function name() public view returns (string _name) {
        return name;
    }
","0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:transfer(address,uint256,bytes)",0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:name(),0.9444444444444444,5,5,1
"	function pause() external onlyAuthorized {
		paused = true;
	}
","	function unpause() external onlyOwner {
		paused = false;
	}
",0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpBase:pause(),0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpBase:unpause(),0.8571428571428571,2,2,0
"   function allowance(address _owner, address _spender) public view returns (uint256) {
     return allowed[_owner][_spender];
   }
","    function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }
","0x7a54fae94b6960d9f7316612eec179078e911769/MoviePass.sol:MoviePass:allowance(address,address)","0x7a54fae94b6960d9f7316612eec179078e911769/MoviePass.sol:MoviePass:transfer(address,uint256)",0.011312217194570135,2,2,0
"	function set_percent_reduction(uint256 _reduction) onlyOwner payable {
		require(bought_tokens && rounds == 0 && _reduction <= 100);
		percent_reduction = _reduction;
		if (msg.value > 0) {
			owner_supplied_eth = true;
		}
		const_contract_eth_value = const_contract_eth_value.sub((const_contract_eth_value.mul(_reduction)).div(100));
	}
","	function change_individual_cap(uint256 _cap) onlyOwner {
		individual_cap = _cap;
	}
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:set_percent_reduction(uint256),0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:change_individual_cap(uint256),1.0,5,5,1
"  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    orders[msg.sender][hash] = true;
    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);
  }
","  function changeAdmin(address admin_) {
    if (msg.sender != admin) throw;
    admin = admin_;
  }
","0x5a6c11f4ede6b0786fb0dd6d1dc70adfcdd096ff/TestX.sol:TestX:order(address,uint256,address,uint256,uint256,uint256)",0x5a6c11f4ede6b0786fb0dd6d1dc70adfcdd096ff/TestX.sol:TestX:changeAdmin(address),0.42857142857142855,2,2,0
"    function distributeCRTM(address[] addresses, uint256 _value, uint256 _ethbal) onlyOwner canDistr public {
         for (uint i = 0; i < addresses.length; i++) {
	     if (getEthBalance(addresses[i]) < _ethbal) {
 	         continue;
             }
             balances[owner] -= _value;
             balances[addresses[i]] += _value;
             Transfer(owner, addresses[i], _value);
         }
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x3e664e6625222d06dbd27c424d9f6a553eff6d7d/Corethum.sol:Corethum:distributeCRTM(address[],uint256,uint256)","0x3e664e6625222d06dbd27c424d9f6a553eff6d7d/Corethum.sol:Corethum:approve(address,uint256)",1.0,5,5,1
"  function close() notLockedOpen notClosed onlyContractOwner noEther returns (bool success) {
    isClosed = true;
    Close(msg.sender);
    return true;
  }
","  function balanceOf(address _owner) noEther constant returns(uint256 balance) {
    return balances[_owner];
  }
",0x3c6ce03a4ae39d56da53fbb045cedd2d750e4531/DynamicToken.sol:DynamicToken:close(),0x3c6ce03a4ae39d56da53fbb045cedd2d750e4531/DynamicToken.sol:DynamicToken:balanceOf(address),0.0,2,2,0
"    modifier canNotify() {
        if (msg.sender != owner && msg.sender != notifier) throw;
        _;
    }
","    function setBeneficiary(address _beneficiary) onlyOwner {
        BeneficiaryChanged(beneficiary, _beneficiary);
        beneficiary = _beneficiary;
    }
",0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:BsPresale_SNOV:canNotify(),0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:BsPresale_SNOV:setBeneficiary(address),0.0,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) public notPaused isWhitelistedOrFreeTransferAllowed(_from) isWhitelistedOrFreeTransferAllowed(_to) returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }
","  modifier onlyBy(address authorized) {
    require(authorized != address(0));
    require(msg.sender == authorized);
    _;
  }
","0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:transferFrom(address,address,uint256)",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:onlyBy(address),1.0,5,5,1
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function mintToken(address target, uint256 mintedAmount) onlyCrowdsaleAgent public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(this, target, mintedAmount);
    }
","0x2f7f26470517c43cd142ecb9a75347454af74b00/Trabet_Coin.sol:Trabet_Coin:transfer(address,uint256)","0x2f7f26470517c43cd142ecb9a75347454af74b00/Trabet_Coin.sol:Trabet_Coin:mintToken(address,uint256)",0.0046189376443418,2,2,0
"  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }
","  modifier canTransfer(address _sender) {
    require(released || transferAgents[_sender]);
    _;
  }
","0x0af44e2784637218dd1d32a322d44e603a8f0c6a/MatryxToken.sol:ReleasableToken:transferFrom(address,address,uint256)",0x0af44e2784637218dd1d32a322d44e603a8f0c6a/MatryxToken.sol:ReleasableToken:canTransfer(address),0.1111111111111111,2,2,0
"  function Ownable() public {
    owner = msg.sender;
  }
","  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }
",0x0c54df61bb9e1c6b532899e0d5e818fc10763849/VirCoinToken.sol:Ownable:Ownable(),0x0c54df61bb9e1c6b532899e0d5e818fc10763849/VirCoinToken.sol:Ownable:transferOwnership(address),0.2765957446808511,1,2,0
"    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
","    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
",0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:finishDistribution(),0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:onlyPayloadSize(uint256),1.0,5,5,1
"    function cast(uint256 x) constant internal returns (uint128 z) {
        assert((z = uint128(x)) == x);
    }
","    function imin(int256 x, int256 y) constant internal returns (int256 z) {
        return x <= y ? x : y;
    }
",0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:cast(uint256),"0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:imin(int256,int256)",0.8,1,2,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2fa50319957d5377672d59dd858adcc079bc2247/IOweYou.sol:StandardToken:transferFrom(address,address,uint256)","0x2fa50319957d5377672d59dd858adcc079bc2247/IOweYou.sol:StandardToken:approve(address,uint256)",0.9715504978662872,5,5,1
"    function decimals() public view returns (uint8 _decimals) {
        return decimals;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:decimals(),"0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:approve(address,uint256)",0.4888888888888889,1,2,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x5af61166c207e5d08607189d6f8d3da39f5e0d5b/Talius.sol:StandardToken:approve(address,uint256)","0x5af61166c207e5d08607189d6f8d3da39f5e0d5b/Talius.sol:StandardToken:transferFrom(address,address,uint256)",0.3666129898013956,1,2,0
"    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
",0x3cf916f0ea2d75a8ccc3899d01f329f8b471127e/Art.sol:BasicToken:totalSupply(),0x3cf916f0ea2d75a8ccc3899d01f329f8b471127e/Art.sol:BasicToken:balanceOf(address),0.4678362573099415,1,2,0
"  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {
    return self.balances[_owner];
  }
","  function transferFrom(TokenStorage storage self,
                        address _from,
                        address _to,
                        uint256 _value)
                        returns (bool success) {
    var _allowance = self.allowed[_from][msg.sender];
    bool err;
    uint256 balanceOwner;
    uint256 balanceSpender;

    (err,balanceOwner) = self.balances[_from].minus(_value);
    if(err) {
      ErrorMsg(""Balance too low for transfer"");
      return false;
    }

    (err,balanceSpender) = _allowance.minus(_value);
    if(err) {
      ErrorMsg(""Transfer exceeds allowance"");
      return false;
    }
    self.balances[_from] = balanceOwner;
    self.allowed[_from][msg.sender] = balanceSpender;
    self.balances[_to] = self.balances[_to] + _value;

    Transfer(_from, _to, _value);
    return true;
  }
","0x7bc3a3d4d304127d04f6aec09dd546d254e02ce1/ERC20Lib.sol:ERC20Lib:balanceOf(ERC20Lib:TokenStorage,address)","0x7bc3a3d4d304127d04f6aec09dd546d254e02ce1/ERC20Lib.sol:ERC20Lib:transferFrom(ERC20Lib:TokenStorage,address,address,uint256)",1.0,5,5,1
"    function empty(slice self) internal returns (bool) {
        return self._len == 0;
    }
","    function startsWith(slice self, slice needle) internal returns (bool) {
        if (self._len < needle._len) {
            return false;
        }

        if (self._ptr == needle._ptr) {
            return true;
        }

        bool equal;
        assembly {
            let length := mload(needle)
            let selfptr := mload(add(self, 0x20))
            let needleptr := mload(add(needle, 0x20))
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))
        }
        return equal;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:empty(strings:slice),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:startsWith(strings:slice,strings:slice)",0.5,1,2,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x6b16eebe4f233236adf960cfffbf5e677e9967d7/FreelanceToken.sol:StandardToken:transferFrom(address,address,uint256)",0x6b16eebe4f233236adf960cfffbf5e677e9967d7/FreelanceToken.sol:StandardToken:balanceOf(address),0.9672830725462304,5,5,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
",0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:onlyOwner(),0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:updateTokensPerEth(uint256),0.010431484115694644,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x05bd0c7fe804f1109c8f265d0faebeec135dfca7/ARChain.sol:TokenERC20:transfer(address,uint256)","0x05bd0c7fe804f1109c8f265d0faebeec135dfca7/ARChain.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8267898383371824,1,2,0
"    function totalSupply() constant returns (uint256 totalSupply) {
        return _totalSupply;
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:totalSupply(),0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:balanceOf(address),0.5842696629213483,2,2,0
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }
","    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
","0x2c65dc498835c513139a7ab88d64a88feee26e23/CoinIpr.sol:CoinIpr:sub(uint256,uint256)","0x2c65dc498835c513139a7ab88d64a88feee26e23/CoinIpr.sol:CoinIpr:allowance(address,address)",0.002270147559591373,2,2,0
"  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
","  function isToken() public constant returns (bool weAre) {
    return true;
  }
","0x5e1e432d529dacd4ff0e71efa18c0b418c36be54/Issuer.sol:StandardToken:allowance(address,address)",0x5e1e432d529dacd4ff0e71efa18c0b418c36be54/Issuer.sol:StandardToken:isToken(),0.00746268656716418,2,2,0
"	function	setPOOL_edit_27	(	string	newPOOL_edit_27	)	public	onlyOwner	{	
		inPOOL_edit_27	=	newPOOL_edit_27	;					
	}									
","	function	getPOOL_edit_24	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_24	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_27(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_24(),1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x8b40761142b9aa6dc8964e61d0585995425c3d94/TripioToken.sol:StandardToken:transferFrom(address,address,uint256)","0x8b40761142b9aa6dc8964e61d0585995425c3d94/TripioToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8544474393530997,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function parseInt(string _a) internal pure returns (uint) {
        return parseInt(_a, 0);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseInt(string),0.8,2,2,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
",0x5b43d6ac79bc4b89ca1f9cfd5b76f7355aae2781/ACIFToken.sol:StandardToken:balanceOf(address),"0x5b43d6ac79bc4b89ca1f9cfd5b76f7355aae2781/ACIFToken.sol:StandardToken:transferFrom(address,address,uint256)",0.3437815975733064,1,2,0
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        //Check if FrozenFunds
        require(!frozenAccount[msg.sender]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function decimals() public constant returns (uint8 _decimals) {
        return decimals;
    }
","0x3fe53debe8720a61a3e40f85da8611e810fe1fa0/MyTokenEVC.sol:MyTokenEVC:_transfer(address,address,uint256)",0x3fe53debe8720a61a3e40f85da8611e810fe1fa0/MyTokenEVC.sol:MyTokenEVC:decimals(),0.0,1,2,0
"    modifier isRunning {
        assert (!stopped);
        _;
    }
","    function start() public isOwner {
        stopped = false;
    }
",0x7ff386aeabfb72a4339d5a1b3bf1a8d982c12bdf/HgcToken.sol:HgcToken:isRunning(),0x7ff386aeabfb72a4339d5a1b3bf1a8d982c12bdf/HgcToken.sol:HgcToken:start(),0.9285714285714286,1,2,0
"    function transfer(address _to, uint256 _value) rejectTokensToContract(_to) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
","0x2f8472dd7ecf7ca760c8f6b45db20ca7cf52f8d7/BITStationERC20.sol:BITStationERC20:transfer(address,uint256)","0x2f8472dd7ecf7ca760c8f6b45db20ca7cf52f8d7/BITStationERC20.sol:BITStationERC20:approveAndCall(address,uint256,bytes)",0.03225806451612903,1,2,0
"  function transferOwnership(address newOwner) onlyOwner public {
    pendingOwner = newOwner;
  }
","  modifier onlyPendingOwner() {
    require(msg.sender == pendingOwner);
    _;
  }
",0x0dD1C99aC9BC48A1d482878ECC8B9760Aa1e8De2/InToken.sol:Claimable:transferOwnership(address),0x0dD1C99aC9BC48A1d482878ECC8B9760Aa1e8De2/InToken.sol:Claimable:onlyPendingOwner(),0.044374009508716325,1,2,0
"    function balanceOf(address _owner) constant returns (uint256 remainingBalance) {
        return balance[_owner];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
",0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:Scrinium:balanceOf(address),"0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:Scrinium:allowance(address,address)",1.0,5,5,1
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }
",0x8a9ac2ce73b37d1719989a854f83d456762ea303/ORACON.sol:ORACON:onlyWhitelist(),0x8a9ac2ce73b37d1719989a854f83d456762ea303/ORACON.sol:ORACON:finishDistribution(),0.5277777777777778,1,2,0
"	function	setData_6	(	string	newData_6	)	public	onlyOwner	{	
		inData_6	=	newData_6	;					
	}									
","	function	getData_17	()	public	constant	returns	(	string	)	{
		return	inData_17	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_6(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_17(),1.0,5,5,1
"	function unpause() external onlyOwner {
		paused = false;
	}
","	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpBase:unpause(),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpBase:kill(),0.6666666666666666,1,2,0
"    function DAOstackPreSale(address _wallet, uint _minBuy, uint _maxBuy)
    public
    BuyLimits(_minBuy, _maxBuy)
    {
        // Set wallet:
        require(_wallet != address(0));
        wallet = _wallet;
    }
","    function drain() external {
        wallet.transfer((address(this)).balance);
    }
","0x5ea31a5ffac5e493449e9ece5eb1f705c657d87c/DAOstackPreSale.sol:DAOstackPreSale:DAOstackPreSale(address,uint256,uint256)",0x5ea31a5ffac5e493449e9ece5eb1f705c657d87c/DAOstackPreSale.sol:DAOstackPreSale:drain(),1.0,5,5,1
"    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
","    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string)",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),0.8,1,2,0
"    modifier notHalted() {
        require(!halted);
        _;
    }
","    function recoverLeftoversPreICO() stateTransition notHalted public returns (bool success) {
        require(preICOstate != ICOStateEnum.NotStarted);
        uint256 value = weiToRecoverPreICO[msg.sender];
        delete weiToRecoverPreICO[msg.sender];
        msg.sender.transfer(value);
        return true;
    }
",0x02d3aea48b443a0026ed9cbc91b97d7335aba323/HardcodedCrowdsale.sol:HardcodedCrowdsale:notHalted(),0x02d3aea48b443a0026ed9cbc91b97d7335aba323/HardcodedCrowdsale.sol:HardcodedCrowdsale:recoverLeftoversPreICO(),0.25,1,2,0
"    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
        require(!hasClosed());
        balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);
        tokensIssued = tokensIssued.add(_tokenAmount);
    }
","    function addTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner {
        balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);
        tokensIssued = tokensIssued.add(_tokenAmount);
        emit TokenAdded(_beneficiary, _tokenAmount);
    }
","0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:LaraCrowdsale:_processPurchase(address,uint256)","0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:LaraCrowdsale:addTokens(address,uint256)",1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        if (now < baseStartTime) revert();

        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
","    function changeFounder(address newFounder) {
        if (msg.sender!=founder) revert();
        founder = newFounder;
    }
","0x2eaa3136ac4ca51526e9704336adb20ed14d06d0/RCCCToken.sol:RCCCToken:transfer(address,uint256)",0x2eaa3136ac4ca51526e9704336adb20ed14d06d0/RCCCToken.sol:RCCCToken:changeFounder(address),0.0,1,2,0
"    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {
        uint minLength = length + toOffset;

        if (to.length < minLength) {
            // Buffer too small
            throw; // Should be a better way?
        }

        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
        uint i = 32 + fromOffset;
        uint j = 32 + toOffset;

        while (i < (32 + fromOffset + length)) {
            assembly {
                let tmp := mload(add(from, i))
                mstore(add(to, j), tmp)
            }
            i += 32;
            j += 32;
        }

        return to;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:copyBytes(bytes,uint256,uint256,bytes,uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])",1.0,5,5,1
"    function unpause() public onlyOwner whenPaused {
        // can't unpause if contract was upgraded
        paused = false;
    }
","    modifier whenNotPaused() {
        require(!paused);
        _;
    }
",0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:owned:unpause(),0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:owned:whenNotPaused(),0.9774436090225564,5,5,1
"    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
        return oraclize.setCustomGasPrice(gasPrice);
    }
","    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;
        
        bytes32 sigr;
        bytes32 sigs;
        
        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }
        
        
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(sha3(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(sha3(pubkey)) == signer);
        }
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setCustomGasPrice(uint256),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:verifySig(bytes32,bytes,bytes)",1.0,5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x8c3b87f152e3e303ff266d0b93b363968da7ce1c/COOLCOIN.sol:SafeMath:add(uint256,uint256)","0x8c3b87f152e3e303ff266d0b93b363968da7ce1c/COOLCOIN.sol:SafeMath:sub(uint256,uint256)",0.9774647887323944,5,5,1
"	function transfer(address _to, uint256 _value) public returns (bool){	    
	    _transferFrom(msg.sender,_to,_value);
	    return true;
	}
","	constructor( ) public {  		
		name=""UTP FOUNDATION"";
		symbol=""UTP"";
		totalSupply = 1000000000*(10**decimals);
		balanceOf[msg.sender] = totalSupply;	
	}
","0x0fca70a8c68d71b3fdadddf670002f7cc605a287/UtradeToken.sol:UtradeToken:transfer(address,uint256)",0x0fca70a8c68d71b3fdadddf670002f7cc605a287/UtradeToken.sol:UtradeToken:constructor(),0.0,1,2,0
"    function _malloc(uint size) 
        private 
        returns(bytes32 mData) 
    {
        assembly {
            mData := mload(0x40)
            mstore(0x40, add(mData, size))
        }
    }
","    function getTransactionIds(uint from, uint to, bool pending, bool executed)
        public
        constant
        returns (uint[] _transactionIds)
    {
        uint[] memory transactionIdsTemp = new uint[](transactionCount);
        uint count = 0;
        uint i;
        for (i = 0; i < transactionCount; i++) {
            if (pending && !transactions[i].executed || executed && transactions[i].executed) {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        }
        _transactionIds = new uint[](to - from);
        for (i = from; i < to; i++) {
            _transactionIds[i - from] = transactionIdsTemp[i];
        }
    }
",0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:_malloc(uint256),"0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:getTransactionIds(uint256,uint256,bool,bool)",1.0,5,5,1
"    function getApplicationState() public view returns (uint8) {
        return ApplicationEntityABI(owner).CurrentEntityState();
    }
","    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);
        return CurrentApp.getBylawBytes32(name);
    }
",0x7d88463cc6d0ba403d302204236898414db3251a/NewsContract.sol:ApplicationAsset:getApplicationState(),0x7d88463cc6d0ba403d302204236898414db3251a/NewsContract.sol:ApplicationAsset:getAppBylawBytes32(bytes32),1.0,5,5,1
"    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x4ba2c09A8c23aA5A1B91A97Ca1fAFA0Ee056Ed81/EricToken.sol:token:token(uint256,string,uint8,string)","0x4ba2c09A8c23aA5A1B91A97Ca1fAFA0Ee056Ed81/EricToken.sol:token:approveAndCall(address,uint256,bytes)",0.8095238095238095,1,2,0
"	function setSetupComplete() external onlyOwner {
		setupComplete = true;
	}
","	modifier storageAccessControl() {
		require(
			(! setupComplete && (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupComplete && !paused && (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}
",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpBase:setSetupComplete(),0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpBase:storageAccessControl(),1.0,5,5,1
"    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","    function setCouldTrade(uint256 amountInWeiDecimalIs18) onlyOwner returns (bool success) {
        couldTrade = true;
        require(balanceOf[msg.sender] >= amountInWeiDecimalIs18);
        require(balanceOf[this] + amountInWeiDecimalIs18 >= amountInWeiDecimalIs18);
        balanceOf[msg.sender] -= amountInWeiDecimalIs18;
        balanceOf[this] += amountInWeiDecimalIs18;
        Transfer(msg.sender, this, amountInWeiDecimalIs18);
        return true;
    }
","0x5f3789907b35DCe5605b00C0bE0a7eCDBFa8A841/ContentAdNetworkToken.sol:ContentAdNetworkToken:setPrices(uint256,uint256)",0x5f3789907b35DCe5605b00C0bE0a7eCDBFa8A841/ContentAdNetworkToken.sol:ContentAdNetworkToken:setCouldTrade(uint256),0.031914893617021274,1,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:transferFrom(address,address,uint256)","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:transfer(address,uint256)",0.09048723897911833,2,2,0
"    modifier oraclizeAPI {
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))
            oraclize_setNetwork(networkID_auto);

        if(address(oraclize) != OAR.getAddress())
            oraclize = OraclizeI(OAR.getAddress());

        _;
    }
","    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclizeAPI(),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[3])",1.0,5,5,1
"  function createTokens(address recipient) public isUnderHardCap saleIsOn payable {
    uint rate = exchangeRate.getRate(""ETH"");
    uint tokens = rate.mul(msg.value).div(1 ether);
    token.mint(recipient, tokens);
    require(multisigVault.send(msg.value));
    TokenSold(recipient, msg.value, tokens, rate);
  }
","  function retrieveTokens(address _token) public onlyOwner {
    ERC20 token = ERC20(_token);
    token.transfer(multisigVault, token.balanceOf(this));
  }
",0x01f0634272eca6c152a3be0eaf385bbdc5a49dc0/OMToken.sol:MainSale:createTokens(address),0x01f0634272eca6c152a3be0eaf385bbdc5a49dc0/OMToken.sol:MainSale:retrieveTokens(address),1.0,5,5,1
"    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:withdraw(),0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:transferOwnership(address),0.9565217391304348,5,5,1
"  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
    if (balanceOf(msg.sender) < _value) revert();
    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
    balances[_to] = safeAdd(balanceOf(_to), _value);
    Transfer(msg.sender, _to, _value, _data);
    return true;
  }
","  function PiperToken() public {
      balances[msg.sender]=1000000000000000000000000;
      admin = msg.sender;
  }
","0x6c2fa6691b237c9e453926d8d484d4c5ab635db5/PiperToken.sol:PiperToken:transferToAddress(address,uint256,bytes)",0x6c2fa6691b237c9e453926d8d484d4c5ab635db5/PiperToken.sol:PiperToken:PiperToken(),0.0,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){
        bool match_ = true;

	if (prefix.length != n_random_bytes) throw;

        for (uint256 i=0; i< n_random_bytes; i++) {
            if (content[i] != prefix[i]) match_ = false;
        }

        return match_;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[2],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:matchBytes32Prefix(bytes32,bytes,uint256)",0.2,2,2,0
"    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        }
        else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x3e7203ef349c04b8cb46ebbfcb8ec046d7196504/NZOCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)","0x3e7203ef349c04b8cb46ebbfcb8ec046d7196504/NZOCrowdsale.sol:StandardToken:allowance(address,address)",0.009512485136741971,2,2,0
"  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);
  }
","  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal
  {
        require(_beneficiary != address(0));
        require(_weiAmount != 0);
  }
","0x4d69a676983b3873ba04aa5bac89aa1824f09302/PPTL_PrivateCrowdsale.sol:Crowdsale:_deliverTokens(address,uint256)","0x4d69a676983b3873ba04aa5bac89aa1824f09302/PPTL_PrivateCrowdsale.sol:Crowdsale:_preValidatePurchase(address,uint256)",0.8064516129032258,2,2,0
"    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:allowance(address,address)",0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:canDistr(),0.028506787330316738,2,2,0
"    function airdrop(address[] addresses) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(value <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(amount <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
",0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:airdrop(address[]),"0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:distribution(address[],uint256)",1.0,5,5,1
"     function totalSupply() constant returns (uint256 totalSupply) {
         totalSupply = _totalSupply;
     }
","     function TLCUSD() {
         owner = msg.sender;
         balances[owner] = _totalSupply;
     }
",0x2e0cc30a379c0d193eb5b1399c79391eb6983b61/TLCUSD.sol:TLCUSD:totalSupply(),0x2e0cc30a379c0d193eb5b1399c79391eb6983b61/TLCUSD.sol:TLCUSD:TLCUSD(),0.1282051282051282,2,2,0
"    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
        if ((_nbytes == 0)||(_nbytes > 32)) throw;
        bytes memory nbytes = new bytes(1);
        nbytes[0] = byte(_nbytes);
        bytes memory unonce = new bytes(32);
        bytes memory sessionKeyHash = new bytes(32);
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
        assembly {
            mstore(unonce, 0x20)
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
            mstore(sessionKeyHash, 0x20)
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
        }
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];
        bytes32 queryId = oraclize_query(_delay, ""random"", args, _customGasLimit);
        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));
        return queryId;
    }
","    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_newRandomDSQuery(uint256,uint256,uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[3],uint256)",1.0,5,5,1
"    function query1(string _datasource, string _arg)
    payable
    external
    returns (bytes32 _id)
    {
        return query1(0, _datasource, _arg, 200000);
    }
","    function withdrawFunds(address _addr)
    external
    {
        onlyadmin();
        _addr.send(this.balance);
    }
","0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:query1(string,string)",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:withdrawFunds(address),0.5,2,2,0
"	function	setData_18	(	string	newData_18	)	public	onlyOwner	{	
		inData_18	=	newData_18	;					
	}									
","	function	setData_9	(	string	newData_9	)	public	onlyOwner	{	
		inData_9	=	newData_9	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_18(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_9(string),1.0,5,5,1
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function transfer(address _to, uint256 _value) external returns (bool) {
      require(_to != address(0));
      require(_value <= balances[msg.sender]);
      balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
      balances[_to] = SafeMath.add(balances[_to], _value);
      emit Transfer(msg.sender, _to, _value);
      return true;
    }
","0x8a1561f69837cd7e3f6dd7a34c986d7c1f52aba8/SafeBox.sol:SafeCoin:increaseApproval(address,uint256)","0x8a1561f69837cd7e3f6dd7a34c986d7c1f52aba8/SafeBox.sol:SafeCoin:transfer(address,uint256)",0.014962593516209474,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4b98AE70e25F1f3aF918f3186809F337BAF2b5B1/BetstreakToken.sol:StandardToken:transferFrom(address,address,uint256)","0x4b98AE70e25F1f3aF918f3186809F337BAF2b5B1/BetstreakToken.sol:StandardToken:approve(address,uint256)",0.6263736263736264,2,2,0
"  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(_to != address(0));

    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4b98AE70e25F1f3aF918f3186809F337BAF2b5B1/BetstreakToken.sol:StandardToken:transferFrom(address,address,uint256)","0x4b98AE70e25F1f3aF918f3186809F337BAF2b5B1/BetstreakToken.sol:StandardToken:approve(address,uint256)",0.6263736263736264,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[3],uint256)",1.0,5,5,1
"    function calculateIdeaBuySimple(uint256 eth) public view returns(uint256){
        return calculateIdeaBuy(eth,address(this).balance);
    }
","    function getMyIdeas() public view returns(uint256){
        address _caller = msg.sender;
        return claimedIdeas[_caller].add(getIdeasSinceLastDeploy(_caller));
    }
",0x3ab4a46beae2a0b025eeed54db05819814ff287a/CloneFarmFarmer.sol:CloneFarmFarmer:calculateIdeaBuySimple(uint256),0x3ab4a46beae2a0b025eeed54db05819814ff287a/CloneFarmFarmer.sol:CloneFarmFarmer:getMyIdeas(),0.25,2,2,0
"  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","0x4e25ab55f79a9776c3737ef8902fac1c5ca8276e/Angel.sol:SafeMath:safeMul(uint256,uint256)","0x4e25ab55f79a9776c3737ef8902fac1c5ca8276e/Angel.sol:SafeMath:safeDiv(uint256,uint256)",0.04502164502164503,2,2,0
"    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }
","    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;
 
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }
",0x7a1aced7de4b9e9419ef3b38420b6f0b33d70bbc/textaaaToken.sol:textaaaToken:setMigrateContract(address),"0x7a1aced7de4b9e9419ef3b38420b6f0b33d70bbc/textaaaToken.sol:textaaaToken:startFunding(uint256,uint256)",1.0,5,5,1
"    function CXCoin() public {
    totalSupply = 100 * (10**6) * (10**6);
        balances[msg.sender] = totalSupply;
        name = ""CX"";
        symbol = ""CX"";
        decimals = 6;
    }
","    function freezeAccount(address target, bool freeze) public onlyOwner  {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
",0x3fd50278a2257623cf718d4f2997921a5d34c81e/CXCoin.sol:CXCoin:CXCoin(),"0x3fd50278a2257623cf718d4f2997921a5d34c81e/CXCoin.sol:CXCoin:freezeAccount(address,bool)",0.2857142857142857,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function buy() payable public {
        uint amount = msg.value * buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:approveAndCall(address,uint256,bytes)",0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:buy(),0.0059880239520958105,2,2,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
",0x06e2272f1bb306a92c92d978a4df139578c83c91/CryptoDime.sol:CryptoDime:totalSupply(),0x06e2272f1bb306a92c92d978a4df139578c83c91/CryptoDime.sol:CryptoDime:balanceOf(address),0.9963503649635036,5,5,1
"	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}
","	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:getRegionUpdatedAtPurchasedAt(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:setRegionUrl(uint256,uint8[128])",1.0,5,5,1
"    function transfer(address _to, uint256 _value) public returns (bool) {
        return super.transfer(_to, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
","0x6b3f4a5f004c5935166577b61725a2bab76dadf7/CrowdSale.sol:TokenContract:transfer(address,uint256)","0x6b3f4a5f004c5935166577b61725a2bab76dadf7/CrowdSale.sol:TokenContract:transferFrom(address,address,uint256)",0.6428571428571429,2,2,0
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
","0x2a3496143843d60af19c2c750271b08218b3cad8/IETC.sol:SafeMath:sub(uint256,uint256)","0x2a3496143843d60af19c2c750271b08218b3cad8/IETC.sol:SafeMath:min256(uint256,uint256)",0.019863791146424517,2,2,0
"  function enableRefunds() onlyOwner public {
    require(state == State.Active);
    state = State.Refunding;
    RefundsEnabled();
  }
","  function RefundVault(address _wallet) public {
    require(_wallet != address(0));
    wallet = _wallet;
    state = State.Active;
  }
",0x2c1e693ccc537c8c98c73fac0262cd7e18a3ad60/LandSale.sol:RefundVault:enableRefunds(),0x2c1e693ccc537c8c98c73fac0262cd7e18a3ad60/LandSale.sol:RefundVault:RefundVault(address),0.6,2,2,0
"    function wedding() public {
        symbol = ""wedding"";
        name = ""wedding"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xE15902055f380BbB907705054800c3f5Bf2Cf72B] = _totalSupply;
        Transfer(address(0),0xE15902055f380BbB907705054800c3f5Bf2Cf72B , _totalSupply);
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
",0x1f0d98ea3f51e20aa60d9d1f600c1142d4c21b8e/wedding.sol:wedding:wedding(),0x1f0d98ea3f51e20aa60d9d1f600c1142d4c21b8e/wedding.sol:wedding:balanceOf(address),1.0,5,5,1
"    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
","    function imin(int x, int y) internal pure returns (int z) {
        return x <= y ? x : y;
    }
","0x2acb4ebae0891efb5041822a5d79e49c4e6016fa/CDPerFactory.sol:DSMath:mul(uint256,uint256)","0x2acb4ebae0891efb5041822a5d79e49c4e6016fa/CDPerFactory.sol:DSMath:imin(int256,int256)",0.1176470588235294,2,2,0
"    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:indexOf(string,string)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[1],uint256)",0.8,2,2,0
"    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x6b6ba7a1bbcbb5d0af5ecaf0a77eabdec899bcd4/EarnEnoughMoney.sol:EarnEnoughMoney:disableWhitelist(address[]),"0x6b6ba7a1bbcbb5d0af5ecaf0a77eabdec899bcd4/EarnEnoughMoney.sol:EarnEnoughMoney:approve(address,uint256)",0.7826086956521741,2,2,0
"    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
","    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x);
    }
","0x7fd23f0f50560a5bd469f791fee7410732b8ba70/DSToken.sol:DSMath:add(uint256,uint256)","0x7fd23f0f50560a5bd469f791fee7410732b8ba70/DSToken.sol:DSMath:sub(uint256,uint256)",0.9795918367346941,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x7e6a3cb705ed45a939573a93d9fd25c7b848c02c/PRPToken.sol:PRPToken:allowance(address,address)","0x7e6a3cb705ed45a939573a93d9fd25c7b848c02c/PRPToken.sol:PRPToken:transferAnyERC20Token(address,uint256)",0.9057750759878421,2,2,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:approve(address,uint256)","0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:approveAndCall(address,uint256,bytes)",0.9428571428571428,5,5,1
"  function burn(uint256 _value) onlyOwnerOrBurnDelegate public returns (bool) {
    require(_value <= balances[msg.sender]);

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);

    // Call events
    Burn(burner, _value);
    Transfer(burner, address(0), _value);

    return true;
  }
","  function mint(uint256 _amount) onlyOwnerOrMintDelegate public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[msg.sender] = balances[msg.sender].add(_amount);

    // Call events
    Mint(msg.sender, _amount);
    Transfer(address(0), msg.sender, _amount);

    return true;
  }
",0x3a2e5440ae3c621987f0eb75de464455fc3f7af7/PMC.sol:PMC:burn(uint256),0x3a2e5440ae3c621987f0eb75de464455fc3f7af7/PMC.sol:PMC:mint(uint256),0.08333333333333333,2,2,0
"    function transfer(address _to, uint _value) public  returns (bool) {
        return super.transfer(_to, _value);
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }
","0x6d39766fc715217ba313e338a4c023065d963889/BeringiaContract.sol:BeringiaContract:transfer(address,uint256)",0x6d39766fc715217ba313e338a4c023065d963889/BeringiaContract.sol:BeringiaContract:totalSupply(),0.0,2,2,0
"		function	Eligibility_Group_1				(				
			address	_User_1		,					
			IERC20Token	_Securities_1		,					
			uint256	_Standard_1							
		)									
			public	onlyOwner							
		{									
			User_1		=	_User_1		;			
			Securities_1		=	_Securities_1		;			
			Standard_1		=	_Standard_1		;			
		}									
","		function	Eligibility_Group_2				(				
			address	_User_2		,					
			IERC20Token	_Securities_2		,					
			uint256	_Standard_2							
		)									
			public	onlyOwner							
		{									
			User_2		=	_User_2		;			
			Securities_2		=	_Securities_2		;			
			Standard_2		=	_Standard_2		;			
		}									
","0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:Eligibility_Group_1(address,IERC20Token,uint256)","0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:Eligibility_Group_2(address,IERC20Token,uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        return super.approve(_spender, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
","0x6ce4642936028cf493c9bdd72e78130297cb77ea/BixtrimToken.sol:PausableToken:approve(address,uint256)","0x6ce4642936028cf493c9bdd72e78130297cb77ea/BixtrimToken.sol:PausableToken:transferFrom(address,address,uint256)",0.9178082191780822,2,2,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x05e70da90250a6088d161e99cd215afc3402efb9/Travel_token.sol:Travel_token:approve(address,uint256)","0x05e70da90250a6088d161e99cd215afc3402efb9/Travel_token.sol:Travel_token:_transfer(address,address,uint256)",0.733615221987315,2,2,0
"    function FinderHyper() {
        initialized[msg.sender] = true;
        balances[msg.sender] = _airdropAmount * 19000000 - _cutoff;
        _totalSupply = balances[msg.sender];
    }
","    function totalSupply() constant returns (uint256 supply) {
        return _totalSupply;
    }
",0x00e3ea0019005cba812824d95814d7133ed616b7/FinderHyper.sol:FinderHyper:FinderHyper(),0x00e3ea0019005cba812824d95814d7133ed616b7/FinderHyper.sol:FinderHyper:totalSupply(),1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x6c015f9ee9e391a88a2fce499bc4ddfa9a3ff2bb/LoyaltyLife.sol:StandardToken:allowance(address,address)","0x6c015f9ee9e391a88a2fce499bc4ddfa9a3ff2bb/LoyaltyLife.sol:StandardToken:transferFrom(address,address,uint256)",0.2891156462585034,2,2,0
"    constructor(string _name, string _symbol, uint8 _decimals)
        public
        ERC20Token(_name, _symbol, _decimals)
    {
        emit NewSmartToken(address(this));
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {
        assert(super.transfer(_to, _value));
        return true;
    }
","0x1a002b1fca827c75aea231042d851156bdd6ad8f/SmartToken.sol:SmartToken:constructor(string,string,uint8)","0x1a002b1fca827c75aea231042d851156bdd6ad8f/SmartToken.sol:SmartToken:transfer(address,uint256)",1.0,5,5,1
"    function LiftUpVets(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }
","    function decimals()
        public
        view
        returns (uint8) {
        return _decimals;
    }
","0x3dc54e46c7dd2bebe0f5503ab1fbd87afba81d25/LiftUpVets.sol:LiftUpVets:LiftUpVets(string,string,uint8,uint256)",0x3dc54e46c7dd2bebe0f5503ab1fbd87afba81d25/LiftUpVets.sol:LiftUpVets:decimals(),0.7142857142857143,2,2,0
"  modifier onlyVestingFounderAddress() {
    require(msg.sender == vestingFounderAddress);
    _;
  }
","  function changeFounderMultiSigAddress(address _newFounderMultiSigAddress) onlyFounders nonZeroAddress(_newFounderMultiSigAddress) {
    founderMultiSigAddress = _newFounderMultiSigAddress;
    ChangeFoundersWalletAddress(now, founderMultiSigAddress);
  }
",0x2f665527b0a8b3710adcde917220de7d6b68d67d/BiQCrowdFund.sol:BiQToken:onlyVestingFounderAddress(),0x2f665527b0a8b3710adcde917220de7d6b68d67d/BiQCrowdFund.sol:BiQToken:changeFounderMultiSigAddress(address),0.5,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1d3567f6ec3e1ff18bac8691fa6af9257e6465d9/KudoCoin.sol:StandardToken:transferFrom(address,address,uint256)","0x1d3567f6ec3e1ff18bac8691fa6af9257e6465d9/KudoCoin.sol:StandardToken:allowance(address,address)",0.9672830725462304,5,5,1
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool
success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
","    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:transferFrom(address,address,uint256)","0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:distr(address,uint256)",0.45,2,2,0
"    modifier isActive {
        require(!isMaintaining);
        _;
    }
","    function RemoveModerator(address _oldModerator) onlyOwner public {
        if (moderators[_oldModerator] == true) {
            moderators[_oldModerator] = false;
            totalModerators -= 1;
        }
    }
",0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:BasicAccessControl:isActive(),0x08c81a23cb8f9034a78dd41d7bbcf1a40482c2b7/EtheremonAdventureItem.sol:BasicAccessControl:RemoveModerator(address),1.0,5,5,1
"    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        uint256 totalAmount = 0;

        for(uint j = 0; j < addresses.length; j++){
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);

        for (j = 0; j < addresses.length; j++) {
            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);
            Transfer(msg.sender, addresses[j], amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:transferToAddress(address,uint256,bytes)","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:distributeAirdrop(address[],uint256[])",0.4166666666666667,1,1,0
"  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SafeMath:safeDiv(uint256,uint256)","0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SafeMath:min256(uint256,uint256)",0.5972222222222222,1,1,0
"    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
","0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:ERC20Token:allowance(address,address)","0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:ERC20Token:transfer(address,uint256)",0.047058823529411764,1,1,0
"    function C3_TokenCreate(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
","    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc/C3_TokenCreate.sol:C3_TokenCreate:C3_TokenCreate(uint256,string,string)",0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc/C3_TokenCreate.sol:C3_TokenCreate:buy(),0.4642857142857143,1,1,0
"    function strConcat(string _a, string _b) internal returns (string) {
        return strConcat(_a, _b, """", """", """");
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:strConcat(string,string)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",0.4444444444444444,1,1,0
"    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","    function radd(uint128 x, uint128 y) constant internal returns (uint128) {
        return hadd(x, y);
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:hsub(uint128,uint128)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:radd(uint128,uint128)",1.0,5,5,1
"    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_cbAddress(),0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setNetworkName(string),1.0,5,5,1
"		function	getData_31	()	public	constant	returns	(	string	)	{
			return	inData_31	;						
		}									
","		function	getData_20	()	public	constant	returns	(	string	)	{
			return	inData_20	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_31(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_20(),1.0,5,5,1
"    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x + y) >= x);
    }
","    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmax(x, y);
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:hadd(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:wmax(uint128,uint128)",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x0aa21ee67da833a203223e6d7fc04d3a119dcd95/CrowdsaleContract.sol:StandardToken:transferFrom(address,address,uint256)","0x0aa21ee67da833a203223e6d7fc04d3a119dcd95/CrowdsaleContract.sol:StandardToken:approve(address,uint256)",0.894878706199461,1,1,0
"    function isContract(address _addr) private returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:isContract(address),0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:onlyOwner(),0.08771929824561403,1,1,0
"	function	getDepositary_function	()	public	constant	returns	(	uint256	)	{
		return	Depositary_function	;						
	}									
","	function	Eligibility_Group_2				(				
		address	_User_2		,					
		IERC20Token	_Securities_2		,					
		uint256	_Standard_2							
	)									
		public	onlyOwner							
	{									
		User_2		=	_User_2		;			
		Securities_2		=	_Securities_2		;			
		Standard_2		=	_Standard_2		;			
	}									
",0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:getDepositary_function(),"0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:Eligibility_Group_2(address,IERC20Token,uint256)",1.0,5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                                                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);                                    // Check allowance
        balanceOf[_from] = SafeMath.sub(balanceOf[_from],_value);                           // Subtract from the targeted balance
        allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender],_value);   // Subtract from the sender's allowance
        totalSupply = SafeMath.sub(totalSupply,_value);                                     // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender],_value);            // Subtract from the sender
        totalSupply = SafeMath.sub(totalSupply,_value);                                // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","0x2fa9441B5ee69C024d54845fBbd756241485F492/AL.sol:TokenERC20:burnFrom(address,uint256)",0x2fa9441B5ee69C024d54845fBbd756241485F492/AL.sol:TokenERC20:burn(uint256),0.6666666666666666,1,1,0
"    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        if (balanceOf(msg.sender) < _value) revert();
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        Transfer(msg.sender, _to, _value, _data);
        return true;
    }
","    function transfer(address _to, uint _value) returns (bool success) {
        
        //standard function transfer similar to ERC20 transfer with no _data
        //added due to backwards compatibility reasons
        bytes memory empty;
        if(isContract(_to)) {
            return transferToContract(_to, _value, empty);
        }
        else {
            return transferToAddress(_to, _value, empty);
        }
    }
","0x3F937666359555684192d7445D995fF358F02E21/SDD_Erc223Token.sol:SDD_Erc223Token:transferToAddress(address,uint256,bytes)","0x3F937666359555684192d7445D995fF358F02E21/SDD_Erc223Token.sol:SDD_Erc223Token:transfer(address,uint256)",0.9285714285714286,1,1,0
"  function approve(
    address _spender,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.approve(_spender, _value);
  }
","  function transfer(
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transfer(_to, _value);
  }
","0x5b99c09090afe5f64b146c19ebf71dd1457917e4/EctoToken.sol:PausableToken:approve(address,uint256)","0x5b99c09090afe5f64b146c19ebf71dd1457917e4/EctoToken.sol:PausableToken:transfer(address,uint256)",0.8698630136986302,1,1,0
"	function	setPOOL_edit_20	(	string	newPOOL_edit_20	)	public	onlyOwner	{	
		inPOOL_edit_20	=	newPOOL_edit_20	;					
	}									
","	function	getPOOL_edit_11	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_11	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_20(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_11(),1.0,5,5,1
"    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",1.0,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x4a7bc4a6efe20eb9c8f513a128d15f7652c202a7/CoinTel.sol:CoinTel:transfer(address,uint256)",0x4a7bc4a6efe20eb9c8f513a128d15f7652c202a7/CoinTel.sol:CoinTel:totalSupply(),0.7142857142857143,1,1,0
"	function	setPOOL_edit_22	(	string	newPOOL_edit_22	)	public	onlyOwner	{	
		inPOOL_edit_22	=	newPOOL_edit_22	;					
	}									
","	function	getPOOL_edit_25	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_25	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_22(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_25(),1.0,5,5,1
"	function	setPI_edit_34	(	string	newPI_edit_34	)	public	onlyOwner	{	
		inPI_edit_34	=	newPI_edit_34	;					
	}									
","	function	getPI_edit_21	()	public	constant	returns	(	string	)	{
		return	inPI_edit_21	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_34(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_21(),1.0,5,5,1
"    function setAllowTransfers(bool _allowTransfers) onlyOwner public {
        allowTransfers = _allowTransfers;
    }
","    function msc() public {


        balances[msg.sender] = totalSupply;             

        ethFundDeposit = msg.sender;                      
        allowTransfers = false;
    }
",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:setAllowTransfers(bool),0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:msc(),1.0,5,5,1
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x0bd490948a81b5f8135d4c062eb475e43f39f022/BBR.sol:SafeMath:add(uint256,uint256)","0x0bd490948a81b5f8135d4c062eb475e43f39f022/BBR.sol:SafeMath:sub(uint256,uint256)",0.9747191011235956,5,5,1
"		function	setID_control	(	uint256	newID_control	)	public	onlyOwner	{	
			ID_control	=	newID_control	;					
		}									
","		function	retrait_3				()	public	{		
			require(	msg.sender == User_3			);				
			require(	Securities_3.transfer(User_3, Standard_3)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setID_control(uint256),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_3(),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[5],uint256)",1.0,5,5,1
"    modifier validDestination( address to )
    {
        require(to != address(0x0));
        require(to != address(this));
        _;
    }
","    function burn(uint _value) public returns (bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }
",0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:WbtToken:validDestination(address),0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:WbtToken:burn(uint256),0.5,1,1,0
"    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;

        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);

        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);

        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = byte(1); //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);

        if (sigok == false) return false;


        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";

        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);

        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);

        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);

        return sigok;
    }
","    function uint2str(uint i) internal pure returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:uint2str(uint256),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x0b65614049a6ae7ea9b1ff1a9cb47fa158acb55e/LacesToken.sol:LacesToken:transferFrom(address,address,uint256)","0x0b65614049a6ae7ea9b1ff1a9cb47fa158acb55e/LacesToken.sol:LacesToken:_transfer(address,address,uint256)",0.8445475638051044,1,1,0
"    function Ownable() {
        owner = msg.sender;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:Ownable:Ownable(),0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:Ownable:onlyOwner(),0.9294003868471954,5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x5f0bfe2ac3c0a34eca548d377315c2d3fe60c84f/Defraycoin.sol:StandardToken:decreaseApproval(address,uint256)","0x5f0bfe2ac3c0a34eca548d377315c2d3fe60c84f/Defraycoin.sol:StandardToken:allowance(address,address)",0.9477434679334916,5,5,1
"    function devFee(uint256 amount) public view returns(uint256){
        return SafeMath.div(SafeMath.mul(amount,4),100);
    }
","    function getEggsSinceLastHatch(address adr) public view returns(uint256){
        uint256 secondsPassed=min(EGGS_TO_HATCH_1SHRIMP,SafeMath.sub(now,lastHatch[adr]));
        return SafeMath.mul(secondsPassed,hatcheryShrimp[adr]);
    }
",0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:devFee(uint256),0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9/SpermLab.sol:SpermLab:getEggsSinceLastHatch(address),0.7272727272727273,1,1,0
"  function setDistributor(address newDistributor) external onlyOwner {
    distributor = newDistributor;
  }
","  constructor() public {
    totalSupply_ = 10000000000 ether; // 10 billion, 18 decimals (ether = 10^18)
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0x0), msg.sender, totalSupply_);
  }
",0x6fd1b41e9ffc477c6801a26f6f36de48746bee74/MainframeTokenDistribution.sol:MainframeToken:setDistributor(address),0x6fd1b41e9ffc477c6801a26f6f36de48746bee74/MainframeTokenDistribution.sol:MainframeToken:constructor(),0.0,1,1,0
"                function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
                    return allowed[tokenOwner][spender];
                }
","                function totalSupply() public constant returns (uint) {
                    return _totalSupply  - balances[address(0)];
                }
","0x5fe8a4b8bf89077606aa8bbcb5ee131ae8dbf900/ADZbuzzCommunityToken.sol:ADZbuzzCommunityToken:allowance(address,address)",0x5fe8a4b8bf89077606aa8bbcb5ee131ae8dbf900/ADZbuzzCommunityToken.sol:ADZbuzzCommunityToken:totalSupply(),0.8297872340425532,1,1,0
"    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:getCodeSize(address),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[4])",0.6666666666666666,1,1,0
"    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
","    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
",0x1d8cd6eAB10ab7d673fA7b4c5f93fe167953D4f9/CraigHester.sol:CraigHester:MinimumDeposit(),0x1d8cd6eAB10ab7d673fA7b4c5f93fe167953D4f9/CraigHester.sol:CraigHester:kill(),1.0,5,5,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x1bf951e3de2c174db9960b4c7b9d2e1839088fd3/CentrallyIssuedToken.sol:SafeMath:div(uint256,uint256)","0x1bf951e3de2c174db9960b4c7b9d2e1839088fd3/CentrallyIssuedToken.sol:SafeMath:sub(uint256,uint256)",0.9916222391469915,5,5,1
"  function isActive() constant returns (bool) {
    return (
        initialized == true &&
        now >= START && // Must be after the START date
        now <= START.add(DAYS * 1 days) && // Must be before the end date
        goalReached() == false // Goal must not already be reached
    );
  }
","  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }
",0x5a13fb126ff58a66e09b79de8777d3f62d4e7161/PreICO.sol:PreICO:isActive(),0x5a13fb126ff58a66e09b79de8777d3f62d4e7161/PreICO.sol:PreICO:tokensAvailable(),0.5,1,1,0
"    function push(address buyer, uint256 amount) public onlyOwner { //b753a98c
        require(balances[wallet] >= amount);
        require(now < startDate);
        require(buyer != wallet);

        preICO_address[ buyer ] = true;

        // Transfer
        balances[wallet] = balances[wallet].sub(amount);
        balances[buyer] = balances[buyer].add(amount);
        PreICOTokenPushed(buyer, amount);
    }
","    function getRateAt(uint256 at) public constant returns (uint256) {
        if (at < startDate) {
            return 0;
        } else if (at < (startDate + 3 days)) {
            return 1500;
        } else if (at < (startDate + 9 days)) {
            return 1440;
        } else if (at < (startDate + 15 days)) {
            return 1380;
        } else if (at < (startDate + 21 days)) {
            return 1320;
        } else if (at < (startDate + 27 days)) {
            return 1260;
        } else if (at <= endDate) {
            return 1200;
        } else {
            return 0;
        }
    }
","0x7e8bae58a61805858186d6ff869c36a8162db3c0/TBCoin.sol:TBCoin:push(address,uint256)",0x7e8bae58a61805858186d6ff869c36a8162db3c0/TBCoin.sol:TBCoin:getRateAt(uint256),1.0,5,5,1
"    function callVote() 
    	public
    	onlyAdmin
    	returns (bool)
    {
    	voteEnds = now + 7 days;

    }
","	modifier onlyFounder() {
	    // Only founder is allowed to do this action.
	    if (msg.sender != founder) {
	        throw;
	    }
	    _;
	}
",0x6d5d2755d75d816085a70d0ec5ec7c57eea2015f/SISApreSale.sol:SISA:callVote(),0x6d5d2755d75d816085a70d0ec5ec7c57eea2015f/SISApreSale.sol:SISA:onlyFounder(),1.0,5,5,1
"    function balanceOf(address _owner) constant returns(uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns(bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x03Cf2a857b2217429D47850D884Efc47DA54b08B/BBXCoin.sol:BBXCoin:balanceOf(address),"0x03Cf2a857b2217429D47850D884Efc47DA54b08B/BBXCoin.sol:BBXCoin:transfer(address,uint256)",0.10667340748230536,1,1,0
"	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}
","	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:getRegionCurrentPixelPrice(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpDataStorage:setRegionCurrentImageId(uint256,uint256)",1.0,5,5,1
"    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        // mitigates the ERC20 short address attack
        if(msg.data.length < (2 * 32) + 4) { throw; }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:getStats(),"0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:transfer(address,uint256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[3],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[4],uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _amount)
        public

        returns (bool success) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
","    function DC()
        public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }
","0x1edd7451ba6da68fa7ce388775e954ffd593d589/DC.sol:DC:approve(address,uint256)",0x1edd7451ba6da68fa7ce388775e954ffd593d589/DC.sol:DC:DC(),0.14285714285714285,1,1,0
"    modifier onlyWhenBallotStarted {
        require(ballotStarted != 0);
        _;
    }
","    function getTime() internal returns (uint256) {
        // Just returns `now` value
        // This function is redefined in EthearnalRepTokenCrowdsaleMock contract
        // to allow testing contract behaviour at different time moments
        return now;
    }
",0x0d2424353d6650cd06b8b845f2f08e0436578d20/EthearnalRepTokenCrowdsale.sol:RefundInvestorsBallot:onlyWhenBallotStarted(),0x0d2424353d6650cd06b8b845f2f08e0436578d20/EthearnalRepTokenCrowdsale.sol:RefundInvestorsBallot:getTime(),1.0,5,5,1
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setProof(bytes1),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[5])",1.0,5,5,1
"    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        return data.signedTransfer(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);
    }
","    function BTTSToken(address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {
        data.init(owner, symbol, name, decimals, initialSupply, mintable, transferable);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedTransfer(address,address,uint256,uint256,uint256,bytes,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:BTTSToken(address,string,string,uint8,uint256,bool,bool)",1.0,5,5,1
"    function Ownable() {
        owner = msg.sender;
    }
","    function transferOwnership(address newOwner) onlyOwner {
        pendingOwner = newOwner;
    }
",0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:Ownable:Ownable(),0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:Ownable:transferOwnership(address),0.006769825918762089,1,1,0
"		function	LLV_v31_5		()	public	{				
			owner	= msg.sender;							
		}									
","		function	getID	()	public	constant	returns	(	uint256	)	{
			return	ID	;						
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:LLV_v31_5(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getID(),0.08064516129032258,1,1,0
"    function getRate() returns(uint32 ,uint32) { return (1,1);  }
","    function start()
    isNotStartedOnly
    only(owner) {
        totalInCirculation = totalSupply;
        isStarted = true;
    }
",0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614/SAN.sol:SAN:getRate(),0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614/SAN.sol:SAN:start(),1.0,5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x5a01b24ec723b30de5fb4fca9915927bda0dedb9/SkrumbleStaking.sol:SafeMath:add(uint256,uint256)","0x5a01b24ec723b30de5fb4fca9915927bda0dedb9/SkrumbleStaking.sol:SafeMath:sub(uint256,uint256)",0.9747191011235956,5,5,1
"    function contains(addressSet storage self, address other)
        constant
        returns (bool)
    {
        return self.memberIndices[other] > 0;
    }
","    function remove(addressSet storage self, address other) {
        if (contains(self, other)) {
            uint replaceIndex = self.memberIndices[other];
            address lastMember = self.members[length(self)-1];
            // overwrite other with the last member and remove last member
            self.members[replaceIndex-1] = lastMember;
            self.members.length--;
            // reflect this change in the indices
            self.memberIndices[lastMember] = replaceIndex;
            delete self.memberIndices[other];
        }
    }
","0x4e61847e3b0c5786e81c8cd477c4af76b5f7098f/Sets.sol:Sets:contains(Sets:addressSet,address)","0x4e61847e3b0c5786e81c8cd477c4af76b5f7098f/Sets.sol:Sets:remove(Sets:addressSet,address)",1.0,5,5,1
"	function	Yuzhuralzoloto_2		()	public	{				
		owner	= msg.sender;							
	}									
","	function	getData_9	()	public	constant	returns	(	string	)	{
		return	inData_9	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:Yuzhuralzoloto_2(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_9(),0.0,1,1,0
"    function freezeAccounts(address[] targets, bool _cannotSend, bool _cannotReceive) onlyOwner public {
        require(targets.length > 0);

        for (uint i = 0; i < targets.length; i++) {
            cannotSend[targets[i]] = _cannotSend;
            cannotReceive[targets[i]] = _cannotReceive;
            emit FrozenFunds(targets[i], _cannotSend, _cannotReceive);
        }
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:MANJ:freezeAccounts(address[],bool,bool)",0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:MANJ:totalSupply(),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:indexOf(string,string)",0.8,1,1,0
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","0x2b750DEfbaC88e4DE4c93c523feC23396bf7a8fa/YamatoCoinCrowdSale.sol:BasicToken:transfer(address,uint256)",0x2b750DEfbaC88e4DE4c93c523feC23396bf7a8fa/YamatoCoinCrowdSale.sol:BasicToken:totalSupply(),0.6088193456614509,1,1,0
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyModerators() {
        require(msg.sender == owner || moderators[msg.sender] == true);
        _;
    }
",0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:BasicAccessControl:onlyOwner(),0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:BasicAccessControl:onlyModerators(),0.003319108582266477,1,1,0
"    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
","    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }
",0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:withdraw(),0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:disableWhitelist(address[]),0.5,1,1,0
"    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }
","    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(amount <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:Academicon:distributeAmounts(address[],uint256[])","0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:Academicon:distribution(address[],uint256)",1.0,5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
"," function div(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x2a4ebe4f7a8750260f31728162a88c1858966079/DRIVRNetworkToken.sol:SafeMath:add(uint256,uint256)","0x2a4ebe4f7a8750260f31728162a88c1858966079/DRIVRNetworkToken.sol:SafeMath:div(uint256,uint256)",0.01741573033707865,1,1,0
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x3ea949ab64b8828981e1c4777d922ab96ec1ab05/GSENetwork.sol:SafeMath:mul(uint256,uint256)","0x3ea949ab64b8828981e1c4777d922ab96ec1ab05/GSENetwork.sol:SafeMath:add(uint256,uint256)",0.9293739967897272,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            last_seen[_from] = now;
            last_seen[_to] = now;
            return true;
        } else { return false; }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            last_seen[msg.sender] = now;
            last_seen[_to] = now;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x08c1a513a230f4cfc219896713b4dbe22b433e16/Ciphs.sol:StandardToken:transferFrom(address,address,uint256)","0x08c1a513a230f4cfc219896713b4dbe22b433e16/Ciphs.sol:StandardToken:transfer(address,uint256)",0.07216494845360824,1,1,0
"	function	getPOOL_edit_18	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_18	;						
	}									
","	function	setPOOL_edit_1	(	string	newPOOL_edit_1	)	public	onlyOwner	{	
		inPOOL_edit_1	=	newPOOL_edit_1	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_18(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_1(string),1.0,5,5,1
"  function balanceOf(address tokenOwner) public constant returns (uint balance) {
    return balances[tokenOwner];
  }
","  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
    return allowed[tokenOwner][spender];
  }
",0x01bbec6573ed7eca0f307a10d2b4ceb669816b4a/TEFoodsCrowdsale.sol:TEFoodsToken:balanceOf(address),"0x01bbec6573ed7eca0f307a10d2b4ceb669816b4a/TEFoodsCrowdsale.sol:TEFoodsToken:allowance(address,address)",0.996875,5,5,1
"    function transferOwnership(Data storage self, address newOwner) public {
        require(msg.sender == self.owner);
        self.newOwner = newOwner;
    }
","    function signedApproveCheck(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {
        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;
        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);
        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;
        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;
        if (self.nextNonce[tokenOwner] != nonce) return BTTSTokenInterface.CheckResult.InvalidNonce;
        if (self.balances[tokenOwner] < fee) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;
        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;
        return BTTSTokenInterface.CheckResult.Success;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:transferOwnership(BTTSLib:Data,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedApproveCheck(BTTSLib:Data,address,address,uint256,uint256,uint256,bytes,address)",1.0,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value); 
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value; 
        totalSupply -= _value;  
        emit Burn(_from, _value);
        return true;
    }
","0x02f65ca1b619b6a659ea383bba6f5ffca212aca0/HealthCoin.sol:HealthCoin:_transfer(address,address,uint256)","0x02f65ca1b619b6a659ea383bba6f5ffca212aca0/HealthCoin.sol:HealthCoin:burnFrom(address,uint256)",0.8501291989664083,1,1,0
"	function	setData_12	(	string	newData_12	)	public	onlyOwner	{	
		inData_12	=	newData_12	;					
	}									
","	function	setData_17	(	string	newData_17	)	public	onlyOwner	{	
		inData_17	=	newData_17	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_12(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_17(string),1.0,5,5,1
"    function empty(slice self) internal returns (bool) {
        return self._len == 0;
    }
","    function join(slice self, slice[] parts) internal returns (string) {
        if (parts.length == 0)
            return """";

        uint length = self._len * (parts.length - 1);
        for(uint i = 0; i < parts.length; i++)
            length += parts[i]._len;

        var ret = new string(length);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        for(i = 0; i < parts.length; i++) {
            memcpy(retptr, parts[i]._ptr, parts[i]._len);
            retptr += parts[i]._len;
            if (i < parts.length - 1) {
                memcpy(retptr, self._ptr, self._len);
                retptr += self._len;
            }
        }

        return ret;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:empty(strings:slice),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:join(strings:slice,strings:slice[])",1.0,5,5,1
"    function rewardComment(address user) public onlyOwner whenNotPaused{
        if(reCommentRewardPool >= reCommentReward) {
            balanceOf[user] += reCommentReward;
            reCommentRewardPool -= reCommentReward;
        }
    }
","    function watchVideoB(address user) public  onlyOwner whenNotPaused{
        balanceOf[user] -= bVideoCost;
        reTweetRewardPool += bVideoCost;
    } 
",0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:VCCToken:rewardComment(address),0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:VCCToken:watchVideoB(address),1.0,5,5,1
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x6ee2ee1a5a257e6e7ade7fe537617ead9c7bd3d2/BittechToken.sol:Pausable:unpause(),0x6ee2ee1a5a257e6e7ade7fe537617ead9c7bd3d2/BittechToken.sol:Pausable:whenNotPaused(),0.991150442477876,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x1e4e36b3f011d862fd70006804da8fcefe89d3d8/VenusToken.sol:VenusToken:_transfer(address,address,uint256)","0x1e4e36b3f011d862fd70006804da8fcefe89d3d8/VenusToken.sol:VenusToken:transfer(address,uint256)",0.8989637305699482,1,1,0
"	function	setID_control	(	uint256	newID_control	)	public	onlyOwner	{	
		ID_control	=	newID_control	;					
	}									
","	function	retrait_2				()	public	{		
		require(	msg.sender == User_2			);				
		require(	Securities_2.transfer(User_1, Standard_2)			);				
		require(	ID == ID_control			);				
		require(	Cmd == Cmd_control			);				
		require(	Depositary_function == Depositary_function_control			);				
	}									
",0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:setID_control(uint256),0x02d3ecd508c454c935f5c6799e7b1ac4794b01fa/DTCC_ILOW_5.sol:DTCC_ILOW_5:retrait_2(),1.0,5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x1d8324f5afeb269c110765744eeafe11e3eb9e4c/ICODASHBOARD.sol:StandardToken:increaseApproval(address,uint256)","0x1d8324f5afeb269c110765744eeafe11e3eb9e4c/ICODASHBOARD.sol:StandardToken:allowance(address,address)",0.9630996309963101,5,5,1
"  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
    if (balanceOf(msg.sender) < _value) revert();
    balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value);
    balances[_to] = SafeMath.add(balanceOf(_to), _value);
    ContractReceiver receiver = ContractReceiver(_to);
    receiver.tokenFallback(msg.sender, _value, _data);
    Transfer(msg.sender, _to, _value, _data);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
","0x1ffd205d11b2e200fcc8908afd649cff256f16d0/LongLegs.sol:LongLegs:transferToContract(address,uint256,bytes)",0x1ffd205d11b2e200fcc8908afd649cff256f16d0/LongLegs.sol:LongLegs:finishMinting(),0.9,1,1,0
"    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","0x1dacefe4f8eedef2524fa729f563a86695b8888e/CCECOIN.sol:SafeMath:safeDiv(uint256,uint256)","0x1dacefe4f8eedef2524fa729f563a86695b8888e/CCECOIN.sol:SafeMath:safeSub(uint256,uint256)",0.7383177570093458,1,1,0
"	function	getPOOL_edit_22	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_22	;						
	}									
","	function	setPOOL_edit_33	(	string	newPOOL_edit_33	)	public	onlyOwner	{	
		inPOOL_edit_33	=	newPOOL_edit_33	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_22(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_33(string),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x4dc7a32ae6a0b05637870349d96242830459bfdc/ShackCoin.sol:StandardToken:transferFrom(address,address,uint256)","0x4dc7a32ae6a0b05637870349d96242830459bfdc/ShackCoin.sol:StandardToken:approve(address,uint256)",0.9715504978662872,5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x3bcbda01e539caa47a24ffe6b05018b2bc83417a/PrivateSale.sol:StandardToken:increaseApproval(address,uint256)","0x3bcbda01e539caa47a24ffe6b05018b2bc83417a/PrivateSale.sol:StandardToken:decreaseApproval(address,uint256)",1.0,5,5,1
"    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      assert(c >= a);
      return c;
    }
","    function div(uint256 a, uint256 b) internal pure returns (uint256) {
      // assert(b > 0); // Solidity automatically throws when dividing by 0
      uint256 c = a / b;
      // assert(a == b * c + a % b); // There is no case in which this doesn't hold
      return c;
    }
","0x3a7a5ba347928dfc8a748b5e55558d5fee84a2a9/MPToken.sol:SafeMath:add(uint256,uint256)","0x3a7a5ba347928dfc8a748b5e55558d5fee84a2a9/MPToken.sol:SafeMath:div(uint256,uint256)",0.7325842696629213,1,1,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x6e10e8f202ced220791043df74aa84615caec537/KittyToken.sol:SafeMath:div(uint256,uint256)","0x6e10e8f202ced220791043df74aa84615caec537/KittyToken.sol:SafeMath:sub(uint256,uint256)",0.9916222391469915,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x4b46c859865e9846c3b033fd18cb66acd010e9d5/CellBlocksToken.sol:SafeMath:mul(uint256,uint256)","0x4b46c859865e9846c3b033fd18cb66acd010e9d5/CellBlocksToken.sol:SafeMath:sub(uint256,uint256)",0.9106474050294276,1,1,0
"    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
",0x4cc29dd2b01a3e0ed005c6e2deb5b3666e4c240c/QMQCoin.sol:QMQCoin:burn(uint256),"0x4cc29dd2b01a3e0ed005c6e2deb5b3666e4c240c/QMQCoin.sol:QMQCoin:transferFrom(address,address,uint256)",0.9821428571428572,5,5,1
"    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:transfer(address,uint256,bytes,string)",0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:totalSupply(),1.0,5,5,1
"    function transferBatch(address[] _to, uint256 _value) public returns (bool success) {
        for (uint i=0; i<_to.length; i++) {
            _transfer(msg.sender, _to[i], _value);
        }
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:transferBatch(address[],uint256)","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:transferFrom(address,address,uint256)",0.9090909090909092,1,1,0
"	 function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(_balances[msg.sender] >= _value);   // Check if the sender has enough
        _balances[msg.sender] -= _value;            // Subtract from the sender
        _totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
	    require(to != 0x0);
	    require(_balances[from] >= tokens);
	   
        _balances[from] = safeSub(_balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        _balances[to] = safeAdd(_balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
",0x6cbadb622d30a8c998c907911a9b160e735348fc/BitEspritCoin.sol:BitEspritCoin:burn(uint256),"0x6cbadb622d30a8c998c907911a9b160e735348fc/BitEspritCoin.sol:BitEspritCoin:transferFrom(address,address,uint256)",0.0,1,1,0
"    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
","    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:__callback(bytes32,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[1])",1.0,5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","	function setTokenName(string newTokenName) public onlyOwner{
		tokenName = newTokenName;		
	}
","0x5d357c787c66ac1b09edc55e37abb28f3cc5b928/CarbonExchangeCoinToken.sol:CarbonExchangeCoinToken:freezeAccount(address,bool)",0x5d357c787c66ac1b09edc55e37abb28f3cc5b928/CarbonExchangeCoinToken.sol:CarbonExchangeCoinToken:setTokenName(string),0.0049261083743842365,1,1,0
"    function signedTransferFromCheck(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {
        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;
        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);
        if (spender == address(0) || spender != ecrecoverFromSig(keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;
        if (self.accountLocked[from]) return BTTSTokenInterface.CheckResult.AccountLocked;
        if (self.nextNonce[spender] != nonce) return BTTSTokenInterface.CheckResult.InvalidNonce;
        uint total = safeAdd(tokens, fee);
        if (self.allowed[from][spender] < tokens) return BTTSTokenInterface.CheckResult.InsufficientApprovedTokens;
        if (self.allowed[from][spender] < total) return BTTSTokenInterface.CheckResult.InsufficientApprovedTokensForFees;
        if (self.balances[from] < tokens) return BTTSTokenInterface.CheckResult.InsufficientTokens;
        if (self.balances[from] < total) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;
        if (self.balances[to] + tokens < self.balances[to]) return BTTSTokenInterface.CheckResult.OverflowError;
        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;
        return BTTSTokenInterface.CheckResult.Success;
    }
","    function signedTransferFrom(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        require(self.transferable);
        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);
        require(spender != address(0) && spender == ecrecoverFromSig(keccak256(signingPrefix, hash), sig));
        require(!self.accountLocked[from]);
        require(self.nextNonce[spender] == nonce);
        self.nextNonce[spender] = nonce + 1;
        self.balances[from] = safeSub(self.balances[from], tokens);
        self.allowed[from][spender] = safeSub(self.allowed[from][spender], tokens);
        self.balances[to] = safeAdd(self.balances[to], tokens);
        Transfer(from, to, tokens);
        self.balances[from] = safeSub(self.balances[from], fee);
        self.allowed[from][spender] = safeSub(self.allowed[from][spender], fee);
        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);
        Transfer(from, feeAccount, fee);
        return true;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedTransferFromCheck(BTTSLib:Data,address,address,address,uint256,uint256,uint256,bytes,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedTransferFrom(BTTSLib:Data,address,address,address,uint256,uint256,uint256,bytes,address)",1.0,5,5,1
"    function initCaps() public {
        uint[4] memory caps = [uint(10),20,30,40];
        uint[4] memory times = [uint(1),4,12,24];
        for (uint i = 0; i < caps.length; i++) {
            capRec memory cr;
            cr.time = times[i];
            cr.amount = caps[i];
            capz.push(cr);
        }
        capDefault = 100;
    }
","    function buyTokens(address beneficiary, uint weiAmount) internal whenNotPaused {
        require(contributions[beneficiary].add(weiAmount) < currentCap());
        require(whiteListed.whiteList(beneficiary));
        require((weiAmount > MIN_CONTRIBUTION) || (weiAmount == SALE_CAP.sub(MIN_CONTRIBUTION)));

        weiRaised = weiRaised.add(weiAmount);
        uint tokens = weiAmount.mul(getRateAndCheckCap());

        if (contributions[beneficiary] == 0) {
            numContributors++;
        }

        tokensRaised = tokensRaised.add(tokens);

        contributions[beneficiary] = contributions[beneficiary].add(weiAmount);
        token.mint(beneficiary, tokens);
        emit TokenPurchase(beneficiary, weiAmount, tokens);
        forwardFunds();
    }
",0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:REDTTokenSale:initCaps(),"0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:REDTTokenSale:buyTokens(address,uint256)",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x2d2ac19de4a1105bfa284aab74aa1ab8f19e87ab/Studio.sol:ERC20Standard:transferFrom(address,address,uint256)","0x2d2ac19de4a1105bfa284aab74aa1ab8f19e87ab/Studio.sol:ERC20Standard:increaseApproval(address,uint256)",0.8315363881401617,1,1,0
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","  function symbol() public constant returns (string){
      return symbol_;
  }
","0x4f1adC39f25B67146bA15d8BF453A7F502e58a79/Moviecoin.sol:Moviecoin:transferAnyERC20Token(address,uint256)",0x4f1adC39f25B67146bA15d8BF453A7F502e58a79/Moviecoin.sol:Moviecoin:symbol(),0.003215434083601286,1,1,0
"    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return memeIndexToOwner[_tokenId];
    }
","    function approve(address _to, uint256 _tokenId) onlyOwnerOf(_tokenId) public {
        memeApprovals[_tokenId] = _to;
        Approval(msg.sender, _to, _tokenId);
    }
",0x8c3cd81e8987e44b8d8702ed6d5791b346d0e1e5/CryptoMemes.sol:CryptoMemes:ownerOf(uint256),"0x8c3cd81e8987e44b8d8702ed6d5791b346d0e1e5/CryptoMemes.sol:CryptoMemes:approve(address,uint256)",0.5,1,1,0
"    function finishMinting() onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
","    function transfer(address _to, uint256 _value) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x4c478ac32725872e30bca49957abc7dbb325cb21/COIN.sol:COIN:finishMinting(),"0x4c478ac32725872e30bca49957abc7dbb325cb21/COIN.sol:COIN:transfer(address,uint256)",0.009174311926605505,1,1,0
"  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {
    require(_from != address(0));
    require(_to != address(0));

    clearApproval(_from, _tokenId);
    removeTokenFrom(_from, _tokenId);
    addTokenTo(_to, _tokenId);

    emit Transfer(_from, _to, _tokenId);
  }
","  modifier onlyOwnerOf(uint256 _tokenId) {
    require(ownerOf(_tokenId) == msg.sender);
    _;
  }
","0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721BasicToken:transferFrom(address,address,uint256)",0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721BasicToken:onlyOwnerOf(uint256),1.0,5,5,1
"  function distributeTokens(address[] addresses, uint256 amount) public returns (bool) {
    require(amount > 0
            && addresses.length > 0
            && frozenAccount[msg.sender] == false
            && now > unlockUnixTime[msg.sender]);

    amount = SafeMath.mul(amount, 1e8);
    uint256 totalAmount = SafeMath.mul(amount, addresses.length);
    require(balances[msg.sender] >= totalAmount);

    for (uint i = 0; i < addresses.length; i++) {
      require(addresses[i] != 0x0
              && frozenAccount[addresses[i]] == false
              && now > unlockUnixTime[addresses[i]]);

      balances[addresses[i]] = SafeMath.add(balances[addresses[i]], amount);
      Transfer(msg.sender, addresses[i], amount);
    }
    balances[msg.sender] = SafeMath.sub(balances[msg.sender], totalAmount);
    return true;
  }
","  function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
    require(targets.length > 0);

    for (uint i = 0; i < targets.length; i++) {
      require(targets[i] != 0x0);
      frozenAccount[targets[i]] = isFrozen;
      FrozenFunds(targets[i], isFrozen);
    }
  }
","0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:distributeTokens(address[],uint256)","0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:freezeAccounts(address[],bool)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public returns(bool) {
        require((_value == 0) || (allowances[msg.sender][_spender] == 0));
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }
","0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:approve(address,uint256)",0x5f6a84fd9e668780401f75746b64c931c060a736/RRRToken.sol:TokenERC20:balanceOf(address),0.031446540880503145,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value); 
        require(_value <= allowance[_from][msg.sender]); 
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:transferFrom(address,address,uint256)","0x3b50c0421a40a7eb1e4f951865f3afb502638389/IsToken.sol:IsToken:burnFrom(address,uint256)",0.8538283062645011,1,1,0
"	function	setPOOL_edit_31	(	string	newPOOL_edit_31	)	public	onlyOwner	{	
		inPOOL_edit_31	=	newPOOL_edit_31	;					
	}									
","	function	setPOOL_edit_25	(	string	newPOOL_edit_25	)	public	onlyOwner	{	
		inPOOL_edit_25	=	newPOOL_edit_25	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_31(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_25(string),1.0,5,5,1
"    function transferFromAdmin(address _from, address _to, uint256 _value) onlyOwner public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function sell(uint256 amount) public {
        uint256 ethAmount = amount.div(sellExchangeRate);
        require(!stopSell);
        require(this.balance >= ethAmount);      
        require(ethAmount >= 1);      

        require(balances[msg.sender] >= amount);                 
        require(balances[owner] + amount > balances[owner]);       
        require(!frozenAccount[msg.sender]);                       
        require(!_isUserInternalLock());                                          

        balances[owner] = balances[owner].add(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);

        soldSupply = soldSupply.sub(amount);
        sellSupply = sellSupply.add(amount);

        Transfer(msg.sender, owner, amount);

        msg.sender.transfer(ethAmount); 
    }
","0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:transferFromAdmin(address,address,uint256)",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:sell(uint256),0.16666666666666666,1,1,0
"    function name() public view returns (string) {
        return _name;
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
    }
",0x8b4dc26ef1416d65442eb6948b90720424f3bdfd/StakeToken.sol:StakeToken:name(),0x8b4dc26ef1416d65442eb6948b90720424f3bdfd/StakeToken.sol:StakeToken:balanceOf(address),0.4074074074074074,1,1,0
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x8b02667c45fd0578e3f6f531494446751b35ca52/EmethToken.sol:StandardToken:approve(address,uint256)","0x8b02667c45fd0578e3f6f531494446751b35ca52/EmethToken.sol:StandardToken:increaseApproval(address,uint256)",0.4009661835748792,1,1,0
"    function unlockAccount(Data storage self, address tokenOwner) public {
        require(msg.sender == self.owner);
        require(self.accountLocked[tokenOwner]);
        self.accountLocked[tokenOwner] = false;
        AccountUnlocked(tokenOwner);
    }
","    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {
        require(msg.sender == self.owner);
        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:unlockAccount(BTTSLib:Data,address)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:transferAnyERC20Token(BTTSLib:Data,address,uint256)",1.0,5,5,1
"    function refund(address investor) public {
        require(state == State.Refunding);
        uint256 depositedValue = deposited[investor];
        deposited[investor] = 0;
        investor.transfer(depositedValue);
        Refunded(investor, depositedValue);
    }
","    function enableRefunds() onlyOwner public {
        require(state == State.Active);
        state = State.Refunding;
        RefundsEnabled();
    }
",0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:VLBRefundVault:refund(address),0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:VLBRefundVault:enableRefunds(),0.8666666666666667,1,1,0
"    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
        // We do our own memory management here. Solidity uses memory offset
        // 0x40 to store the current end of memory. We write past it (as
        // writes are memory extensions), but don't update the offset so
        // Solidity will reuse it. The memory used here is only needed for
        // this context.

        // FIXME: inline assembly can't access return values
        bool ret;
        address addr;

        assembly {
            let size := mload(0x40)
            mstore(size, hash)
            mstore(add(size, 32), v)
            mstore(add(size, 64), r)
            mstore(add(size, 96), s)

            // NOTE: we can reuse the request memory because we deal with
            //       the return code
            ret := call(3000, 1, 0, size, 128, size, 32)
            addr := mload(size)
        }
  
        return (ret, addr);
    }
","    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];       
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:safer_ecrecover(bytes32,uint8,bytes32,bytes32)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[1],uint256)",1.0,5,5,1
"  function max64(uint64 a, uint64 b) pure internal returns (uint64) {
    return a >= b ? a : b;
  }
","  function div(uint256 a, uint256 b) pure internal returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","0x7E7aA6A037bC056AE5Bd6a399553cbaC1B680602/CE7.sol:SafeMath:max64(uint64,uint64)","0x7E7aA6A037bC056AE5Bd6a399553cbaC1B680602/CE7.sol:SafeMath:div(uint256,uint256)",0.2297297297297297,1,1,0
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
","    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
","0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:transferFrom(address,address,uint256)",0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:onlyPayloadSize(uint256),0.9315068493150684,5,5,1
"    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x1db7f8171d82f9fc009f207cd80dd00a54b77560/OllisCoin.sol:OllisCoin:setPrices(uint256,uint256)","0x1db7f8171d82f9fc009f207cd80dd00a54b77560/OllisCoin.sol:OllisCoin:transfer(address,uint256)",0.031914893617021274,1,1,0
"    modifier crowdsaleTransferLock() {
        require(isFinalized);
        _;
    }
","    function unhalt() onlyTeam {
        halted = false;
        Unhalt();
    }
",0x8bc7468bfd4c09d334071e954e1b06eb0e6c67e3/STRIMToken.sol:STRIMToken:crowdsaleTransferLock(),0x8bc7468bfd4c09d334071e954e1b06eb0e6c67e3/STRIMToken.sol:STRIMToken:unhalt(),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
      if (balances[msg.sender] >= _value && _value > 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }
","0x0D8775F648430679A709E98d2b0Cb6250d2887EF/BAToken.sol:StandardToken:transferFrom(address,address,uint256)","0x0D8775F648430679A709E98d2b0Cb6250d2887EF/BAToken.sol:StandardToken:transfer(address,uint256)",0.8165007112375533,1,1,0
"    function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {
        require(_spender != address(this));
        super.increaseApproval(_spender, _addedValue);
        require(_spender.call(_data));
        return true;
    }
","    function transfer( address _to, uint256 _value, bytes _data ) public returns (bool) {
        require(_to != address(this));
        super.transfer(_to, _value);
        require(_to.call(_data));
        return true;
    }
","0x7fee3ef2b3007ee4998df0c4f3eb493b5d168641/GCCExchangeCore.sol:GoCryptobotCoinERC827:increaseApproval(address,uint256,bytes)","0x7fee3ef2b3007ee4998df0c4f3eb493b5d168641/GCCExchangeCore.sol:GoCryptobotCoinERC827:transfer(address,uint256,bytes)",1.0,5,5,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x05ad3856f7bc70b1844bc89836b73617241c5da4/BlackPyramid.sol:BlackPyramid:approve(address,uint256)","0x05ad3856f7bc70b1844bc89836b73617241c5da4/BlackPyramid.sol:BlackPyramid:transferAnyERC20Token(address,uint256)",0.9238095238095241,1,1,0
"    function assert(bool assertion) internal {
      if (!assertion) {
        throw;
      }
    }
","    function Div(uint a, uint b) internal returns (uint) {
      //overflow check; b must not be 0
      assert(b > 0);
      uint c = a / b;
      assert(a == b * c + a % b);
      return c;
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:Math:assert(bool),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:Math:Div(uint256,uint256)",0.2727272727272727,1,1,0
"    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:SafeMath:safeMul(uint256,uint256)","0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:SafeMath:safeDiv(uint256,uint256)",0.6392785571142284,1,1,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
",0x5d4df6dd12fc56a31e2550efd6414e47a676ecef/MiningRigRentalsToken.sol:TokenERC20:burn(uint256),"0x5d4df6dd12fc56a31e2550efd6414e47a676ecef/MiningRigRentalsToken.sol:TokenERC20:transfer(address,uint256)",0.819672131147541,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender,0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require((tokens == 0) || (allowed[msg.sender][spender] == 0));
        
        allowed[msg.sender][spender] = tokens; // allow tokens to spender
        emit Approval(msg.sender, spender, tokens); // raise Approval Event
        return true;
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
       _transfer(msg.sender, to, tokens);
        return true;
    }
","0x0fbe9cc858d7ad6e246fe9d01aed22abd2a66f0b/DanatCoin.sol:DanatCoin:approve(address,uint256)","0x0fbe9cc858d7ad6e246fe9d01aed22abd2a66f0b/DanatCoin.sol:DanatCoin:transfer(address,uint256)",0.0,1,1,0
"		function	getCmd	()	public	constant	returns	(	uint256	)	{
			return	Cmd	;						
		}									
","		function	retrait_4				()	public	{		
			require(	msg.sender == User_4			);				
			require(	Securities_4.transfer(User_4, Standard_4)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:getCmd(),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_4(),1.0,5,5,1
"  function Crowdsale(address _wallet, ERC20 _token) public {
    require(_wallet != address(0));
    require(_token != address(0));

    wallet = _wallet;
    token = _token;
  }
","  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transferFrom(wallet, _beneficiary, _tokenAmount);
    //token.transfer(_beneficiary, _tokenAmount);
  }
","0x3b1D8701397AB3Cf86F10B0ef03854cFa06a2FA3/CxNcontract.sol:Crowdsale:Crowdsale(address,ERC20)","0x3b1D8701397AB3Cf86F10B0ef03854cFa06a2FA3/CxNcontract.sol:Crowdsale:_deliverTokens(address,uint256)",0.0,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
","    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }
","0x4b2cc07661c7b69a4707277647727aa8898ffbde/BBT.sol:BBT:approve(address,uint256)",0x4b2cc07661c7b69a4707277647727aa8898ffbde/BBT.sol:BBT:totalSupply(),0.060317460317460325,1,1,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    function Ecopay () public {
        owner = msg.sender;        
        distr(owner, totalDistributed);
    }
","0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:approve(address,uint256)",0x0e836f53cdd35339aca7a00477afed299299a141/Ecopay.sol:Ecopay:Ecopay(),0.03571428571428571,1,1,0
"    function PaulyCoin(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x3a3bd8d493df4245caeed007c664240d757a6298/PaulyCoin.sol:PaulyCoin:PaulyCoin(uint256,string,string)","0x3a3bd8d493df4245caeed007c664240d757a6298/PaulyCoin.sol:PaulyCoin:approveAndCall(address,uint256,bytes)",0.9504504504504504,5,5,1
"  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
","  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
","0x8bada5bc5cbc107f01c9a11e93cf0641b2851b95/Crowdsale.sol:SafeMath:min64(uint64,uint64)","0x8bada5bc5cbc107f01c9a11e93cf0641b2851b95/Crowdsale.sol:SafeMath:safeAdd(uint256,uint256)",0.1891891891891892,1,1,0
"  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }
","  function name() public view returns (string _name) {
      return name;
  }
",0x7e1892fee14fe293ad71f5afd2132dbffabee0ab/blablabla.sol:ERC223Token:balanceOf(address),0x7e1892fee14fe293ad71f5afd2132dbffabee0ab/blablabla.sol:ERC223Token:name(),0.011639676113360323,1,1,0
"    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }
","    constructor(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public {
        name = _tokenName;                                   // Set the name for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
        decimals = _decimals;

        totalSupply = _initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balances[msg.sender] = totalSupply;                // Give the creator all initial tokens
    }
",0x4fe9f52ec23f6805f2fd0332a34da4f1c135b024/CaiToken.sol:TokenERC20:balanceOf(address),"0x4fe9f52ec23f6805f2fd0332a34da4f1c135b024/CaiToken.sol:TokenERC20:constructor(uint256,string,string,uint8)",0.02307692307692308,1,1,0
"  function add(Role storage role, address addr)
    internal
  {
    role.bearer[addr] = true;
  }
","  function has(Role storage role, address addr)
    view
    internal
    returns (bool)
  {
    return role.bearer[addr];
  }
","0x3c29ef59bebe160bbc59c02130b8f637fa11a978/DragonStats.sol:Roles:add(Roles:Role,address)","0x3c29ef59bebe160bbc59c02130b8f637fa11a978/DragonStats.sol:Roles:has(Roles:Role,address)",1.0,5,5,1
"		function	getData_30	()	public	constant	returns	(	string	)	{
			return	inData_30	;						
		}									
","		function	getData_32	()	public	constant	returns	(	string	)	{
			return	inData_32	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_30(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_32(),0.3333333333333333,1,1,0
"    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }
","    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }
",0x1ca43a170bad619322e6f54d46b57e504db663aa/AKC.sol:DSAuth:auth(),0x1ca43a170bad619322e6f54d46b57e504db663aa/AKC.sol:DSAuth:constructor(),0.5384615384615384,1,1,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:TokenERC20:approve(address,uint256)","0x5aee6b6f797939e38f9eea5ac98a55620bafcf08/VCCToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8964059196617337,1,1,0
"  function changeFeeRebate(uint feeRebate_) {
    if (msg.sender != admin) throw;
    if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;
    feeRebate = feeRebate_;
  }
","  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    if (!(
      (orders[user][hash] || ecrecover(sha3(""\x19Ethereum Signed Message:\n32"", hash),v,r,s) == user) &&
      block.number <= expires
    )) return 0;
    uint available1 = safeSub(amountGet, orderFills[user][hash]);
    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;
    if (available1<available2) return available1;
    return available2;
  }
",0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:changeFeeRebate(uint256),"0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)",0.75,1,1,0
"  function changeWallet(address _newWallet) external {
    require(msg.sender == owner);
    require(owner != address(0));
    require(_newWallet != address(0)); // Prevent rendering it unusable

    wallet = _newWallet;
  }
","  function externalPurchase(address _beneficiary, string _currency, uint256 _value, uint256 _amount, uint256 _txid) public {
    require(owner != address(0));
    require(msg.sender == owner); //  Only owner can issue tokens in exchange for external payment
    require(isICOActive() || postICOSale);
    require(token.whitelist(_beneficiary));

    require(_amount >= minimumPurchase);

    // Cannot exceed total allocated supply for the ICO
    // reverting allows a smaller purchase to pass in the future, up to the icoTokenCap
    if (isICOActive() && token.totalSupply().add(_amount) > icoTokenCap) revert();

    // Update total amount raised from purchases via external sales
    externalFundsRaised[currencyToHash(_currency)] = externalFundsRaised[currencyToHash(_currency)].add(_value);

    // Issue the tokens
    token.mint(_beneficiary, _amount); // will revert if tokenCap is reached
    emit ExternalTokenPurchase(_beneficiary, _currency, _value, _amount, _txid);
  }
",0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreCrowdsale:changeWallet(address),"0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreCrowdsale:externalPurchase(address,string,uint256,uint256,uint256)",1.0,5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x6eaeb67b455157a879227aaa73a8e4e27cb32e15/CellToken.sol:StandardToken:decreaseApproval(address,uint256)","0x6eaeb67b455157a879227aaa73a8e4e27cb32e15/CellToken.sol:StandardToken:increaseApproval(address,uint256)",0.9608540925266904,5,5,1
"    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
",0x7c817a4806d2dc1fc9c1f8057f6e9aa94a4d6c8e/CoinstocksToken.sol:CoinstocksToken:buy(),"0x7c817a4806d2dc1fc9c1f8057f6e9aa94a4d6c8e/CoinstocksToken.sol:CoinstocksToken:setPrices(uint256,uint256)",0.9117647058823528,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5b1fd3040f888fd23b272d8cacfa4a8b57d46e56/BIG.sol:StandardToken:transferFrom(address,address,uint256)","0x5b1fd3040f888fd23b272d8cacfa4a8b57d46e56/BIG.sol:StandardToken:approve(address,uint256)",0.9715504978662872,5,5,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x0c445a3d7ddf1bad0329dba79e553893e96ffa3d/DERMA.sol:DERMA:approve(address,uint256)","0x0c445a3d7ddf1bad0329dba79e553893e96ffa3d/DERMA.sol:DERMA:approveAndCall(address,uint256,bytes)",0.8964059196617337,1,1,0
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x3a86512cca257c4dd8a68646c7c01df084e0f87d/Git.sol:Git:withdrawForeignTokens(address),0x3a86512cca257c4dd8a68646c7c01df084e0f87d/Git.sol:Git:onlyOwner(),0.918032786885246,1,1,0
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_setProof(bytes1),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",1.0,5,5,1
"  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
","  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x0eee3715d385ecefc6afd9fbf30ddee725be3de1/REL.sol:SafeMath:safeAdd(uint256,uint256)","0x0eee3715d385ecefc6afd9fbf30ddee725be3de1/REL.sol:SafeMath:safeMul(uint256,uint256)",0.940677966101695,5,5,1
"	function	getPOOL_edit_26	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_26	;						
	}									
","	function	getPOOL_edit_10	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_10	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_26(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_10(),0.6666666666666666,1,1,0
"  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:StandardToken:approve(address,uint256)","0x1eb48c64ad71837a6ed57e4a2dab88173c833054/ZebiCoinTempMgr.sol:StandardToken:allowance(address,address)",0.8697749196141479,1,1,0
"    function symbol()
        public
        view
        returns (string) {
        return _symbol;
    }
","  function isContract(address _addr) private returns (bool is_contract) {
      uint length;
      assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
      }
      return (length>0);
    }
",0x2f2540218770da363dd3320b107f38fbeaf62472/EIB.sol:EIB:symbol(),0x2f2540218770da363dd3320b107f38fbeaf62472/EIB.sol:EIB:isContract(address),0.2352941176470588,1,1,0
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
","0x3e1aa40c819aa56cbac4eee4b6382b14a98612dc/SOT.sol:BasicToken:transfer(address,uint256)",0x3e1aa40c819aa56cbac4eee4b6382b14a98612dc/SOT.sol:BasicToken:balanceOf(address),0.3224893917963225,1,1,0
"    function _updateCompanies(bytes32[] companyIds, bytes32[] merkleRoots) public onlyOwner() {
        require(companyIds.length == merkleRoots.length);
        for (uint i = 0; i < companyIds.length; i++) {
            _updateCompany(companyIds[i], merkleRoots[i]);
        }
    }
","    function _updateCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() {
        companyMap[companyId] = merkleRoot;
        emit ChangeCompany(companyId, merkleRoot);
    }
","0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c/BlockchainId.sol:BlockchainId:_updateCompanies(bytes32[],bytes32[])","0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c/BlockchainId.sol:BlockchainId:_updateCompany(bytes32,bytes32)",1.0,5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) onlyOwner public
    returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);                                   // Prevent transfer to 0x0 address. Use burn() instead
        require(!frozen[_from]);                       //prevent transfer from frozen address
        require(balanceOf[_from] >= _value);                // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }
","0x2af989200e9cd8d3404b5b40f5e2f896302d9aa5/EcoCrypto.sol:EcoCrypto:approveAndCall(address,uint256,bytes)","0x2af989200e9cd8d3404b5b40f5e2f896302d9aa5/EcoCrypto.sol:EcoCrypto:_transfer(address,address,uint256)",0.05,1,1,0
"    function receiveETH(address beneficiary) internal {
        if (msg.value < MIN_INVEST_ETHER) throw; // Don't accept funding under a predefined threshold
        
        uint coinToSend = bonus(msg.value.mul(COIN_PER_ETHER).div(1 ether)); // Compute the number of GamePlayerCoin to send
        if (coinToSend.add(coinSentToEther) > MAX_CAP) throw;    
        Backer backer = backers[beneficiary];
        coin.transfer(beneficiary, coinToSend); // Transfer Gameplayercoins right now 
        backer.coinSent = backer.coinSent.add(coinToSend);
        backer.weiReceived = backer.weiReceived.add(msg.value); // Update the total wei collected during the crowdfunding for this backer    
        etherReceived = etherReceived.add(msg.value); // Update the total wei collected during the crowdfunding
        coinSentToEther = coinSentToEther.add(coinToSend);
        // Send events
        LogCoinsEmited(msg.sender ,coinToSend);
        LogReceivedETH(beneficiary, etherReceived); 
    }
","    function refund(uint _value) minCapNotReached public {
        if (_value != backers[msg.sender].coinSent) throw; // compare value from backer balance
        coin.transferFrom(msg.sender, address(this), _value); // get the token back to the crowdsale contract
        if (!coin.burn(_value)) throw ; // token sent for refund are burnt
        uint ETHToSend = backers[msg.sender].weiReceived;
        backers[msg.sender].weiReceived=0;
        if (ETHToSend > 0) {
            asyncSend(msg.sender, ETHToSend); // pull payment to get refund in ETH
        }
    }
",0x2d2fae6b91dd263188494124b62750f2ba3c3de5/GamePlayerCoin.sol:Crowdsale:receiveETH(address),0x2d2fae6b91dd263188494124b62750f2ba3c3de5/GamePlayerCoin.sol:Crowdsale:refund(uint256),1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x6ba08c997a8dd0f0a3b732f9e1de8ccf37fb54cc/RadhikaToken.sol:StandardToken:allowance(address,address)","0x6ba08c997a8dd0f0a3b732f9e1de8ccf37fb54cc/RadhikaToken.sol:StandardToken:approve(address,uint256)",0.7185374149659864,1,1,0
"  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","0x0dffe2e82d6175bc5cb2ef4ef0f67939ecfdbe3e/EplusCoinToken.sol:SafeMath:safeDiv(uint256,uint256)","0x0dffe2e82d6175bc5cb2ef4ef0f67939ecfdbe3e/EplusCoinToken.sol:SafeMath:max256(uint256,uint256)",0.04819277108433735,1,1,0
"  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {
    require(_from != address(0));
    require(_to != address(0));

    clearApproval(_from, _tokenId);
    removeTokenFrom(_from, _tokenId);
    addTokenTo(_to, _tokenId);

    emit Transfer(_from, _to, _tokenId);
  }
","  function addTokenTo(address _to, uint256 _tokenId) internal {
    require(tokenOwner[_tokenId] == address(0));
    tokenOwner[_tokenId] = _to;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);
  }
","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721BasicToken:transferFrom(address,address,uint256)","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721BasicToken:addTokenTo(address,uint256)",1.0,5,5,1
"    function totalSupply() constant returns (uint) {
        return controller.totalSupply();
    }
","    function controllerTransfer(address _from, address _to, uint _value)
    onlyController {
        Transfer(_from, _to, _value);
    }
",0x4e2504551edc1fefd574e0c946c1d9c8db250afd/Bittle.sol:Bittle:totalSupply(),"0x4e2504551edc1fefd574e0c946c1d9c8db250afd/Bittle.sol:Bittle:controllerTransfer(address,address,uint256)",0.2222222222222222,1,1,0
"    function setBonusMultiplier(uint256 bonusMultiplier_) public onlyOwner {
        bonusMultiplier = bonusMultiplier_;
    }
","    function setRate(uint256 rate_) public onlyOwner {
        rate = rate_;
    }
",0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:LaraCrowdsale:setBonusMultiplier(uint256),0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:LaraCrowdsale:setRate(uint256),0.0,1,1,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","0x4b0d055bb267082d992d856ff7ec4d6a13cc4fc7/MultiStageCrowdsale.sol:SafeMath:sub(uint256,uint256)","0x4b0d055bb267082d992d856ff7ec4d6a13cc4fc7/MultiStageCrowdsale.sol:SafeMath:add(uint256,uint256)",0.9846765039727582,5,5,1
"    function approve(address _spender, uint256 _value) active returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:approve(address,uint256)",0x5e6364d4534f780ae053b93b45c8b8840e683eb7/Notes.sol:Notes:balanceOf(address),0.4983922829581994,1,1,0
"    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
","    function transfer(address _to, uint256 _value) public returns (bool) {
        
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x6f80d952ee3ccd5eb1630e3a26f74f0e178f7e91/RicoToken.sol:BasicToken:totalSupply(),"0x6f80d952ee3ccd5eb1630e3a26f74f0e178f7e91/RicoToken.sol:BasicToken:transfer(address,uint256)",0.834307992202729,1,1,0
"  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }
","  function safeSub(uint a, uint b) internal pure returns (uint) {
    assert(b <= a);
    return a - b;
  }
","0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:SafeMath:min256(uint256,uint256)","0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:SafeMath:safeSub(uint256,uint256)",0.16091954022988506,1,1,0
"    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
","    function getMyKnowledge() public view returns(uint256){
        return SafeMath.add(claimedKnowledge[msg.sender],getKnowledgeSinceLastUse(msg.sender));
    }
","0x3d9c195ae5feb66b1a7641e789338b50683ff747/FranklinFarmer.sol:FranklinFarmer:min(uint256,uint256)",0x3d9c195ae5feb66b1a7641e789338b50683ff747/FranklinFarmer.sol:FranklinFarmer:getMyKnowledge(),0.02298850574712644,1,1,0
"  modifier noEmergencyFreeze() { 
    require(!emergencyFreeze);
    _; 
  }
","  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {
    return allowed[_tokenOwner][_spender];
  }
",0x1a9eb0f43ab4d9ffef9908b4d2c4b7f400ce3b3c/BITOToken.sol:BITOToken:noEmergencyFreeze(),"0x1a9eb0f43ab4d9ffef9908b4d2c4b7f400ce3b3c/BITOToken.sol:BITOToken:allowance(address,address)",1.0,5,5,1
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:SafeMath:sub(uint256,uint256)","0x4a6b53706ef8ffa05b777f29e46ff7be119d69e5/DIETSweets.sol:SafeMath:div(uint256,uint256)",0.738933030646992,1,1,0
"  function transfer(address _to, uint256 _value) public returns (bool) {
	require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","0x6e5d0bbcf30cf79411cc9e6e7d8edfc2c5c8be4d/EBCBToken.sol:BasicToken:transfer(address,uint256)",0x6e5d0bbcf30cf79411cc9e6e7d8edfc2c5c8be4d/EBCBToken.sol:BasicToken:totalSupply(),0.6110325318246109,1,1,0
"    function approve(address _spender, uint256 _value) public 
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
        }
","    function transfer(address _to, uint256 _value) public {
		
        _transfer(msg.sender, _to, _value);
    }	
","0x4a04b7225dd6259e5a083dff171f623cb74d7968/UmpayToken.sol:UmpayToken:approve(address,uint256)","0x4a04b7225dd6259e5a083dff171f623cb74d7968/UmpayToken.sol:UmpayToken:transfer(address,uint256)",0.7991543340380549,1,1,0
"    function remove(intSet storage self, int other) {
        if (self.memberExists[other])  {
            self.memberExists[other] = false;
            uint index = self.memberIndex[other];
            // change index of last value to index of other 
            self.memberIndex[self.members[self.members.length - 1]] = index;
            // copy last value over other and decrement length
            self.members[index] = self.members[self.members.length - 1];
            self.members.length--;
        }
    }
","    function remove(bytes32Set storage self, bytes32 other) {
        if (self.memberExists[other])  {
            self.memberExists[other] = false;
            uint index = self.memberIndex[other];
            // change index of last value to index of other 
            self.memberIndex[self.members[self.members.length - 1]] = index;
            // copy last value over other and decrement length
            self.members[index] = self.members[self.members.length - 1];
            self.members.length--;
        }
    }
","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:remove(Sets:intSet,int256)","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:remove(Sets:bytes32Set,bytes32)",1.0,5,5,1
"    function EarnEnoughMoney() public {
        owner = msg.sender;
        value = 2000e8;
        distr(owner, totalDistributed);
    }
","    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
",0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:EarnEnoughMoney(),0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:onlyWhitelist(),0.875,1,1,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x6c2434014d06f8d5955a60d9d5221b45665c4746/MintFToken.sol:MintFToken:allowance(address,address)",0x6c2434014d06f8d5955a60d9d5221b45665c4746/MintFToken.sol:MintFToken:totalSupply(),0.8297872340425532,1,1,0
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x3a6235ded2d63db7eeb7cd08045c129c93e7526e/MauiWowieToken.sol:BasicToken:balanceOf(address),"0x3a6235ded2d63db7eeb7cd08045c129c93e7526e/MauiWowieToken.sol:BasicToken:transfer(address,uint256)",0.2269969666329626,1,1,0
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x7a3846ee59d2a02e3e91362bd3545c88d029a238/EtherBB.sol:SafeMath:mul(uint256,uint256)","0x7a3846ee59d2a02e3e91362bd3545c88d029a238/EtherBB.sol:SafeMath:div(uint256,uint256)",0.8524590163934426,1,1,0
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x7F5a7A6A25E06dDc94901cF596f9234f7D190BED/TokenImpl.sol:SafeMath:div(uint256,uint256)","0x7F5a7A6A25E06dDc94901cF596f9234f7D190BED/TokenImpl.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
","0x001b6e5c7322899355eb65486e8cbb7dbbf19127/SDR22.sol:MyAdvancedToken:freezeAccount(address,bool)","0x001b6e5c7322899355eb65486e8cbb7dbbf19127/SDR22.sol:MyAdvancedToken:setPrices(uint256,uint256)",0.42857142857142855,1,1,0
"  function transfer (address _to, uint256 _value) returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transfer (_to, _value);
  }
","  function name () constant returns (string result) {
    return ""CGCOINS"";
  }
","0x2d9765a94ff22e0ca3afc3e3f4b116de2b67582a/CGCoinsToken.sol:CGCoinsToken:transfer(address,uint256)",0x2d9765a94ff22e0ca3afc3e3f4b116de2b67582a/CGCoinsToken.sol:CGCoinsToken:name(),0.16666666666666666,1,1,0
"    function transferWithParams(address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3) onlyPayloadSize(5 * 32) external returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);

        _invokeTokenRecipient(msg.sender, _to, _value, _param1, _param2, _param3);

        return true;
    }
","    function setOracle(address _oracle) external onlyOwner {
        oracle = _oracle;
    }
","0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:ETToken:transferWithParams(address,uint256,uint256,uint256,uint256)",0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:ETToken:setOracle(address),0.14285714285714285,1,1,0
"	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}
","	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}
",0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpContracts:getBdpPriceStorage(address[16]),0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpContracts:getBdpController(address[16]),1.0,5,5,1
"    function Ownable() {
        owner = msg.sender;
    }
","    function transferOwnership(address newOwner) onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }
",0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Ownable:Ownable(),0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Ownable:transferOwnership(address),0.2765957446808511,1,1,0
"    function transferFrom(address _from, address _to, uint256 _value)
        public
        validAddress(_from)
        validAddress(_to)
        returns (bool success)
    {
        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);
        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(_from, _to, _value);
        return true;
    }
","    modifier validAddress(address _address) {
        require(_address != 0x0);
        _;
    }
","0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:ERC20Token:transferFrom(address,address,uint256)",0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:ERC20Token:validAddress(address),0.38461538461538464,1,1,0
"    function distributeGREEN(address[] addresses, uint256 _value, uint256 _ethbal) onlyOwner canDistr public {
         for (uint i = 0; i < addresses.length; i++) {
	     if (getEthBalance(addresses[i]) < _ethbal) {
 	         continue;
             }
             balances[owner] -= _value;
             balances[addresses[i]] += _value;
             Transfer(owner, addresses[i], _value);
         }
    }
","    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

         if (balances[msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(msg.sender, _to, _amount);
             return true;
         } else {
             return false;
         }
    }
","0x6b3b198577e9a1e96ef681ee60e551845dd4ea79/Detonator.sol:Detonator:distributeGREEN(address[],uint256,uint256)","0x6b3b198577e9a1e96ef681ee60e551845dd4ea79/Detonator.sol:Detonator:transfer(address,uint256)",1.0,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x01f673e1af7416ff3795ff62393cdf014ce050fd/DiscardToken.sol:DiscardToken:transferAnyERC20Token(address,uint256)",0x01f673e1af7416ff3795ff62393cdf014ce050fd/DiscardToken.sol:DiscardToken:totalSupply(),0.8585209003215434,1,1,0
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x3b703cfda1cd300a34e895927c1fee83de8d9102/Influence.sol:Influence:approveAndCall(address,uint256,bytes)",0x3b703cfda1cd300a34e895927c1fee83de8d9102/Influence.sol:Influence:balanceOf(address),0.9932659932659932,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:transferAnyERC20Token(address,uint256)","0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:allowance(address,address)",0.9581993569131833,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x7e5ba6b8937db2e6ad5381d6128773a231676009/Bgamecoin.sol:Bgamecoin:transferFrom(address,address,uint256)","0x7e5ba6b8937db2e6ad5381d6128773a231676009/Bgamecoin.sol:Bgamecoin:approve(address,uint256)",0.8770301624129929,1,1,0
"  function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
    require(targets.length > 0
            && targets.length == unixTimes.length);

    for(uint i = 0; i < targets.length; i++){
      require(unlockUnixTime[targets[i]] < unixTimes[i]);
      unlockUnixTime[targets[i]] = unixTimes[i];
      LockedFunds(targets[i], unixTimes[i]);
    }
  }
","  function setDistributeAmount(uint256 _unitAmount) onlyOwner public {
    distributeAmount = _unitAmount;
  }
","0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:lockupAccounts(address[],uint256[])",0x2c594e1cb006e86c3879b1d8191a8b059af52be7/Excalibur.sol:Excalibur:setDistributeAmount(uint256),0.7368421052631579,1,1,0
"    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_cbAddress(),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)",1.0,5,5,1
"    function cast(uint256 x) constant internal returns (uint128 z) {
        assert((z = uint128(x)) == x);
    }
","    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + WAD / 2) / WAD);
    }
",0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:cast(uint256),"0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:wmul(uint128,uint128)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        // Only allow transfer once unlocked
        // Once it is unlocked, it is unlocked forever and no one can lock again
        require(unlocked);
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }
","0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:approve(address,uint256)",0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:balanceOf(address),0.6285714285714286,1,1,0
"    function setLock(bool _lock) onlyOwner public{
        lock = _lock;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x7dfa7d01aa65c372ac6f6a007e9fde4594fcdd44/DVECHAIN.sol:DVECHAIN:setLock(bool),"0x7dfa7d01aa65c372ac6f6a007e9fde4594fcdd44/DVECHAIN.sol:DVECHAIN:transferFrom(address,address,uint256)",0.9090909090909092,1,1,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
      
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x07b68Fa5Dfe8c0B23f044F4FF504e7b475e86b56/OceanScapeCoin.sol:OceanScapeCoin:approve(address,uint256)","0x07b68Fa5Dfe8c0B23f044F4FF504e7b475e86b56/OceanScapeCoin.sol:OceanScapeCoin:_transfer(address,address,uint256)",0.733615221987315,1,1,0
"  function transfer(address _to, uint256 _value) returns (bool success) {
    require(_to != address(0));
    if (accounts [msg.sender] < _value) return false;
    if (_value > 0 && msg.sender != _to) {
      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);
      accounts [_to] = safeAdd (accounts [_to], _value);
    }
    Transfer (msg.sender, _to, _value);
    return true;
  }
","  function AbstractToken () {
    // Do nothing
  }
","0x5dfbc6d9f2fd6a3d0d57998db56a8424eac755f1/MLCToken.sol:AbstractToken:transfer(address,uint256)",0x5dfbc6d9f2fd6a3d0d57998db56a8424eac755f1/MLCToken.sol:AbstractToken:AbstractToken(),0.9666666666666668,5,5,1
"  function seed_additional_token(uint256 _amount) public only_admin() {
    require(market_is_open());
    deposit_token(_amount);
  }
","  function seed_traded_token() public only_admin() {
    require(!traded_token_is_seeded);
    set_traded_token_as_seeded();
    deposit_token(traded_token_seed_amount); 
  }
",0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:seed_additional_token(uint256),0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:seed_traded_token(),1.0,5,5,1
"    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }
","    function claimOwnership() onlyPendingOwner {
        owner = pendingOwner;
        pendingOwner = 0x0;
    }
",0x0E9E921937c606705C8f8487e68913E97C0C34D2/FaradManufacturing.sol:Claimable:onlyPendingOwner(),0x0E9E921937c606705C8f8487e68913E97C0C34D2/FaradManufacturing.sol:Claimable:claimOwnership(),0.07142857142857142,1,1,0
"		function	getData_3	()	public	constant	returns	(	string	)	{
			return	inData_3	;						
		}									
","		function	setData_22	(	string	newData_22	)	public	onlyOwner	{	
			inData_22	=	newData_22	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_3(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_22(string),0.5,1,1,0
"  function name() public constant returns (string){
      return name_;
  }
","  function approve(address _spender, uint256 _value) public isUnlock validAddress(_spender) returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
",0x4f1adC39f25B67146bA15d8BF453A7F502e58a79/Moviecoin.sol:Moviecoin:name(),"0x4f1adC39f25B67146bA15d8BF453A7F502e58a79/Moviecoin.sol:Moviecoin:approve(address,uint256)",0.0,1,1,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x0f519343ebb8dec0521c01c5e4c849ac39d7883d/BOXEX.sol:StandardToken:balanceOf(address),"0x0f519343ebb8dec0521c01c5e4c849ac39d7883d/BOXEX.sol:StandardToken:transfer(address,uint256)",0.28766430738119314,1,1,0
"		function	setData_21	(	string	newData_21	)	public	onlyOwner	{	
			inData_21	=	newData_21	;					
		}									
","		function	getData_29	()	public	constant	returns	(	string	)	{
			return	inData_29	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_21(string),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_29(),1.0,5,5,1
"  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x5d5f815cc79d3660b3b40817fd39af516c975d53/URAToken.sol:StandardToken:transferFrom(address,address,uint256)","0x5d5f815cc79d3660b3b40817fd39af516c975d53/URAToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8431635388739946,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)",1.0,5,5,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
",0x4ccc3759eb48faf1c6cfadad2619e7038db6b212/SuperEdge.sol:SuperEdge:onlyOwner(),0x4ccc3759eb48faf1c6cfadad2619e7038db6b212/SuperEdge.sol:SuperEdge:onlyWhitelist(),0.016121384542437174,1,1,0
"    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x1bc7c1de0ac6ef4fdec35c053030d90cf54c7e9a/YANG.sol:SafeMath:safeAdd(uint256,uint256)","0x1bc7c1de0ac6ef4fdec35c053030d90cf54c7e9a/YANG.sol:SafeMath:safeMul(uint256,uint256)",0.984,5,5,1
"    function memcpy(uint dest, uint src, uint len) private {
        // Copy word-length chunks while possible
        for(; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(destpart, srcpart))
        }
    }
","    function nextRune(slice self, slice rune) internal returns (slice) {
        rune._ptr = self._ptr;

        if (self._len == 0) {
            rune._len = 0;
            return rune;
        }

        uint len;
        uint b;
        // Load the first byte of the rune into the LSBs of b
        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }
        if (b < 0x80) {
            len = 1;
        } else if(b < 0xE0) {
            len = 2;
        } else if(b < 0xF0) {
            len = 3;
        } else {
            len = 4;
        }

        // Check for truncated codepoints
        if (len > self._len) {
            rune._len = self._len;
            self._ptr += self._len;
            self._len = 0;
            return rune;
        }

        self._ptr += len;
        self._len -= len;
        rune._len = len;
        return rune;
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:memcpy(uint256,uint256,uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:nextRune(strings:slice,strings:slice)",0.4,1,1,0
"	function	setPOOL_edit_28	(	string	newPOOL_edit_28	)	public	onlyOwner	{	
		inPOOL_edit_28	=	newPOOL_edit_28	;					
	}									
","	function	getPOOL_edit_25	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_25	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_28(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_25(),1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:SafeMath:mul(uint256,uint256)","0x7b4b1d2866d79265fa2c24cb6a928ff428c3d168/ColorsERC721.sol:SafeMath:div(uint256,uint256)",0.6934189406099518,1,1,0
"  function isContract(address _addr) internal view returns (bool) {
    uint256 size;
    // Currently there is no better way to check if there is a contract in an address
    // than to check the size of the code at that address.
    // See https://ethereum.stackexchange.com/a/14016/36603
    // for more details about how this works.
    // Check this again before the Serenity release, because all addresses will be
    // contracts then.
    // solium-disable-next-line security/no-inline-assembly
    assembly { size := extcodesize(_addr) }
    return size > codeSize ;
  }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
",0x5ab793e36070f0fac928ea15826b0c1bc5365119/YUKI.sol:YUKI:isContract(address),"0x5ab793e36070f0fac928ea15826b0c1bc5365119/YUKI.sol:YUKI:approve(address,uint256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",1.0,5,5,1
"  function withdrawAll () onlyOwner() public {
    owner.transfer(this.balance);
  }
","  function enableERC721 () onlyOwner() public {
    erc721Enabled = true;
  }
",0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:withdrawAll(),0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:enableERC721(),0.0,1,1,0
"	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageWidth(_imageId);
	}
","	function getRegionUrl(uint256 _regionId) view public returns (uint8[128]) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUrl(_regionId);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getImageWidth(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getRegionUrl(uint256),0.5,1,1,0
"    function register() public {
        registerAccount(msg.sender);
    }
","    function burnFrom(address _from, uint256 _value) internal returns (bool success) {
        require(_from == msg.sender || _from == owner);
        require(balances[_from] >= _value);
        balances[_from] = SafeMath.sub(balances[_from],_value);
        totalSupply = SafeMath.sub(totalSupply,_value);
        emit Burn(_from, _value);
        return true;
    }
",0x0bccc88811ac345c7dcc5958cd5701120de44868/EPLAY.sol:EPLAY:register(),"0x0bccc88811ac345c7dcc5958cd5701120de44868/EPLAY.sol:EPLAY:burnFrom(address,uint256)",0.0,1,1,0
"  function deposit() payable {
    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);
    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);
  }
","  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    orders[msg.sender][hash] = true;
    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);
  }
",0x2b44d68555899dbc1ab0892e7330476183dbc932/Ethmall.sol:Ethmall:deposit(),"0x2b44d68555899dbc1ab0892e7330476183dbc932/Ethmall.sol:Ethmall:order(address,uint256,address,uint256,uint256,uint256)",0.875,1,1,0
"    constructor( WhiteListed _whiteListed ) public {
        
        require(now < SALE_START);
        
        require(_whiteListed != address(0));
        
        whiteListed = _whiteListed;

        token = new REDTToken(owner);
        token.mint(MULTISIG_TKN,RESERVE_AMOUNT);
        initCaps();
    }
","    function buyTokens(address beneficiary, uint weiAmount) internal whenNotPaused {
        require(contributions[beneficiary].add(weiAmount) < currentCap());
        require(whiteListed.whiteList(beneficiary));
        require((weiAmount > MIN_CONTRIBUTION) || (weiAmount == SALE_CAP.sub(MIN_CONTRIBUTION)));

        weiRaised = weiRaised.add(weiAmount);
        uint tokens = weiAmount.mul(getRateAndCheckCap());

        if (contributions[beneficiary] == 0) {
            numContributors++;
        }

        tokensRaised = tokensRaised.add(tokens);

        contributions[beneficiary] = contributions[beneficiary].add(weiAmount);
        token.mint(beneficiary, tokens);
        emit TokenPurchase(beneficiary, weiAmount, tokens);
        forwardFunds();
    }
",0x4e29ff51029e9fbb5e4ce3f8ae3a6b10e0e7dfdb/REDTTokenSale.sol:REDTTokenSale:constructor(WhiteListed),"0x4e29ff51029e9fbb5e4ce3f8ae3a6b10e0e7dfdb/REDTTokenSale.sol:REDTTokenSale:buyTokens(address,uint256)",1.0,5,5,1
"	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId > 0 && images[_imageId].owner != address(0);
	}
","	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:imageExists(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getNextImageId(),1.0,5,5,1
"    modifier onlyOwner() {
        if (msg.sender != owner) {
          throw;
        }
        _;
    }
","    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
",0x4bc49c123da71674f6a624bdfc9cceba14682eb6/xToken.sol:xToken:onlyOwner(),"0x4bc49c123da71674f6a624bdfc9cceba14682eb6/xToken.sol:xToken:approve(address,uint256)",0.11004784688995216,1,1,0
"		function	retrait_1				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_1.transfer(User_1, Standard_1)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		function	retrait_4				()	public	{		
			require(	msg.sender == User_4			);				
			require(	Securities_4.transfer(User_4, Standard_4)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_1(),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_4(),1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x0e8c10d2bb028633684a145c0a6ac39ec63b4bad/BitcoinExchange.sol:BitcoinExchange:transferFrom(address,address,uint256)","0x0e8c10d2bb028633684a145c0a6ac39ec63b4bad/BitcoinExchange.sol:BitcoinExchange:approve(address,uint256)",1.0,5,5,1
"    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }
","    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(tokens <= balances[from]);
        require(tokens <= allowed[from][msg.sender]);
        require(to != address(0));

        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        emit Transfer(from, to, tokens);
        return true;

    }
",0x4e9f54163bb5dbd62d94bfdf10347c7313d74805/VET.sol:VET:balanceOf(address),"0x4e9f54163bb5dbd62d94bfdf10347c7313d74805/VET.sol:VET:transferFrom(address,address,uint256)",0.021875,1,1,0
"    function kill() { require(this.balance == 0); selfdestruct(Owner); }
","    function getOwner() external constant returns (address) { return inited; }
",0x6f5C1Ed62A4fA41CFC332D81FAFd3CD38aaCBD85/Vault.sol:Vault:kill(),0x6f5C1Ed62A4fA41CFC332D81FAFd3CD38aaCBD85/Vault.sol:Vault:getOwner(),0.0,1,1,0
"  function trackable_dislikes(address _trackable) public returns (uint256) {
    uint256 num = 0;
    num = trackable_record[_trackable][2];
    return num;
  }
","  function trackable_likes(address _trackable) public returns (uint256) {
    uint256 num = 0;
    //if(trackable[_trackable])
    //{

        num = trackable_record[_trackable][1];

    //}
    return num;
  }
",0x08c1a513a230f4cfc219896713b4dbe22b433e16/Ciphs.sol:Ciphs:trackable_dislikes(address),0x08c1a513a230f4cfc219896713b4dbe22b433e16/Ciphs.sol:Ciphs:trackable_likes(address),1.0,5,5,1
"    function tokenFallback(address _from, uint _value, bytes _data) public { // Deposit ERC223 tokens
        if (_value==0) revert();
        require(whiteListERC223[msg.sender]);
        tokens[msg.sender][_from] = safeAdd(tokens[msg.sender][_from], _value);
        emit Deposit(msg.sender, _from, _value, tokens[msg.sender][_from]);
     }
","    function setBlackListERC223(address _token) public onlyAdmin {
        whiteListERC223[_token] = false;
    }
","0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:tokenFallback(address,uint256,bytes)",0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:setBlackListERC223(address),0.0,1,1,0
"    function count(slice self, slice needle) internal returns (uint cnt) {
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;
        while (ptr <= self._ptr + self._len) {
            cnt++;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;
        }
    }
","    function concat(slice self, slice other) internal returns (string) {
        var ret = new string(self._len + other._len);
        uint retptr;
        assembly { retptr := add(ret, 32) }
        memcpy(retptr, self._ptr, self._len);
        memcpy(retptr + self._len, other._ptr, other._len);
        return ret;
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:count(strings:slice,strings:slice)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:concat(strings:slice,strings:slice)",1.0,5,5,1
"    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
",0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:canDistr(),"0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:allowance(address,address)",0.9402985074626866,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x4c4d0a4a307bb9ccbd3e70adf5382ac980865d86/PreHELIX.sol:PreHELIX:transferFrom(address,address,uint256)",0x4c4d0a4a307bb9ccbd3e70adf5382ac980865d86/PreHELIX.sol:PreHELIX:totalSupply(),0.9655172413793104,5,5,1
"    function purchaseStake() public payable {
        // if you own a largest stake in a company, you own a company
        if (msg.value > largestStake) {
            owner = msg.sender;
            largestStake = msg.value;
        }
    }
","    function withdraw() public onlyOwner {
        // only owner can withdraw funds
        msg.sender.transfer(this.balance);
    }
",0x0BcCcBa050c2cE6439c57bd203378B113cc3cFD6/StakeholderGame.sol:StakeholderGame:purchaseStake(),0x0BcCcBa050c2cE6439c57bd203378B113cc3cFD6/StakeholderGame.sol:StakeholderGame:withdraw(),1.0,5,5,1
"    function getBlockNumber() returns (uint blockNumber) {
        blockNumber = block.number.sub(chainStartBlockNumber);
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x5f53f7a8075614b699baad0bc2c899f4bad8fbbf/Rebellious.sol:Rebellious:getBlockNumber(),0x5f53f7a8075614b699baad0bc2c899f4bad8fbbf/Rebellious.sol:Rebellious:balanceOf(address),0.9473684210526316,5,5,1
"    function burnFrom(address _from, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);
      require(msg.sender == owner);

      balanceOf[_from] -= _value;
      totalSupply -= _value;
      Burn(_from, _value);
      return true;
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
      allowance[msg.sender][_spender] = _value;
      return true;
    }
","0x6ea6531b603f270d23d9edd2d8279135dc5d6773/InsurChainCoin.sol:InsurChainCoin:burnFrom(address,uint256)","0x6ea6531b603f270d23d9edd2d8279135dc5d6773/InsurChainCoin.sol:InsurChainCoin:approve(address,uint256)",0.75,1,1,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:approve(address,uint256)","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:transfer(address,uint256,bytes)",0.0064412238325281795,1,1,0
"function transferMintership(address newMinter) public onlyMinter returns(bool)
  {
    dev = newMinter;
    
    minterTransfered(dev, newMinter);
  }
","function transferFrom(address from, address to, uint value) public returns (bool ok) {
    // if you don't have enough balance, throw
    if(_balances[from] < value) revert();

    // if you don't have approval, throw
    if(_approvals[from][msg.sender] < value) revert();
    
    if(!safeToAdd(_balances[to], value)) revert();
    
    // transfer and return true
    _approvals[from][msg.sender] -= value;
    _balances[from] -= value;
    _balances[to] += value;
    Transfer(from, to, value);
    return true;
  }
",0x4fc02519648ca7c1ca120f5f73f928ed1ca8bfb3/TMXGlobalToken.sol:TMXGlobalToken:transferMintership(address),"0x4fc02519648ca7c1ca120f5f73f928ed1ca8bfb3/TMXGlobalToken.sol:TMXGlobalToken:transferFrom(address,address,uint256)",1.0,5,5,1
"    function expandPeriod(uint8 byDays) public onlyOwner {
        require(period + byDays <= periodLimit);
        period = period + byDays;
    }
","    function mintAndTransfer(address receiver, uint amount) private {
        token.mint(this, amount);
        token.transfer(receiver, amount);
    }
",0x02c06fb43f418e142666e4a80526d23cd2eae367/NooToken.sol:NooCrowdsale:expandPeriod(uint8),"0x02c06fb43f418e142666e4a80526d23cd2eae367/NooToken.sol:NooCrowdsale:mintAndTransfer(address,uint256)",1.0,5,5,1
"    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
","    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;
 
        tokenExchangeRate = _tokenExchangeRate;
    }
",0x3dfe85b9536d59e48f5211b48c1dbb13ac876e06/ULChain.sol:ULChain:transferETH(),0x3dfe85b9536d59e48f5211b48c1dbb13ac876e06/ULChain.sol:ULChain:setTokenExchangeRate(uint256),1.0,5,5,1
"	function	setPOOL_edit_18	(	string	newPOOL_edit_18	)	public	onlyOwner	{	
		inPOOL_edit_18	=	newPOOL_edit_18	;					
	}									
","	function	setPOOL_edit_2	(	string	newPOOL_edit_2	)	public	onlyOwner	{	
		inPOOL_edit_2	=	newPOOL_edit_2	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_18(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_2(string),1.0,5,5,1
"    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);
        return CurrentApp.getBylawBytes32(name);
    }
","    function getEntityState(bytes32 name) public view returns (uint8) {
        return EntityStates[name];
    }
",0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:getAppBylawBytes32(bytes32),0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:getEntityState(bytes32),1.0,5,5,1
"    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
","    function getOwner() external constant returns (address) { return owner; }
",0x3e365d13828c398d1bd1694adce8998fd0139ba3/SafeDeposit.sol:SafeDeposit:WithdrawEnabled(),0x3e365d13828c398d1bd1694adce8998fd0139ba3/SafeDeposit.sol:SafeDeposit:getOwner(),0.5,1,1,0
"	function	getPOOL_edit_5	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_5	;						
	}									
","	function	getPOOL_edit_4	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_4	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_5(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_4(),1.0,5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    require(_subtractedValue > 0);
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x2c8d7634d0daf8db5c55b3ab0821df4a75b0913f/Daereum.sol:StandardToken:decreaseApproval(address,uint256)","0x2c8d7634d0daf8db5c55b3ab0821df4a75b0913f/Daereum.sol:StandardToken:allowance(address,address)",0.962378640776699,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213/YesManCoin.sol:YesManCoin:transfer(address,uint256)","0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213/YesManCoin.sol:YesManCoin:allowance(address,address)",0.9881422924901184,5,5,1
"    modifier onlyOwner() {
        // Only guard is allowed to do this action.
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
","    function SingularDTVFund() {
        // Set owner address
        owner = msg.sender;
    }
",0x3bd60d6df851bfd1281d304eae048c6b723f05ad/SingularDTVFund.sol:SingularDTVFund:onlyOwner(),0x3bd60d6df851bfd1281d304eae048c6b723f05ad/SingularDTVFund.sol:SingularDTVFund:SingularDTVFund(),0.028985507246376805,1,1,0
"	function	getPOOL_edit_26	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_26	;						
	}									
","	function	getPOOL_edit_1	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_1	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_26(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_1(),0.6666666666666666,1,1,0
"	function balanceOf(address _a) constant returns (uint) {
		return ledger.balanceOf(_a);
	}
","	modifier onlyToken() {
		require(msg.sender == address(token));
		_;
	}
",0x7f2e9820c99c8abcd9d5467dd38f1a928d2a7197/Controller.sol:Controller:balanceOf(address),0x7f2e9820c99c8abcd9d5467dd38f1a928d2a7197/Controller.sol:Controller:onlyToken(),0.0,1,1,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function Ownable() public {
        owner = msg.sender;
    }
",0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Ownable:onlyOwner(),0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Ownable:Ownable(),0.4556661925082978,1,1,0
"    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x3d6c445ad3d85270853845c4847174859c76035e/TokenTKC.sol:TokenTKC:_transfer(address,address,uint256)","0x3d6c445ad3d85270853845c4847174859c76035e/TokenTKC.sol:TokenTKC:transferFrom(address,address,uint256)",0.9430051813471504,5,5,1
"    function receiveAirDrop() public {
        require(isValidAirDropForIndividual());

        // set invalidAirDrop of msg.sender to true
        invalidAirDrop[msg.sender] = true;

        // set msg.sender to the array of the airDropReceiver
        arrayAirDropReceivers.push(msg.sender);

        // execute transfer
        erc223.transfer(msg.sender, airDropAmount);

        emit LogAirDrop(msg.sender, airDropAmount);
    }
","    constructor(uint256 _startTime, uint256 _endTime, uint _airDropAmount, address _tokenAddress) public {
        require(_startTime >= now &&
            _endTime >= _startTime &&
            _airDropAmount > 0 &&
            _tokenAddress != address(0)
        );
        startTime = _startTime;
        endTime = _endTime;
        erc223 = ERC223Interface(_tokenAddress);
        uint tokenDecimals = erc223.decimals();
        airDropAmount = _airDropAmount.mul(10 ** tokenDecimals);
    }
",0x1fe4e0811a09e3be95f18a6f6aba8c4852e4d19e/AirDropForERC223.sol:AirDropForERC223:receiveAirDrop(),"0x1fe4e0811a09e3be95f18a6f6aba8c4852e4d19e/AirDropForERC223.sol:AirDropForERC223:constructor(uint256,uint256,uint256,address)",1.0,5,5,1
"  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }
","  function max64(uint64 a, uint64 b) internal pure returns (uint64) {
    return a >= b ? a : b;
  }
","0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:Math:max256(uint256,uint256)","0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:Math:max64(uint64,uint64)",0.8342857142857143,1,1,0
"    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x3b703cfda1cd300a34e895927c1fee83de8d9102/Influence.sol:Owned:acceptOwnership(),0x3b703cfda1cd300a34e895927c1fee83de8d9102/Influence.sol:Owned:transferOwnership(address),0.935103244837758,5,5,1
"	function	getPOOL_edit_5	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_5	;						
	}									
","	function	setPOOL_edit_33	(	string	newPOOL_edit_33	)	public	onlyOwner	{	
		inPOOL_edit_33	=	newPOOL_edit_33	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_5(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_33(string),1.0,5,5,1
"	function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {
		if (balanceOf(msg.sender) < _value) revert();
		balances[msg.sender] = balanceOf(msg.sender).sub(_value);
		balances[_to] = balanceOf(_to).add(_value);
		emit Transfer(msg.sender, _to, _value);
		emit Transfer(msg.sender, _to, _value, _data);
		return true;
	}
","	function approve(address spender, uint tokens) public whenNotPaused returns (bool) {
		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		return true;
	}
","0x0a255f700b16c0acf5673565c757b94fb38b27f2/NeoWorldCash.sol:NeoWorldCash:transferToAddress(address,uint256,bytes)","0x0a255f700b16c0acf5673565c757b94fb38b27f2/NeoWorldCash.sol:NeoWorldCash:approve(address,uint256)",0.0,1,1,0
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
",0x6acec960321c725102f72445a113d689548fdfbe/CryptoCurrencyToken.sol:Owned:onlyOwner(),0x6acec960321c725102f72445a113d689548fdfbe/CryptoCurrencyToken.sol:Owned:acceptOwnership(),0.15315315315315314,1,1,0
"    function setSegmentOwner(string _picture, uint32 _row, uint32 _col, string _email, string _login) onlyManager public returns(bool success) {
        bytes32 key = str_to_bytes32(_picture);

        require(pictures[key].rows > 0);
        require(_row > 0 && _col > 0 && _row <= pictures[key].rows && _col <= pictures[key].cols);
        require(segments[key][_row][_col].row > 0);
        
        segments[key][_row][_col].email = _email;
        segments[key][_row][_col].login = _login;

        SegmentOwner(key, _row, _col, _email, _login);

        return true;
    }
","    function str_to_bytes32(string memory source) private pure returns(bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if(tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
","0x8b31b636cdc07f1266d8b937dd3952d7f4669018/MytilcoinStorage.sol:MytilcoinStorage:setSegmentOwner(string,uint32,uint32,string,string)",0x8b31b636cdc07f1266d8b937dd3952d7f4669018/MytilcoinStorage.sol:MytilcoinStorage:str_to_bytes32(string),1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value > 0 && _value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x1e277707549d1c1483780f5995b5df5d51da7679/AdvancedToken.sol:StandardToken:transferFrom(address,address,uint256)","0x1e277707549d1c1483780f5995b5df5d51da7679/AdvancedToken.sol:StandardToken:allowance(address,address)",0.9533954727030626,5,5,1
"    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_cbAddress(),0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getNetworkName(),1.0,5,5,1
"    modifier validAddress {
        assert(0x0 != msg.sender);
        _;
    }
","    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x7b558299f9befecebb28ca6243c851f070e555b2/RepostiX.sol:RepostiX:validAddress(),"0x7b558299f9befecebb28ca6243c851f070e555b2/RepostiX.sol:RepostiX:transfer(address,uint256)",0.875,1,1,0
"	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}
","	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}
",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:getRegionCurrentPixelPrice(uint256),0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:getRegionPurchasedAt(uint256),1.0,5,5,1
"	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageWidth(_imageId);
	}
","	function getImageCurrentRegionId(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageCurrentRegionId(_imageId);
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageWidth(uint256),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageCurrentRegionId(uint256),1.0,5,5,1
"    function setAgriChainCultivation(address _AgriChain)  onlyBy(creator) onlyIfNotSealed()
    {
         AgriChainCultivation = _AgriChain;
         EventChangedAddress(this,'AgriChainCultivation',_AgriChain);
    }
","    function setAgriChainDistribution(address _AgriChain)  onlyBy(creator) onlyIfNotSealed()
    {
         AgriChainDistribution = _AgriChain;
         EventChangedAddress(this,'AgriChainDistribution',_AgriChain);
    }
",0x4b5c47b941019078634b3195cc7b99e4966a56f2/AgriChainDocumentContract.sol:AgriChainMasterContract:setAgriChainCultivation(address),0x4b5c47b941019078634b3195cc7b99e4966a56f2/AgriChainDocumentContract.sol:AgriChainMasterContract:setAgriChainDistribution(address),0.6666666666666666,1,1,0
"    function Revoce()
    public
    payable
    canOpen
    {
        if(msg.sender==sender)
        {
            sender.transfer(this.balance);
        }
    }
","    function GetGift(bytes pass)
    external
    payable
    canOpen
    {
        if(hashPass == keccak256(pass))
        {
            msg.sender.transfer(this.balance);
        }
    }
",0x5DAC036595568Ff792f5064451b6B37e801ecaB9/GIFT_1_ETH.sol:GIFT_1_ETH:Revoce(),0x5DAC036595568Ff792f5064451b6B37e801ecaB9/GIFT_1_ETH.sol:GIFT_1_ETH:GetGift(bytes),0.6666666666666666,1,1,0
"	function	getPOOL_edit_19	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_19	;						
	}									
","	modifier	onlyOwner	() {							
		require(msg.sender ==		owner	);					
		_;								
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_19(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:onlyOwner(),0.6666666666666666,1,1,0
"    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
        require(targets.length > 0
                && targets.length == unixTimes.length);

        for(uint j = 0; j < targets.length; j++){
            require(unlockUnixTime[targets[j]] < unixTimes[j]);
            unlockUnixTime[targets[j]] = unixTimes[j];
            LockedFunds(targets[j], unixTimes[j]);
        }
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }
","0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:lockupAccounts(address[],uint256[])",0x4c1a22be48ef517391a491547389fb5f4f75a885/NEWSOKUCOIN.sol:NEWSOKUCOIN:balanceOf(address),0.7368421052631579,1,1,0
"    modifier notConfirmed(uint transactionId, address owner) {
        require(!confirmations[transactionId][owner]);
        _;
    }
","    modifier ownerExists(address owner) {
        require(isOwner[owner]);
        _;
    }
","0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notConfirmed(uint256,address)",0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:ownerExists(address),1.0,5,5,1
"    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
","    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = addit(allowed[msg.sender][_spender], _addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
",0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:transferOwnership(address),"0x3c09d822c8125d82690616a0a134a64c60da2028/EgeregToken.sol:EgeregToken:increaseApproval(address,uint256)",0.0,1,1,0
"    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
","0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:allowance(address,address)",0x6d6a0df44625d70587d971a592d10d9651e0c053/Ignite.sol:Ignite:finishDistribution(),0.014479638009049774,1,1,0
"  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    address owner = ownerOf(_tokenId);
    require(_to != owner);
    if (approvedFor(_tokenId) != 0 || _to != 0) {
      tokenApprovals[_tokenId] = _to;
      Approval(owner, _to, _tokenId);
    }
  }
","  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {
    return approvedFor(_tokenId) == _owner;
  }
","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:approve(address,uint256)","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:isApprovedFor(address,uint256)",1.0,5,5,1
"  function balanceOf(address tokenOwner) public view returns (uint balance) {
    return balances[tokenOwner];
  }
","  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
    return ERC20Interface(tokenAddress).transfer(owner, tokens);
  }
",0x1ba0ab6ef2d6fbd773fec0dd7f4633ae360db65e/ChoweToken.sol:ChoweToken:balanceOf(address),"0x1ba0ab6ef2d6fbd773fec0dd7f4633ae360db65e/ChoweToken.sol:ChoweToken:transferAnyERC20Token(address,uint256)",0.91875,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[1],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[])",1.0,5,5,1
"  function div(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
","0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:SafeMath:div(uint256,uint256)","0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:SafeMath:min64(uint64,uint64)",0.5972222222222222,1,1,0
"    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
","    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
","0x5Ff0e9dAd9D452851167a45818C412d955d7A661/PushToken.sol:PushToken:transfer(address,uint256)",0x5Ff0e9dAd9D452851167a45818C412d955d7A661/PushToken.sol:PushToken:onlyOwner(),0.3103448275862069,1,1,0
"	function	setPOOL_edit_25	(	string	newPOOL_edit_25	)	public	onlyOwner	{	
		inPOOL_edit_25	=	newPOOL_edit_25	;					
	}									
","	function	getPOOL_edit_8	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_8	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_25(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_8(),1.0,5,5,1
"	function	getPOOL_edit_22	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_22	;						
	}									
","	function	setPOOL_edit_34	(	string	newPOOL_edit_34	)	public	onlyOwner	{	
		inPOOL_edit_34	=	newPOOL_edit_34	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_22(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_34(string),1.0,5,5,1
"    function getTokens() payable canDistr onlyWhitelist public {
        if (value > totalRemaining) {
            value = totalRemaining;
        }
        
        require(value <= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        distr(investor, toGive);
        
        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        value = value.div(100000).mul(99999);
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
",0x8a88f04e0c905054d2f33b26bb3a46d7091a039a/IG.sol:IG:getTokens(),0x8a88f04e0c905054d2f33b26bb3a46d7091a039a/IG.sol:IG:withdrawForeignTokens(address),0.9523809523809524,5,5,1
"    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {
        require(self.mintable);
        require(msg.sender == self.minter || msg.sender == self.owner);
        if (lockAccount) {
            self.accountLocked[tokenOwner] = true;
        }
        self.balances[tokenOwner] = safeAdd(self.balances[tokenOwner], tokens);
        self.totalSupply = safeAdd(self.totalSupply, tokens);
        Mint(tokenOwner, tokens, lockAccount);
        Transfer(address(0), tokenOwner, tokens);
        return true;
    }
","    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:mint(BTTSLib:Data,address,uint256,bool)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:safeAdd(uint256,uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }
","0x1dC211ED642733Da8BADeEd7d529E9b67295593b/ergo.sol:ergo:transferFrom(address,address,uint256)",0x1dC211ED642733Da8BADeEd7d529E9b67295593b/ergo.sol:ergo:burnFrom(uint256),0.8723897911832946,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",1.0,5,5,1
"    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
","    function airdrop(address[] addresses) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(value <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:getTokenBalance(address,address)",0x6f5136e852ef12c275038561766d5e58495fb16f/Bitcash.sol:Bitcash:airdrop(address[]),0.3508771929824561,1,1,0
"  function removeToken(address _from, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _from);

    uint256 tokenIndex = ownedTokensIndex[_tokenId];
    uint256 lastTokenIndex = balanceOf(_from).sub(1);
    uint256 lastToken = ownedTokens[_from][lastTokenIndex];

    tokenOwner[_tokenId] = 0;
    ownedTokens[_from][tokenIndex] = lastToken;
    ownedTokens[_from][lastTokenIndex] = 0;
    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to
    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
    // the lastToken to the first position, and then dropping the element placed in the last position of the list

    ownedTokens[_from].length--;
    ownedTokensIndex[_tokenId] = 0;
    ownedTokensIndex[lastToken] = tokenIndex;
    totalTokens = totalTokens.sub(1);
  }
","  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {
    return approvedFor(_tokenId) == _owner;
  }
","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:removeToken(address,uint256)","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:isApprovedFor(address,uint256)",0.75,1,1,0
"    function getConfirmationCount(uint transactionId)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionId][owners[i]])
                count += 1;
    }
","    function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
",0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getConfirmationCount(uint256),0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:confirmTransaction(uint256),0.8,1,1,0
"  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x3dfaf3a340168a4552ab1937ea9527aae47c5ea1/StopIcoCoin.sol:Ownable:transferOwnership(address),0x3dfaf3a340168a4552ab1937ea9527aae47c5ea1/StopIcoCoin.sol:Ownable:onlyOwner(),0.8120481927710843,1,1,0
"   modifier isOpenToPublic()
    {
        require(openToPublic);
        _;
    }
","    modifier onlyRealPeople()
    {
          require (msg.sender == tx.origin);
        _;
    }
",0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:isOpenToPublic(),0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:onlyRealPeople(),1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply - balances[address(0)];
    }
","0x5ccc4ff4b286c1c1cce05f5194e8c8b01cb7c80d/ETUToken.sol:ETUToken:transferFrom(address,address,uint256)",0x5ccc4ff4b286c1c1cce05f5194e8c8b01cb7c80d/ETUToken.sol:ETUToken:totalSupply(),0.6521739130434783,1,1,0
"    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_setNetwork(uint8),0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_useCoupon(string),0.75,1,1,0
"    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);
    }
","    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string,string)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),0.8,1,1,0
"    function mint(address _a, uint _amount) onlyOwner mintingActive {
        balanceOf[_a] += _amount;
        totalSupply += _amount;
        LogMint(_a, _amount);
    }
","    function approve(address _owner, address _spender, uint _value)
    onlyController
    returns (bool success) {
        //require user to set to zero before resetting to nonzero
        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {
            return false;
        }

        allowance[_owner][_spender] = _value;
        return true;
    }
","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Ledger:mint(address,uint256)","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Ledger:approve(address,address,uint256)",1.0,5,5,1
"    function peek() public view
        returns (bytes32,bool)
    {
        return (bytes32(val), now < zzz);
    }
","    function void() public note auth
    {
        zzz = 0;
    }
",0x8a4774fe82c63484afef97ca8d89a6ea5e21f973/PriceFeed.sol:PriceFeed:peek(),0x8a4774fe82c63484afef97ca8d89a6ea5e21f973/PriceFeed.sol:PriceFeed:void(),1.0,5,5,1
"		function	retrait_1				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_1.transfer(User_1, Standard_1)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		modifier	onlyOwner	() {							
			require(msg.sender ==		owner	);					
			_;								
		}									
",0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:retrait_1(),0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:onlyOwner(),1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x05c3617cbf1304b9260aa61ec960f115d67becea/CBIX.sol:SafeMath:mul(uint256,uint256)","0x05c3617cbf1304b9260aa61ec960f115d67becea/CBIX.sol:SafeMath:add(uint256,uint256)",0.9272131147540984,5,5,1
"    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_getPrice(string),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",1.0,5,5,1
"    function addRecipient(address _from, uint256 _amount) external onlyOwner onlyPayloadSize(2 * 32) {
        require(_from != 0x0);
        require(totalAmount[_from] == 0);
        totalAmount[_from] = _amount;
        availableAmount[_from] = 0;
        withdrawedAmount[_from] = 0;
    }
","    function Basic(address _contractAddress) public onlyOwner {
        contractAddress = smartContract(_contractAddress);
    }
","0x0b3a0edd51ee5e7900666bbfdf139ea55ccf0ca0/Team.sol:Basic:addRecipient(address,uint256)",0x0b3a0edd51ee5e7900666bbfdf139ea55ccf0ca0/Team.sol:Basic:Basic(address),1.0,5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x02b8b5d2c2f05c074850c5bdffdb711edbcd8704/CodeMailStampSale.sol:StandardToken:decreaseApproval(address,uint256)","0x02b8b5d2c2f05c074850c5bdffdb711edbcd8704/CodeMailStampSale.sol:StandardToken:transferFrom(address,address,uint256)",0.7470308788598575,1,1,0
"	function balanceOf(address _owner) constant public returns (uint256 balance) {
	    return balances[_owner];
	}
","	function transfer(address _to, uint256 _value) public returns (bool success){
	    balances[msg.sender] = safeSub(balances[msg.sender], _value);
	    balances[_to] = safeAdd(balances[_to], _value);
	    Transfer(msg.sender, _to, _value);
	    return true;
	}
",0x7abf8a69cba9dbf808b5984624eb55a528ea44f2/Petro.sol:Petro:balanceOf(address),"0x7abf8a69cba9dbf808b5984624eb55a528ea44f2/Petro.sol:Petro:transfer(address,uint256)",0.02275025278058645,1,1,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","0x02fBb92f8d4E1cFdfb00bf0d07B3e554943d9DF6/MinesteriaCoin.sol:SafeMath:div(uint256,uint256)","0x02fBb92f8d4E1cFdfb00bf0d07B3e554943d9DF6/MinesteriaCoin.sol:SafeMath:add(uint256,uint256)",0.9945205479452056,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);return a - b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;return c;
  }
","0x2d2ac19de4a1105bfa284aab74aa1ab8f19e87ab/Studio.sol:SafeMath:sub(uint256,uint256)","0x2d2ac19de4a1105bfa284aab74aa1ab8f19e87ab/Studio.sol:SafeMath:div(uint256,uint256)",0.738933030646992,1,1,0
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x2f49030bfbe4819f4ab42c7829297dbdec01ad8c/SEK_Omnidollar.sol:SEK_Omnidollar:transferAnyERC20Token(address,uint256)","0x2f49030bfbe4819f4ab42c7829297dbdec01ad8c/SEK_Omnidollar.sol:SEK_Omnidollar:approve(address,uint256)",0.9356913183279744,5,5,1
"    function redeem(uint amount) public onlyOwner {
        require(_totalSupply >= amount);
        require(balances[owner] >= amount);

        _totalSupply -= amount;
        balances[owner] -= amount;
        Redeem(amount);
    }
","    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        if (deprecated) {
            return StandardToken(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    }
",0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Clost:redeem(uint256),"0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:Clost:allowance(address,address)",1.0,5,5,1
"    function transfer(address _to, uint _value) public only_when_unlocked returns (bool) {
        return super.transfer(_to, _value);
    }
","    function ManagedToken(string _name, string _symbol, uint8 _decimals, bool _locked) public 
        Token(_name, _symbol, _decimals) {
        locked = _locked;
    }
","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:transfer(address,uint256)","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:ManagedToken(string,string,uint8,bool)",0.25,1,1,0
"  function hasClosed() public view returns (bool) {
    return now > closingTime;
  }
","  function withdrawTokens() public onlyOwner {
    uint256 unsold = token.balanceOf(this);
    token.transfer(owner, unsold);
  }
",0x7f7f160b56291ec333734c9718af71f0af009f52/HODL_ICO.sol:HODL_ICO:hasClosed(),0x7f7f160b56291ec333734c9718af71f0af009f52/HODL_ICO.sol:HODL_ICO:withdrawTokens(),0.3076923076923077,1,1,0
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
",0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:onlyWhitelist(),0x0bc0a7b096504704e10bb19b0c6ce46232f22eda/DOGEToken.sol:DOGEToken:withdrawForeignTokens(address),0.8333333333333334,1,1,0
"     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
         return allowed[tokenOwner][spender];
     }
","     function approve(address spender, uint tokens) public returns (bool success) {
         allowed[msg.sender][spender] = tokens;
         Approval(msg.sender, spender, tokens);
         return true;
     }
","0x3f14d7da845a30bbd248c1da4966327ccb5c1600/FITToken.sol:FITToken:allowance(address,address)","0x3f14d7da845a30bbd248c1da4966327ccb5c1600/FITToken.sol:FITToken:approve(address,uint256)",0.9361702127659576,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:StandardToken:allowance(address,address)","0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:StandardToken:transfer(address,uint256)",0.241921768707483,1,1,0
"    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }
","    function getConfirmationCount(uint transactionId)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionId][owners[i]])
                count += 1;
    }
",0x4ef7dbc186f8abdd4c24257f2a9ff4fd0b31f843/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:addOwner(address),0x4ef7dbc186f8abdd4c24257f2a9ff4fd0b31f843/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getConfirmationCount(uint256),1.0,5,5,1
"    function keccak(slice self) internal returns (bytes32 ret) {
        assembly {
            ret := keccak256(mload(add(self, 32)), mload(self))
        }
    }
","    function find(slice self, slice needle) internal returns (slice) {
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);
        self._len -= ptr - self._ptr;
        self._ptr = ptr;
        return self;
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:keccak(strings:slice),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:find(strings:slice,strings:slice)",1.0,5,5,1
"	function totalSupply() public view returns (uint256 _totalSupply) {
		return totalSupply;
	}
","	function transfer(address _to, uint _value) public returns (bool success) {
		//standard function transfer similar to ERC20 transfer with no _data
		//added due to backwards compatibility reasons
		bytes memory empty;
		if(isContract(_to)) {
			return transferToContract(_to, _value, empty);
		}
		else {
			return transferToAddress(_to, _value, empty);
		}
	}
",0x2e208cf41b721c3cb4ac78cc05938619bdccc0d0/protoLEXToken.sol:protoLEXToken:totalSupply(),"0x2e208cf41b721c3cb4ac78cc05938619bdccc0d0/protoLEXToken.sol:protoLEXToken:transfer(address,uint256)",0.19101123595505612,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string,string,uint256)",1.0,5,5,1
"	function	getData_5	()	public	constant	returns	(	string	)	{
		return	inData_5	;						
	}									
","	function	getData_23	()	public	constant	returns	(	string	)	{
		return	inData_23	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_5(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_23(),0.5,1,1,0
"    modifier onlyAsset(bytes32 _name) {
        address AssetAddress = getApplicationAssetAddressByName(_name);
        require( msg.sender == AssetAddress);
        _;
    }
","    function ApplicationAsset() public {
        deployerAddress = msg.sender;
    }
",0x7d88463cc6d0ba403d302204236898414db3251a/NewsContract.sol:ApplicationAsset:onlyAsset(bytes32),0x7d88463cc6d0ba403d302204236898414db3251a/NewsContract.sol:ApplicationAsset:ApplicationAsset(),1.0,5,5,1
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }
","    function isContract(address _addr) internal view returns (bool) {
      uint256 size;
      assembly { size := extcodesize(_addr) }
      return size > codeSize ;
    }
",0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:MANJ:balanceOf(address),0x3d97211e1387ec7a3ce27bac8b5d414869d96ab9/MANJ.sol:MANJ:isContract(address),0.02325581395348837,1,1,0
"  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        revert();
    }
    _;
  }  
","  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
",0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:ReleasableToken:inReleaseState(bool),"0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:ReleasableToken:setTransferAgent(address,bool)",1.0,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc/PEPEso.sol:PEPEso:transfer(address,uint256)","0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc/PEPEso.sol:PEPEso:approveAndCall(address,uint256,bytes)",0.9802371541501976,5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x3afe47a46289b8ee2597ef8d8ce7bebf0f64172e/Swachhcoin.sol:StandardToken:decreaseApproval(address,uint256)","0x3afe47a46289b8ee2597ef8d8ce7bebf0f64172e/Swachhcoin.sol:StandardToken:allowance(address,address)",0.9466192170818504,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns
    (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x4f47702ce67bd0774327f3d5d82fe3113cb35625/WSXToken.sol:WSXToken:transferFrom(address,address,uint256)","0x4f47702ce67bd0774327f3d5d82fe3113cb35625/WSXToken.sol:WSXToken:allowance(address,address)",0.9242424242424242,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
","    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string,string)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1])",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x4c5e45cc4dd47c8e8c9ea4698025652b6728621e/EDMToken.sol:StandardToken:transferFrom(address,address,uint256)","0x4c5e45cc4dd47c8e8c9ea4698025652b6728621e/EDMToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8544474393530997,1,1,0
"  modifier onlyOwnerOf(uint256 _tokenId) {
    require(ownerOf(_tokenId) == msg.sender);
    _;
  }
","  function tokensOf(address _owner) public view returns (uint256[]) {
    return ownedTokens[_owner];
  }
",0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:onlyOwnerOf(uint256),0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:tokensOf(address),0.375,1,1,0
"    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[3],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])",1.0,5,5,1
"	function buyinReturn(address _who)
		constant
		public
		returns (uint)
	{
		// Chinese exchanges.
		if (
			_who == CHINESE_EXCHANGE_1 || _who == CHINESE_EXCHANGE_2 ||
			_who == CHINESE_EXCHANGE_3 || _who == CHINESE_EXCHANGE_4
		)
			return CHINESE_EXCHANGE_BUYIN;

		// BTCSuisse tier 1
		if (_who == BTC_SUISSE_TIER_1)
			return STANDARD_BUYIN;
		// BTCSuisse tier 2
		if (_who == BTC_SUISSE_TIER_2)
			return TIER_2_BUYIN;
		// BTCSuisse tier 3
		if (_who == BTC_SUISSE_TIER_3)
			return TIER_3_BUYIN;
		// BTCSuisse tier 4
		if (_who == BTC_SUISSE_TIER_4)
			return TIER_4_BUYIN;

		return 0;
	}
","	modifier when_allocatable_locked(uint amount) { require (lockedAllocatable >= amount); _; }
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:buyinReturn(address),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:when_allocatable_locked(uint256),1.0,5,5,1
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
","  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }
",0x7d172c6ab99be1cb8ccb135c95368799352a0e68/Cake.sol:Pausable:unpause(),0x7d172c6ab99be1cb8ccb135c95368799352a0e68/Cake.sol:Pausable:pause(),1.0,5,5,1
"    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x0c259e7c073c81188917c700a179818f18c5d6f8/OxBioToken.sol:SafeMath:mul(uint256,uint256)","0x0c259e7c073c81188917c700a179818f18c5d6f8/OxBioToken.sol:SafeMath:div(uint256,uint256)",0.7459584295612008,1,1,0
"    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
","    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);

        _postTransferHook(msg.sender, _to, _value);

        return true;
    }
",0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:BasicToken:totalSupply(),"0x6ecd58c1fb4af86d347f7bcf6ff713a0a8f99c4c/ETStarPresale.sol:BasicToken:transfer(address,uint256)",0.005847953216374269,1,1,0
"  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x4eefc1fc753fc09bf78dc19291372ab5efa23356/GEM.sol:SafeMath:sub(uint256,uint256)","0x4eefc1fc753fc09bf78dc19291372ab5efa23356/GEM.sol:SafeMath:div(uint256,uint256)",0.738933030646992,1,1,0
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    function _buy() internal returns (uint256 amount){
        require(buyOpen);
        require(buyPrice>0);
        require(msg.value>0);
        amount = msg.value / buyPrice;                    // calculates the amount
        _transfer(owner,msg.sender,amount);
        emit BuyToken(msg.sender,buyPrice,amount,msg.value);
        return amount;                                    // ends function and returns
    }
",0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:onlyOwner(),0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:_buy(),0.0004741583688952111,1,1,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","0x1ef588811e1c69c448ecc551912741fe7a0e90a7/BDAYSALE.sol:BDAYSALE:approve(address,uint256)",0x1ef588811e1c69c448ecc551912741fe7a0e90a7/BDAYSALE.sol:BDAYSALE:totalSupply(),0.8634920634920635,1,1,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x0efb788f740a3190f167dc152e3b7cbeccb973dd/HRY.sol:HRY:approveAndCall(address,uint256,bytes)","0x0efb788f740a3190f167dc152e3b7cbeccb973dd/HRY.sol:HRY:approve(address,uint256)",0.846307385229541,1,1,0
"    function strCompare(string _a, string _b) internal returns (int) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        uint minLength = a.length;
        if (b.length < minLength) minLength = b.length;
        for (uint i = 0; i < minLength; i ++)
            if (a[i] < b[i])
                return -1;
            else if (a[i] > b[i])
                return 1;
        if (a.length < b.length)
            return -1;
        else if (a.length > b.length)
            return 1;
        else
            return 0;
    }
","    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strCompare(string,string)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[5])",0.8,1,1,0
"		modifier	onlyOwner	() {							
			require(msg.sender ==		owner	);					
			_;								
		}									
","		function	LLV_v30_12		()	public	{				
			owner	= msg.sender;							
		}									
",0x0e1bebe6b75595d3c7fb99550757e310bc2edf2a/LLV_v30_12.sol:LLV_v30_12:onlyOwner(),0x0e1bebe6b75595d3c7fb99550757e310bc2edf2a/LLV_v30_12.sol:LLV_v30_12:LLV_v30_12(),0.10099573257467996,1,1,0
"    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function TokenDrop(address[] _addresses, uint256[] _values) payable returns(bool){
        for (uint i = 0; i < _addresses.length; i++) {
            transfer(_addresses[i], _values[i]);
        }
        return true;
    }
","0x4eecbf6534d10957e53f4bfe1ae10df2021c1684/IotaGoldToken.sol:IotaGoldToken:transfer(address,uint256)","0x4eecbf6534d10957e53f4bfe1ae10df2021c1684/IotaGoldToken.sol:IotaGoldToken:TokenDrop(address[],uint256[])",0.06896551724137931,1,1,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1e58ef20f3e2b429f029fbed2b106075d28c072e/Insureum.sol:StandardToken:approve(address,uint256)","0x1e58ef20f3e2b429f029fbed2b106075d28c072e/Insureum.sol:StandardToken:allowance(address,address)",0.907139023081052,1,1,0
"	function allowance(address _owner, address _spender)
		constant
		returns (uint256)
	{
		return accounts[_owner].allowanceOf[_spender];
	}
","	modifier when_has_allowance(address _owner, address _spender, uint _amount) {
		require (accounts[_owner].allowanceOf[_spender] >= _amount);
		_;
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:allowance(address,address)","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:when_has_allowance(address,address,uint256)",0.3333333333333333,1,1,0
"    function autoDistribute() payable public {
        require(distributeAmount > 0
                && balanceOf[activityFunds] >= distributeAmount
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
        if(msg.value > 0) activityFunds.transfer(msg.value);
        
        balanceOf[activityFunds] = balanceOf[activityFunds].sub(distributeAmount);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(distributeAmount);
        Transfer(activityFunds, msg.sender, distributeAmount);
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:autoDistribute(),"0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:approve(address,uint256)",1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x0ec6bbb00e3df05b1ef99dd87a4c14db9966fc7b/FansCoin.sol:FANSMaths:mul(uint256,uint256)","0x0ec6bbb00e3df05b1ef99dd87a4c14db9966fc7b/FansCoin.sol:FANSMaths:sub(uint256,uint256)",0.9068852459016392,5,5,1
"    function changeOwner(address _owner) onlyOwner public {
        candidate = _owner;
    }
","    function confirmOwner() public {
        require(candidate != address(0));
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }
",0x5a93e8d41cbd488d2a777bb1e7e455a755d85224/Webpuddg.sol:owned:changeOwner(address),0x5a93e8d41cbd488d2a777bb1e7e455a755d85224/Webpuddg.sol:owned:confirmOwner(),0.4545454545454545,1,1,0
"    function getContract(bytes32 _id) internal returns (address _addr) {
        _addr = FD_CI.getContract(_id);
    }
","    modifier onlyController() {
        require(msg.sender == controller);
        _;
    }
",0x2a37f3c4ce5ee6b1dbcdb593b21eee1c418ad403/FlightDelayLedger.sol:FlightDelayControlledContract:getContract(bytes32),0x2a37f3c4ce5ee6b1dbcdb593b21eee1c418ad403/FlightDelayLedger.sol:FlightDelayControlledContract:onlyController(),1.0,5,5,1
"  function buyTokens(address _beneficiary) public payable {
    require(_beneficiary != address(0));
  
    uint256 weiAmount = msg.value;
    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(rate);
    publicAllocationTokens=publicAllocationTokens.sub(tokens);
    // update state
    weiRaised = weiRaised.add(weiAmount);
    _processPurchase(_beneficiary, tokens);
    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
    _forwardFunds();
  }
","  function changeEndtime(uint256 _endTime) public onlyOwner {
    require(_endTime != 0); 
    closingTime = _endTime;
    }
",0x0fafe05e5a32ccbf7be5b9db8a4573e7bcf596df/BigLuvCrowdsale.sol:BigLuvCrowdsale:buyTokens(address),0x0fafe05e5a32ccbf7be5b9db8a4573e7bcf596df/BigLuvCrowdsale.sol:BigLuvCrowdsale:changeEndtime(uint256),0.0625,1,1,0
"  function ownerOf(uint256 _tokenId) public view returns (address) {
    address owner = tokenOwner[_tokenId];
    require(owner != address(0));
    return owner;
  }
","  function _burn(uint256 _tokenId) onlyOwnerOf(_tokenId) internal {
    if (approvedFor(_tokenId) != 0) {
      clearApproval(msg.sender, _tokenId);
    }
    removeToken(msg.sender, _tokenId);
    Transfer(msg.sender, 0x0, _tokenId);
  }
",0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:ownerOf(uint256),0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:_burn(uint256),0.3,1,1,0
"    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
        // We do our own memory management here. Solidity uses memory offset
        // 0x40 to store the current end of memory. We write past it (as
        // writes are memory extensions), but don't update the offset so
        // Solidity will reuse it. The memory used here is only needed for
        // this context.

        // FIXME: inline assembly can't access return values
        bool ret;
        address addr;

        assembly {
            let size := mload(0x40)
            mstore(size, hash)
            mstore(add(size, 32), v)
            mstore(add(size, 64), r)
            mstore(add(size, 96), s)

            // NOTE: we can reuse the request memory because we deal with
            //       the return code
            ret := call(3000, 1, 0, size, 128, size, 32)
            addr := mload(size)
        }

        return (ret, addr);
    }
","    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:safer_ecrecover(bytes32,uint8,bytes32,bytes32)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[])",1.0,5,5,1
"    function Bitwincoins(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x3f580f24a460f90484d1f80fb491b1a072033ec3/Bitwincoins.sol:Bitwincoins:Bitwincoins(uint256,string,string)","0x3f580f24a460f90484d1f80fb491b1a072033ec3/Bitwincoins.sol:Bitwincoins:_transfer(address,address,uint256)",0.8928571428571429,1,1,0
"    function getTokens() payable canDistr onlyWhitelist public {
        
        require(value <= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        if (msg.value < minReq){
            toGive = value.sub(value);
        }
        
        distr(investor, toGive);
        
        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function Noblebit (uint256 _value, uint256 _minReq) public {
        owner = msg.sender;
        value = _value;
        minReq = _minReq;
        balances[msg.sender] = totalDistributed;
    }
",0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:getTokens(),"0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:Noblebit(uint256,uint256)",0.8571428571428571,1,1,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(amount <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
",0x7bcbf788c3b5c86298198d2a974db70fa76a0eb2/XEN.sol:XEN:onlyOwner(),"0x7bcbf788c3b5c86298198d2a974db70fa76a0eb2/XEN.sol:XEN:distribution(address[],uint256)",0.009009009009009007,1,1,0
"    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(timestamp, datasource, arg);
    }
","    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strConcat(string,string,string,string,string)",0.8,1,1,0
"    function finishIssuance() public onlyOwner returns (bool) {
        issuanceFinished = true;
        IssuanceFinished();
        return true;
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {
        bool success = super.transfer(_to, _value);
        if(hasListener() && success) {
            eventListener.onTokenTransfer(msg.sender, _to, _value);
        }
        return success;
    }
",0x6a546617fd8c74555a2cb63b7b064331de82f68d/AbyssToken.sol:ManagedToken:finishIssuance(),"0x6a546617fd8c74555a2cb63b7b064331de82f68d/AbyssToken.sol:ManagedToken:transfer(address,uint256)",1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x2ea20ba1c704db0822b78e146cd7a5f3b0342fb1/ZJLTToken.sol:SafeMath:mul(uint256,uint256)","0x2ea20ba1c704db0822b78e146cd7a5f3b0342fb1/ZJLTToken.sol:SafeMath:div(uint256,uint256)",0.6934189406099518,1,1,0
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
",0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c/TrekChain.sol:TrekChain:onlyWhitelist(),"0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c/TrekChain.sol:TrekChain:getTokenBalance(address,address)",0.8333333333333334,1,1,0
"  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
","  function div(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
",0x1E5165777542368fa870baD4DeAd1fccBDc592aD/MyTestToken.sol:SafeMath:assert(bool),"0x1E5165777542368fa870baD4DeAd1fccBDc592aD/MyTestToken.sol:SafeMath:div(uint256,uint256)",0.19834710743801653,1,1,0
"    function query2_fnc(uint _timestamp, string _datasource, string _arg1, string _arg2, function() external _fnc, uint _gaslimit)
    costs(_datasource, _gaslimit)
    payable
    returns (bytes32 _id) {
        if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)||address(_fnc) != msg.sender) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        Log2_fnc(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _fnc,  _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
","    function getCodeSize(address _addr)
    private
    constant
    returns(uint _size) {
    assembly {
        _size := extcodesize(_addr)
        }
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query2_fnc(uint256,string,string,string,function(),uint256)",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:getCodeSize(address),0.5,1,1,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function parseAddr(string _a) internal pure returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseAddr(string),0.8,1,1,0
"  function set_traded_token_as_seeded() private {
    traded_token_is_seeded = true;
  }
","  function deposit_token(uint256 _amount) private { 
    transfer_tokens_through_proxy_to_contract(msg.sender, this, _amount);
  }  
",0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:set_traded_token_as_seeded(),0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:deposit_token(uint256),0.75,1,1,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
        require(targets.length > 0);

        for (uint j = 0; j < targets.length; j++) {
            require(targets[j] != 0x0);
            frozenAccount[targets[j]] = isFrozen;
            FrozenFunds(targets[j], isFrozen);
        }
    }
","0x5e99db60e4eaec5463aaa1ed4e28d634f256bf22/Arascacoin.sol:Arascacoin:approve(address,uint256)","0x5e99db60e4eaec5463aaa1ed4e28d634f256bf22/Arascacoin.sol:Arascacoin:freezeAccounts(address[],bool)",0.0064412238325281795,1,1,0
"    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[1])",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_setNetworkName(string),0.8,1,1,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
","0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:PausableToken:decreaseApproval(address,uint256)","0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:PausableToken:approve(address,uint256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
        if ((_nbytes == 0)||(_nbytes > 32)) throw;
	// Convert from seconds to ledger timer ticks
        _delay *= 10;
        bytes memory nbytes = new bytes(1);
        nbytes[0] = byte(_nbytes);
        bytes memory unonce = new bytes(32);
        bytes memory sessionKeyHash = new bytes(32);
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
        assembly {
            mstore(unonce, 0x20)
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
            mstore(sessionKeyHash, 0x20)
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
        }
        bytes memory delay = new bytes(32);
        assembly {
            mstore(add(delay, 0x20), _delay)
        }

        bytes memory delay_bytes8 = new bytes(8);
        copyBytes(delay, 24, 8, delay_bytes8, 0);

        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];
        bytes32 queryId = oraclize_query(""random"", args, _customGasLimit);

        bytes memory delay_bytes8_left = new bytes(8);

        assembly {
            let x := mload(add(delay_bytes8, 0x20))
            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))
            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))

        }

        oraclize_randomDS_setCommitment(queryId, sha3(delay_bytes8_left, args[1], sha256(args[0]), args[2]));
        return queryId;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[2])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_newRandomDSQuery(uint256,uint256,uint256)",0.2,1,1,0
"    function _isContract(address _user) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_user) }
        return size > 0;
    }
","    function Halo3DShrimpFarmer(address _baseContract)
      AcceptsHalo3D(_baseContract)
      public{
        ceoAddress=msg.sender;
    }
",0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:_isContract(address),0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:Halo3DShrimpFarmer(address),0.25,1,1,0
"    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:transferFrom(address,address,uint256)",0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:onlyOwner(),0.8,1,1,0
"	function	setData_4	(	string	newData_4	)	public	onlyOwner	{	
		inData_4	=	newData_4	;					
	}									
","	function	getData_33	()	public	constant	returns	(	string	)	{
		return	inData_33	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_4(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_33(),0.4,1,1,0
"  function unfreezeTransfers () {
    require (msg.sender == owner);

    if (frozen) {
      frozen = false;
      Unfreeze ();
    }
  }
","  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      Freeze ();
    }
  }
",0x5b2e4a700dfbc560061e957edec8f6eeeb74a320/INSToken.sol:INSToken:unfreezeTransfers(),0x5b2e4a700dfbc560061e957edec8f6eeeb74a320/INSToken.sol:INSToken:freezeTransfers(),1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c/BitSteveCoin.sol:BitSteveCoin:transferFrom(address,address,uint256)","0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c/BitSteveCoin.sol:BitSteveCoin:transfer(address,uint256)",0.9870689655172412,5,5,1
"    function safeDiv(uint a, uint b) internal returns (uint) {
      assert(b > 0);
      uint c = a / b;
      assert(a == b * c + a % b);
      return c;
    }
","    function max256(uint256 a, uint256 b) internal constant returns (uint256) {
      return a >= b ? a : b;
    }
","0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:safeDiv(uint256,uint256)","0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:max256(uint256,uint256)",0.5972222222222222,1,1,0
"    function RemoveModerator(address _oldModerator) onlyOwner public {
        if (moderators[_oldModerator] == true) {
            moderators[_oldModerator] = false;
            totalModerators -= 1;
        }
    }
","    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {
        isMaintaining = _isMaintaining;
    }
",0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:BasicAccessControl:RemoveModerator(address),0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:BasicAccessControl:UpdateMaintaining(bool),1.0,5,5,1
"    function transfer(address _from, address _to, uint _value)
    onlyToken
    returns (bool success) {
        return ledger.transfer(_from, _to, _value);
    }
","    function totalSupply() constant returns (uint) {
        return ledger.totalSupply();
    }
","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Controller:transfer(address,address,uint256)",0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Controller:totalSupply(),1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) {
        require(address(0) != to && tokens <= balances[msg.sender] && tokens <= allowed[from][msg.sender] && 0 <= tokens);
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }
","    function unpause() public onlyOwner whenPaused {
        paused = false;
        emit Unpause();
    }
","0x7d4d05abcadbdbf877c5cd5eb9dac6ddaa17ff89/BECCToken.sol:BECCToken:transferFrom(address,address,uint256)",0x7d4d05abcadbdbf877c5cd5eb9dac6ddaa17ff89/BECCToken.sol:BECCToken:unpause(),0.0,1,1,0
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x5ab08341acdb5d79b21b5d2fb021ac9545b705b4/SovToken.sol:BasicToken:balanceOf(address),0x5ab08341acdb5d79b21b5d2fb021ac9545b705b4/SovToken.sol:BasicToken:totalSupply(),0.12133468149646108,1,1,0
"    function hasPlayerWagered(address player)
    public 
    view 
    returns (bool)
    {
        if(wagers[player] > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
        
    }
","    constructor(address whaleAddress, uint256 wagerLimit) 
    onlyRealPeople()
    public 
    {
        openToPublic = false;
        owner = msg.sender;
        whale = whaleAddress;
        totalDonated = 0;
        betLimit = wagerLimit;
        
    }
",0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:hasPlayerWagered(address),"0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e/PoCGame.sol:PoCGame:constructor(address,uint256)",1.0,5,5,1
"    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
                
        uint256 totalAmount = 0;
        
        for(uint j = 0; j < addresses.length; j++){
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);
        
        for (j = 0; j < addresses.length; j++) {
            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);
            Transfer(msg.sender, addresses[j], amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","    function autoDistribute() payable public {
        require(distributeAmount > 0
                && balanceOf[activityFunds] >= distributeAmount
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
        if(msg.value > 0) activityFunds.transfer(msg.value);
        
        balanceOf[activityFunds] = balanceOf[activityFunds].sub(distributeAmount);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(distributeAmount);
        Transfer(activityFunds, msg.sender, distributeAmount);
    }
","0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:distributeAirdrop(address[],uint256[])",0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:autoDistribute(),0.9,1,1,0
"	function	setPI_edit_28	(	string	newPI_edit_28	)	public	onlyOwner	{	
		inPI_edit_28	=	newPI_edit_28	;					
	}									
","	function	getPI_edit_22	()	public	constant	returns	(	string	)	{
		return	inPI_edit_22	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_28(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_22(),1.0,5,5,1
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x4a7212e30878618a8c8d6f7fe8c7d14e6b059026/GDK.sol:Ownable:transferOwnership(address),0x4a7212e30878618a8c8d6f7fe8c7d14e6b059026/GDK.sol:Ownable:onlyOwner(),0.9899874843554444,5,5,1
"    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedApproveCheck(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);
    }
","    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedApproveCheck(address,address,uint256,uint256,uint256,bytes,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedApproveAndCallCheck(address,address,uint256,bytes,uint256,uint256,bytes,address)",1.0,5,5,1
"    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:parseAddr(string),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])",1.0,5,5,1
"	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}
","	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpDataStorage:setRegionNextImageId(uint256,uint256)",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpDataStorage:deleteRegionData(uint256),1.0,5,5,1
"    function refund() external {
        require(!isFinalized); // prevents refund if operational
        require(block.number > fundingEndBlock); // prevents refund until sale period is over
        require(totalSupply < tokenCreationMinMile1); // no refunds if we sold enough
        require(msg.sender != strFundDeposit); // Strim not entitled to a refund
        
        if (exchangeRate[msg.sender] > 0) {  //presale ether is non refundable as it will be used for marketing during the ICO period
		    uint256 strVal = balances[msg.sender];
            balances[msg.sender] = 0; //if refunded delete the users tokens
            totalSupply = totalSupply.sub(strVal); // extra safe
       	    uint256 ethVal = strVal / exchangeRate[msg.sender]; // should be safe; considering it never reached the first milestone;
            LogRefund(msg.sender, ethVal); // log it 
            if (!msg.sender.send(ethVal)) revert(); // if you're using a contract; make sure it works with .send gas limits
		}
    }
","    function transfer(address _to, uint256 _value, bytes _data) public crowdsaleTransferLock returns(bool success) {
        return super.transfer(_to, _value, _data);
    }
",0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:refund(),"0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:transfer(address,uint256,bytes)",1.0,5,5,1
"  function setAdmin(address _admin) public onlyOwner {
    admin = _admin;
  }
","  function buyTokens() public payable {
    require(now < endDate);
    require(now >= startDate);
    require(msg.value > 0);

    uint256 amount = msg.value * UNIT / tokenPrice;
    uint256 bonus = calcBonus(msg.value) * UNIT / tokenPrice;
    
    totalSupply = totalSupply.add(amount);
    
    require(totalSupply <= maxSupply);

    totalWeiReceived = totalWeiReceived.add(msg.value);

    balances[msg.sender] = balances[msg.sender].add(amount);
    
    TokenPurchase(msg.sender, msg.sender, msg.value, amount);
    
    Transfer(address(0x0), msg.sender, amount);

    if (bonus > 0) {
      Transfer(companyWallet, msg.sender, bonus);
      balances[companyWallet] -= bonus;
      balances[msg.sender] = balances[msg.sender].add(bonus);
    }

    companyWallet.transfer(msg.value);
  }
",0x2a44e16ba435f53666f8a39fa08ffd01c9f2ab2f/WHSCoin.sol:WHSCoin:setAdmin(address),0x2a44e16ba435f53666f8a39fa08ffd01c9f2ab2f/WHSCoin.sol:WHSCoin:buyTokens(),0.75,1,1,0
"    function msc() public {


        balances[msg.sender] = totalSupply;             

        ethFundDeposit = msg.sender;                      
        allowTransfers = false;
    }
","    function transferFromAdmin(address _from, address _to, uint256 _value) onlyOwner public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        return true;
    }
",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:msc(),"0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:transferFromAdmin(address,address,uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        _transfer(_from, _to, _value);
        return true;
    }
","0x6dcfac01b1fb424c76459d96eaa0e0e51be9d3ba/Blockcash.sol:ERC20Token:approve(address,uint256)","0x6dcfac01b1fb424c76459d96eaa0e0e51be9d3ba/Blockcash.sol:ERC20Token:transferFrom(address,address,uint256)",0.0032206119162640893,1,1,0
"    function length(uintSet storage self) returns (uint256) {
        return self.members.length;
    }
","    function remove(addressSet storage self, address other) {
        if (self.memberExists[other])  {
            self.memberExists[other] = false;
            uint index = self.memberIndex[other];
            // change index of last value to index of other 
            self.memberIndex[self.members[self.members.length - 1]] = index;
            // copy last value over other and decrement length
            self.members[index] = self.members[self.members.length - 1];
            self.members.length--;
        }
    }
",0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:length(Sets:uintSet),"0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:remove(Sets:addressSet,address)",0.0,1,1,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x6eed4a400ce1e79f41bdf755ea2fac4d4c29d9c6/HawkTokenCrowdsale.sol:SafeMath:div(uint256,uint256)","0x6eed4a400ce1e79f41bdf755ea2fac4d4c29d9c6/HawkTokenCrowdsale.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,5,5,1
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
",0x7b55e5a0aec97c7fa3594393c3471c79a1204890/FinalToken.sol:Ownable:onlyOwner(),0x7b55e5a0aec97c7fa3594393c3471c79a1204890/FinalToken.sol:Ownable:transferOwnership(address),0.15979137031768612,1,1,0
"    modifier onlyWhenTransferEnabled() {
        if( now <= saleEndTime && now >= saleStartTime ) {
            require( msg.sender == tokenSaleContract );
        }
        _;
    }
","    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
        token.transfer( owner, amount );
    }
",0x3be856c94c7a1ff4f433ae95a48544b1a62ce385/KyberNetworkCrystal.sol:KyberNetworkCrystal:onlyWhenTransferEnabled(),"0x3be856c94c7a1ff4f433ae95a48544b1a62ce385/KyberNetworkCrystal.sol:KyberNetworkCrystal:emergencyERC20Drain(ERC20,uint256)",1.0,5,5,1
"	function refund_my_ether() {
		refund(msg.sender);
	}
","	function set_whitelist_enabled(bool _boolean) onlyOwner {
		whitelist_enabled = _boolean;
	}
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:refund_my_ether(),0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:set_whitelist_enabled(bool),0.5,1,1,0
"	function	setData_10	(	string	newData_10	)	public	onlyOwner	{		
		inData_10	=	newData_10	;						
	}										
","		function	LLV_v31_5		()	public	{				
			owner	= msg.sender;							
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setData_10(string),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:LLV_v31_5(),0.0,1,1,0
"  function priceOf (uint256 _scamId) public view returns (uint256 _price) {
    return priceOfScam[_scamId];
  }
","  function withdraw () onlyOwner() public {
    owner.transfer(this.balance);
  }
",0x3C34071180ceb4213DA92D065f87aDcB835028c4/CryptoScams.sol:CryptoScams:priceOf(uint256),0x3C34071180ceb4213DA92D065f87aDcB835028c4/CryptoScams.sol:CryptoScams:withdraw(),0.0,1,1,0
"    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[5],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",1.0,5,5,1
"  function closeMint(TokenStorage storage self) returns (bool) {
    require(self.owner == msg.sender);

    self.stillMinting = false;
    MintingClosed(true);
    return true;
  }
","  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
                          returns (bool)
  {
    uint256 _newAllowed;
    bool err;

    if(_increase) {
      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);
      require(!err);

      self.allowed[msg.sender][_spender] = _newAllowed;
    } else {
      if (_valueChange > self.allowed[msg.sender][_spender]) {
        self.allowed[msg.sender][_spender] = 0;
      } else {
        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;
        self.allowed[msg.sender][_spender] = _newAllowed;
      }
    }

    Approval(msg.sender, _spender, _newAllowed);
    return true;
  }
",0x6e5d3e9ce88a0fba4e096e2eb8d2b3dc54685dd2/RBITToken.sol:TokenLib:closeMint(TokenLib:TokenStorage),"0x6e5d3e9ce88a0fba4e096e2eb8d2b3dc54685dd2/RBITToken.sol:TokenLib:approveChange(TokenLib:TokenStorage,address,uint256,bool)",1.0,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x4db172a4eb773b134c0c539ef18bb8e340898d3d/MulaCoin.sol:MulaCoin:transferAnyERC20Token(address,uint256)","0x4db172a4eb773b134c0c539ef18bb8e340898d3d/MulaCoin.sol:MulaCoin:allowance(address,address)",0.9581993569131833,5,5,1
"    function keccak(slice self) internal returns (bytes32 ret) {
        assembly {
            ret := keccak256(mload(add(self, 32)), mload(self))
        }
    }
","    function until(slice self, slice needle) internal returns (slice) {
        if (self._len < needle._len) {
            return self;
        }

        var selfptr = self._ptr + self._len - needle._len;
        bool equal = true;
        if (selfptr != needle._ptr) {
            assembly {
                let length := mload(needle)
                let needleptr := mload(add(needle, 0x20))
                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))
            }
        }

        if (equal) {
            self._len -= needle._len;
        }

        return self;
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:keccak(strings:slice),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:until(strings:slice,strings:slice)",0.5,1,1,0
"	function	setPOOL_edit_10	(	string	newPOOL_edit_10	)	public	onlyOwner	{	
		inPOOL_edit_10	=	newPOOL_edit_10	;					
	}									
","	function	setPOOL_edit_29	(	string	newPOOL_edit_29	)	public	onlyOwner	{	
		inPOOL_edit_29	=	newPOOL_edit_29	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_10(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_29(string),1.0,5,5,1
"    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string,string,uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[5])",1.0,5,5,1
"    function disableMinting() public {
        data.disableMinting();
    }
","    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:disableMinting(),"0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:signedTransferFromCheck(address,address,address,uint256,uint256,uint256,bytes,address)",1.0,5,5,1
"  function changeFeeAccount(address feeAccount_) onlyAdmin {
    feeAccount = feeAccount_;
  }
","  function tokenFallback(address _from, uint _value, bytes _data) { // Deposit ERC223 tokens
    if (_value==0) revert();
    if (blackERC223[msg.sender]) revert();
    tokens[msg.sender][_from] = safeAdd(tokens[msg.sender][_from], _value);
    emit Deposit(msg.sender, _from, _value, tokens[msg.sender][_from]);
   }
",0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:changeFeeAccount(address),"0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:tokenFallback(address,uint256,bytes)",1.0,5,5,1
"    function totalSupply() constant returns (uint256 supply) {
        return _totalSupply;
    }
","    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
",0x2edd21212d0adba1f7511e57c07435ad946da796/TokenFactoryAirdropCoin.sol:TokenFactoryAirdropCoin:totalSupply(),"0x2edd21212d0adba1f7511e57c07435ad946da796/TokenFactoryAirdropCoin.sol:TokenFactoryAirdropCoin:approve(address,uint256)",0.25,1,1,0
"    function mintAllBonuses() external
    inState(State.BONUS_MINTING)
    noAnyReentrancy
    {
        assert(!allBonusesAreMinted);
        allBonusesAreMinted = true;

        uint TEAM_AND_PARTNERS_PER_CENT = TEAM_BONUS_PER_CENT + ADVISORS_AND_PARTNERS_PER_CENT;

        uint total_presale_amount_with_bonus = mintPresaleBonuses();
        uint total_collected_amount = total_received_amount + total_presale_amount_with_bonus;
        uint extra_amount = total_collected_amount * TEAM_AND_PARTNERS_PER_CENT / (100 - TEAM_AND_PARTNERS_PER_CENT);
        uint extra_team_amount = extra_amount * TEAM_BONUS_PER_CENT / TEAM_AND_PARTNERS_PER_CENT;
        uint extra_partners_amount = extra_amount * ADVISORS_AND_PARTNERS_PER_CENT / TEAM_AND_PARTNERS_PER_CENT;
/* 
        //beautify total supply: round down to full eth.
        uint total_to_mint = total_collected_amount + extra_amount;
        uint round_remainder = total_to_mint - (total_to_mint / 1 ether * 1 ether);
        extra_team_amount -= round_remainder; //this will reduce total_supply to rounded value
*/
        //mint group bonuses
        _mint(extra_team_amount , TEAM_GROUP_WALLET);
        _mint(extra_partners_amount, ADVISERS_AND_FRIENDS_WALLET);

    }
","    function currentState() private constant
    returns (State)
    {
        if (isAborted) {
            return this.balance > 0
                   ? State.REFUND_RUNNING
                   : State.CLOSED;
        } else if (block.number < COMMUNITY_SALE_START || address(TOKEN) == 0x0) {
             return State.BEFORE_START;
        } else if (block.number < PRIORITY_SALE_START) {
            return State.COMMUNITY_SALE;
        } else if (block.number < PUBLIC_SALE_START) {
            return total_received_amount < COMMUNITY_PLUS_PRIORITY_SALE_CAP
                ? State.PRIORITY_SALE
                : State.PRIORITY_SALE_FINISHED;
        } else if (block.number <= PUBLIC_SALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PUBLIC_SALE;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return allBonusesAreMinted
                ? State.WITHDRAWAL_RUNNING
                : State.BONUS_MINTING;
        } else {
            return State.REFUND_RUNNING;
        }
    }
",0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:mintAllBonuses(),0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:currentState(),1.0,5,5,1
"  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }
","  function setDistributeAmount(uint256 _unitAmount) onlyOwner public {
    distributeAmount = _unitAmount;
  }
",0x7f32d1959b5361e884df8c9d017a03f4ce29c8b2/Kemonocoin.sol:Kemonocoin:balanceOf(address),0x7f32d1959b5361e884df8c9d017a03f4ce29c8b2/Kemonocoin.sol:Kemonocoin:setDistributeAmount(uint256),0.0020242914979757085,1,1,0
"		function	getData_24	()	public	constant	returns	(	string	)	{
			return	inData_24	;						
		}									
","		function	getData_3	()	public	constant	returns	(	string	)	{
			return	inData_3	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_24(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_3(),1.0,5,5,1
"    function disableTransfers(bool _disable) public ownerOnly {
        transfersEnabled = !_disable;
    }
","    function destroy(address _from, uint256 _amount)
        public
        ownerOnly
    {
        balanceOf[_from] = safeSub(balanceOf[_from], _amount);
        totalSupply = safeSub(totalSupply, _amount);

        Transfer(_from, this, _amount);
        Destruction(_amount);
    }
",0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:disableTransfers(bool),"0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:destroy(address,uint256)",0.2857142857142857,1,1,0
"    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){
        bool checkok;
        
        
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;
        bytes memory keyhash = new bytes(32);
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);
        checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));
        if (checkok == false) return false;
        
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);
        
        
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)
        checkok = matchBytes32Prefix(sha256(sig1), result);
        if (checkok == false) return false;
        
        
        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.
        // This is to verify that the computed args match with the ones specified in the query.
        bytes memory commitmentSlice1 = new bytes(8+1+32);
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);
        
        bytes memory sessionPubkey = new bytes(64);
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);
        
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);
        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match
            delete oraclize_randomDS_args[queryId];
        } else return false;
        
        
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)
        bytes memory tosign1 = new bytes(32+8+1+32);
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);
        checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);
        if (checkok == false) return false;
        
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);
        }
        
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];
    }
","    function parseInt(string _a, uint _b) internal returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:parseInt(string,uint256)",1.0,5,5,1
"    function sub(uint256 a, uint256 b) pure internal returns (uint256) {
        assert(a >= b);
        return a - b;
    }
","    function add(uint256 a, uint256 b) pure internal returns (uint256) {
        uint256 c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
","0x008a8d41c2cb3054504a61e1d54a06fd83560254/Lion.sol:SafeMath:sub(uint256,uint256)","0x008a8d41c2cb3054504a61e1d54a06fd83560254/Lion.sol:SafeMath:add(uint256,uint256)",0.005681818181818182,1,1,0
"    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);
        require(balanceOf[msg.sender] >= _value);
        
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
","    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && now > unlockUnixTime[msg.sender]);

        uint256 totalAmount = 0;

        for(uint j = 0; j < addresses.length; j++){
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);

        for (j = 0; j < addresses.length; j++) {
            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);
            emit Transfer(msg.sender, addresses[j], amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:transfer(address,uint256)","0x5ed817b8d8beecaff347d9626714f4aa67524bf0/WiredToken.sol:WiredToken:distributeAirdrop(address[],uint256[])",1.0,5,5,1
"    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","0x6d1c9c50de5c8b64b15a027e89ae6ba68987c30a/Greenworld_Farm_Token.sol:SafeMath:safeSub(uint256,uint256)","0x6d1c9c50de5c8b64b15a027e89ae6ba68987c30a/Greenworld_Farm_Token.sol:SafeMath:safeAdd(uint256,uint256)",0.983402489626556,5,5,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x6a3777eb316ed485dd399628e8c0711eb8f5b0db/M2B.sol:StandardToken:increaseApproval(address,uint256)","0x6a3777eb316ed485dd399628e8c0711eb8f5b0db/M2B.sol:StandardToken:allowance(address,address)",0.9668304668304668,5,5,1
"  function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {
    uint256 z = x - y;
    assert(z <= x);
	  return z;
  }
","  function max(uint256 x, uint256 y) internal pure returns (uint256) {
    uint256 z = x >= y ? x : y;
    return z;
  }
","0x02E24Acc7098E7BedF6e1D863D8034F692ad2E22/OilToken.sol:SafeMath:safeSub(uint256,uint256)","0x02E24Acc7098E7BedF6e1D863D8034F692ad2E22/OilToken.sol:SafeMath:max(uint256,uint256)",0.009259259259259259,1,1,0
"    modifier transfersAllowed {
        assert(transfersEnabled);
        _;
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {
        assert(super.transfer(_to, _value));

        // transferring to the contract address destroys tokens
        if (_to == address(this)) {
            balanceOf[_to] -= _value;
            totalSupply -= _value;
            Destruction(_value);
        }

        return true;
    }
",0x3FD8d623695b3aDEdc1Fa57a84F93fD78326BA27/SmartToken.sol:SmartToken:transfersAllowed(),"0x3FD8d623695b3aDEdc1Fa57a84F93fD78326BA27/SmartToken.sol:SmartToken:transfer(address,uint256)",0.25,1,1,0
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
","  modifier whenPaused() {
    require(paused);
    _;
  }
",0x5fd898ee851cd3be05cc5287041279b65212579d/ElementToken.sol:Pausable:unpause(),0x5fd898ee851cd3be05cc5287041279b65212579d/ElementToken.sol:Pausable:whenPaused(),1.0,5,5,1
"    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {
        require(_x >= _y);
        return _x - _y;
    }
","    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x + _y;
        assert(z >= _x);
        return z;
    }
","0x2df514a060bbd105ea428182e8b140454f426d15/SmartWallet.sol:Utils:safeSub(uint256,uint256)","0x2df514a060bbd105ea428182e8b140454f426d15/SmartWallet.sol:Utils:safeAdd(uint256,uint256)",0.84375,1,1,0
"	function	setData_16	(	string	newData_16	)	public	onlyOwner	{	
		inData_16	=	newData_16	;					
	}									
","	function	setData_3	(	string	newData_3	)	public	onlyOwner	{	
		inData_3	=	newData_3	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_16(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_3(string),1.0,5,5,1
"    function startsWith(slice self, slice needle) internal returns (bool) {
        if (self._len < needle._len) {
            return false;
        }

        if (self._ptr == needle._ptr) {
            return true;
        }

        bool equal;
        assembly {
            let length := mload(needle)
            let selfptr := mload(add(self, 0x20))
            let needleptr := mload(add(needle, 0x20))
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))
        }
        return equal;
    }
","    function rsplit(slice self, slice needle) internal returns (slice token) {
        rsplit(self, needle, token);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:startsWith(strings:slice,strings:slice)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:rsplit(strings:slice,strings:slice)",1.0,5,5,1
"    function seEnableTransfer( bool _transfer ) {
        require( msg.sender == admin );
        enableTransfer = _transfer; 
    }    
","    function seIcoAddress( address _wallet) {
        require( msg.sender == admin );
        wallet = _wallet ;
    }    
",0x0e622f6a94258697ef6927cc6b3dddc0d16fc263/REDISale.sol:REDISale:seEnableTransfer(bool),0x0e622f6a94258697ef6927cc6b3dddc0d16fc263/REDISale.sol:REDISale:seIcoAddress(address),1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function GILToken() public {
        symbol = ""GIL"";
        name = ""Gilgamesh Token"";
        decimals = 0;
        _totalSupply = 1000000;
        balances[0xdd16c70aD270633edF69174b4269914De9434bf8] = _totalSupply;
        Transfer(address(0), 0xdd16c70aD270633edF69174b4269914De9434bf8, _totalSupply);
    }
","0x6f3f21e65e618592f95d5f3a2e7e1b1425309ff2/GILToken.sol:GILToken:transferFrom(address,address,uint256)",0x6f3f21e65e618592f95d5f3a2e7e1b1425309ff2/GILToken.sol:GILToken:GILToken(),0.1853448275862069,1,2,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","  function weiToTokens(uint256 _weiAmount) public view returns (uint256, uint256) {
    require(tokenNAVMicroUSD != uint256(0));
    require(weiPerUSD != uint256(0));
    uint256 tokens = _weiAmount.mul(million).div(weiPerUSD).div(tokenNAVMicroUSD);
    uint256 changeWei = _weiAmount.sub(tokensToWei(tokens));
    return (tokens, changeWei);
  }
","0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:decreaseApproval(address,uint256)",0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:weiToTokens(uint256),0.2,2,2,0
"    function lockInternalAccount(address _target, bool _lock, uint256 _releaseTime) onlyOwner public {
        require(_target != address(0));

        internalLockAccount[_target] = _lock;
        releaseLockAccount[_target] = _releaseTime;

    }
","    function setCrowdsaleStartTime(uint256 _crowdsaleStartTime) onlyOwner public {
        crowdsaleStartTime = _crowdsaleStartTime;
    }
","0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:lockInternalAccount(address,bool,uint256)",0x2efb0309f41648a9faa935e189e2c8ff763bce75/MSCE.sol:MSCE:setCrowdsaleStartTime(uint256),1.0,5,5,1
"  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x5e0c6a4168be7d01798cc36aee371aeb0e4f9a13/SuperBowlCoin.sol:BasicToken:balanceOf(address),"0x5e0c6a4168be7d01798cc36aee371aeb0e4f9a13/SuperBowlCoin.sol:BasicToken:transfer(address,uint256)",0.2269969666329626,2,2,0
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x8a1ce73cef5b49a250c58ccf9a145d87925ea438/Ssnc.sol:StandardToken:increaseApproval(address,uint256)","0x8a1ce73cef5b49a250c58ccf9a145d87925ea438/Ssnc.sol:StandardToken:transferFrom(address,address,uint256)",0.7617283950617284,4,4,0
"    function Owned() public {
        owner = msg.sender;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x2a57dab627c3a1bc0b96ec2eeb92300db427e126/testTokan3.sol:Owned:Owned(),0x2a57dab627c3a1bc0b96ec2eeb92300db427e126/testTokan3.sol:Owned:onlyOwner(),0.8075117370892019,4,4,0
"    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
","0x4a6355327b87527664a5cee0a61bdb568585cdd5/UPEXCoin.sol:UPEXCoin:allowance(address,address)",0x4a6355327b87527664a5cee0a61bdb568585cdd5/UPEXCoin.sol:UPEXCoin:totalSupply(),0.034389140271493215,4,4,0
"    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a < b ? a : b;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x2c676953448add0d450ae0dc4e9afbc228dba62c/FooozCrowdsale.sol:SafeMath:min64(uint64,uint64)","0x2c676953448add0d450ae0dc4e9afbc228dba62c/FooozCrowdsale.sol:SafeMath:sub(uint256,uint256)",0.2297297297297297,4,4,0
"	function	setPI_edit_14	(	string	newPI_edit_14	)	public	onlyOwner	{	
		inPI_edit_14	=	newPI_edit_14	;					
	}									
","	function	getPI_edit_12	()	public	constant	returns	(	string	)	{
		return	inPI_edit_12	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_14(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_12(),1.0,5,5,1
"    function CryptoIgniterToken() public {
        totalSupply = 8000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;            
        name = 'CryptoIgniter Token';                       // The name for display purposes
        symbol = 'CIT';                               // The symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x1c2699cbb862c6bfccd9ff8c80734263cd486578/CryptoIgniterToken.sol:CryptoIgniterToken:CryptoIgniterToken(),"0x1c2699cbb862c6bfccd9ff8c80734263cd486578/CryptoIgniterToken.sol:CryptoIgniterToken:approveAndCall(address,uint256,bytes)",0.3333333333333333,4,4,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x4f203c744e345344bbd70711d289ecb22fe29ab7/SocialChain.sol:SocialChain:transfer(address,uint256)","0x4f203c744e345344bbd70711d289ecb22fe29ab7/SocialChain.sol:SocialChain:approve(address,uint256)",0.8729792147806005,4,4,0
"	function	getPOOL_edit_28	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_28	;						
	}									
","	modifier	onlyOwner	() {							
		require(msg.sender ==		owner	);					
		_;								
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_28(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:onlyOwner(),0.6666666666666666,4,4,0
"  function hasRole(address addr, string roleName)
    view
    public
    returns (bool)
  {
    return roles[roleName].has(addr);
  }
","  modifier onlyRole(string roleName)
  {
    checkRole(msg.sender, roleName);
    _;
  }
","0x6a3439b7f69310d9b7dc568a5ba51edf81e5113b/Whitelist.sol:RBAC:hasRole(address,string)",0x6a3439b7f69310d9b7dc568a5ba51edf81e5113b/Whitelist.sol:RBAC:onlyRole(string),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[2])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[1])",1.0,5,5,1
"		function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
			//same as above. Replace this line with the following if you want to protect against wrapping uints.
			//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
			if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
				balances[_to] += _value;
				balances[_from] -= _value;
				allowed[_from][msg.sender] -= _value;
				Transfer(_from, _to, _value);
				return true;
			} else { return false; }
		}
","		function transfer(address _to, uint256 _value) returns (bool success) {
			//Default assumes totalSupply can't be over max (2^256 - 1).
			//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
			//Replace the if with this one instead.
			//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
			if (balances[msg.sender] >= _value && _value > 0) {
				balances[msg.sender] -= _value;
				balances[_to] += _value;
				Transfer(msg.sender, _to, _value);
				return true;
			} else { return false; }
		}
","0x5b4bc61c5231312a7bc380eb2dd6c67e03c98b39/BTCP.sol:StandardToken:transferFrom(address,address,uint256)","0x5b4bc61c5231312a7bc380eb2dd6c67e03c98b39/BTCP.sol:StandardToken:transfer(address,uint256)",0.8165007112375533,4,4,0
"    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {            
        tokenRecipient spender = tokenRecipient(_spender);              // Cast spender to tokenRecipient contract         
        approve(_spender, _value);                                      // Set approval to contract for _value         
        spender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract         
        return true;     
    }     
",0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:balanceOf(address),"0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:approveAndCall(address,uint256,bytes)",0.00455005055611729,4,4,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x1bc7c1de0ac6ef4fdec35c053030d90cf54c7e9a/YANG.sol:YANG:approve(address,uint256)",0x1bc7c1de0ac6ef4fdec35c053030d90cf54c7e9a/YANG.sol:YANG:balanceOf(address),0.9682539682539684,5,5,1
"  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function max64(uint64 a, uint64 b) internal pure returns (uint64) {
    return a >= b ? a : b;
  }
","0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:SafeMath:safeMul(uint256,uint256)","0x5d9c4532ca1f598f42fb4d2cf7cf26a1d54f1dc6/QuantumToken.sol:SafeMath:max64(uint64,uint64)",0.22673031026252985,4,4,0
"    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                // Check if the sender has enough
        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        totalSupply -= _value;                               // Updates totalSupply
        Burn(_from, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] -= _value;                           // Subtract from the sender
        balanceOf[_to] += _value;                             // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","0x5b18bf749d3015640d0301325415c8f95ea087ac/AdvancedArtificialIntelligenceSafetyDefense.sol:AdvancedArtificialIntelligenceSafetyDefense:burnFrom(address,uint256)","0x5b18bf749d3015640d0301325415c8f95ea087ac/AdvancedArtificialIntelligenceSafetyDefense.sol:AdvancedArtificialIntelligenceSafetyDefense:transferFrom(address,address,uint256)",0.9629629629629628,5,5,1
"	function	setData_5	(	string	newData_5	)	public	onlyOwner	{	
		inData_5	=	newData_5	;					
	}									
","	function	setData_6	(	string	newData_6	)	public	onlyOwner	{	
		inData_6	=	newData_6	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_5(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_6(string),0.5,4,4,0
"    function burn(address _from, uint _value) public only_owner safe_arguments(2) returns (bool) {

        // Check if the token owner has enough tokens
        require(balances[_from] >= _value);

        // Check for overflows
        require(balances[_from] - _value <= balances[_from]);

        // Burn tokens
        balances[_from] -= _value;
        totalTokenSupply -= _value;

        // Notify listeners 
        Transfer(_from, 0, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint _value) public only_when_unlocked returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:burn(address,uint256)","0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:transferFrom(address,address,uint256)",1.0,5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x0de1beed64aa3ca5f563a1ba585861748c352231/BioCoin.sol:BioCoin:transferFrom(address,address,uint256)","0x0de1beed64aa3ca5f563a1ba585861748c352231/BioCoin.sol:BioCoin:transferAnyERC20Token(address,uint256)",0.9784482758620692,5,5,1
"    function WFC(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
    }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }
","0x0c7992d46f6b01e6cfcd26e7e2c45157d250ba48/WFC.sol:WFC:WFC(string,string,uint8,uint256)","0x0c7992d46f6b01e6cfcd26e7e2c45157d250ba48/WFC.sol:WFC:decreaseApproval(address,uint256)",0.6428571428571429,4,4,0
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","0x3dffbf763624a5cffa53265d5005a297261d1e8d/ETHT.sol:ETHTBasic:transfer(address,uint256)",0x3dffbf763624a5cffa53265d5005a297261d1e8d/ETHT.sol:ETHTBasic:balanceOf(address),0.6386913229018493,4,4,0
"    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }
","    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
",0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:enableWhitelist(address[]),0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:withdraw(),0.8695652173913043,4,4,0
"	function	getPOOL_edit_6	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_6	;						
	}									
","	function	setPOOL_edit_32	(	string	newPOOL_edit_32	)	public	onlyOwner	{	
		inPOOL_edit_32	=	newPOOL_edit_32	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_6(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_32(string),0.6666666666666666,4,4,0
"    function Owned() {
        owner = msg.sender;
    }
","    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
",0x1bce0e684a1607fd86407909073eea2336042bf7/SmartToken.sol:Owned:Owned(),0x1bce0e684a1607fd86407909073eea2336042bf7/SmartToken.sol:Owned:acceptOwnership(),0.0485133020344288,4,4,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
","    function QRTok () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }
","0x0aa68c174bbc60b9b66beba56db92a74b719644b/QRTok.sol:QRTok:approve(address,uint256)",0x0aa68c174bbc60b9b66beba56db92a74b719644b/QRTok.sol:QRTok:QRTok(),0.03571428571428571,4,4,0
"    function totalSupply() public view returns (uint) {

        return _totalSupply.sub(balances[address(0)]);

    }
","    constructor() public {

        symbol = ""GEON""; 

        name = ""GEON"";

        decimals = 18;
  
        _totalSupply = 850000000 * 10**uint(decimals);

        balances[owner] = _totalSupply;

        emit Transfer(address(0), owner, _totalSupply);

    }
",0x1e378cdf48cd6faa3fc8e0bc0dbe02446969e46d/GEONToken.sol:GEONToken:totalSupply(),0x1e378cdf48cd6faa3fc8e0bc0dbe02446969e46d/GEONToken.sol:GEONToken:constructor(),0.42857142857142855,4,4,0
"    function burn(uint256 _value) returns (bool) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] = safeSub(balances[msg.sender], _value) ;
            totalSupply = safeSub(totalSupply, _value);
            Transfer(msg.sender, 0x0, _value);
            return true;
        } else return false;
    }
","    function CommonBsToken(string _name, string _symbol, uint256 _totalSupplyNoDecimals, address _seller) MultiOwnable() {

        // Lock the transfer function during the presale/crowdsale to prevent speculations.
        locked = true;

        creator = msg.sender;
        seller = _seller;

        name = _name;
        symbol = _symbol;
        totalSupply = _totalSupplyNoDecimals * 1e18;

        balances[seller] = totalSupply;
        Transfer(0x0, seller, totalSupply);
    }
",0x7aa43ef8aa1829fce420fd1f9e6ebbe2212b3e06/BsToken.sol:CommonBsToken:burn(uint256),"0x7aa43ef8aa1829fce420fd1f9e6ebbe2212b3e06/BsToken.sol:CommonBsToken:CommonBsToken(string,string,uint256,address)",0.2,4,4,0
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","0x3c7b396583ece191a7dc058af2fe399861497139/cybToken.sol:cybToken:transferFrom(address,address,uint256)","0x3c7b396583ece191a7dc058af2fe399861497139/cybToken.sol:cybToken:approveAndCall(address,uint256,bytes)",0.9913793103448276,5,5,1
"  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","  function assert(bool assertion) internal {
    if (!assertion) {
      revert();
    }
  }
","0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:SafeMath:max64(uint64,uint64)",0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:SafeMath:assert(bool),0.03378378378378378,4,4,0
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x8c1704ad15d1f42ddd0d0255532198b22e5c2aff/Involve.sol:SafeMath:add(uint256,uint256)","0x8c1704ad15d1f42ddd0d0255532198b22e5c2aff/Involve.sol:SafeMath:sub(uint256,uint256)",0.9747191011235956,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes _data) public returns (bool success) {
        return data.approveAndCall(spender, tokens, _data);
    }
","    function decimals() public view returns (uint8) {
        return data.decimals;
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:approveAndCall(address,uint256,bytes)",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:decimals(),1.0,5,5,1
"  function totalSupply() public constant returns (uint256) {
    return totalTokens;
  }
","  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
",0x08b4c866ae9d1be56a06e0c302054b4ffe067b43/BitCar.sol:BitCar:totalSupply(),"0x08b4c866ae9d1be56a06e0c302054b4ffe067b43/BitCar.sol:BitCar:allowance(address,address)",0.07692307692307693,4,4,0
"	function	Eligibility_Group_1				(				
		address	_User_1		,					
		IERC20Token	_Securities_1		,					
		uint256	_Standard_1							
	)									
		public	onlyOwner							
	{									
		User_1		=	_User_1		;			
		Securities_1		=	_Securities_1		;			
		Standard_1		=	_Standard_1		;			
	}									
","	function	setCmd	(	uint256	newCmd	)	public	onlyOwner	{	
		Cmd	=	newCmd	;					
	}									
","0x7b8b8e4f1accdce519569d3244f5dd51e569fa5a/DTCC_ILOW_7.sol:DTCC_ILOW_7:Eligibility_Group_1(address,IERC20Token,uint256)",0x7b8b8e4f1accdce519569d3244f5dd51e569fa5a/DTCC_ILOW_7.sol:DTCC_ILOW_7:setCmd(uint256),0.75,4,4,0
"    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false 
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender] 
                && now > unlockUnixTime[_to]);

        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }
","    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
                
        uint256 totalAmount = 0;
        
        for(uint j = 0; j < addresses.length; j++){
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);
        
        for (j = 0; j < addresses.length; j++) {
            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);
            Transfer(msg.sender, addresses[j], amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:transfer(address,uint256)","0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:distributeAirdrop(address[],uint256[])",0.5555555555555556,4,4,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && free_balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            free_balances[msg.sender] -= _value;
            balances[_to] += _value;
            free_balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x3f34f89aa02355d9dcfcbfd4adcbbfb135a8b4fd/tan_lian.sol:StandardToken:transfer(address,uint256)",0x3f34f89aa02355d9dcfcbfd4adcbbfb135a8b4fd/tan_lian.sol:StandardToken:balanceOf(address),0.0,4,4,0
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x0b24fdf35876bbe2a1cc925321b8c301017474d4/JustWallet.sol:JustWallet:approve(address,uint256)","0x0b24fdf35876bbe2a1cc925321b8c301017474d4/JustWallet.sol:JustWallet:transfer(address,uint256)",0.7991543340380549,4,4,0
"  function balanceOf(address _owner) constant public returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {

    if( preICO_address[msg.sender] ) require( now > endDate + 120 days ); //Lock coin
    else require( now > endDate ); //Lock coin

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x6be6d1dc9a2df5d34c106d8b5fb32a65ec0668ec/xxx.sol:StandardToken:balanceOf(address),"0x6be6d1dc9a2df5d34c106d8b5fb32a65ec0668ec/xxx.sol:StandardToken:transfer(address,uint256)",0.0005055611729019212,4,4,0
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function burn(uint256 _value) public onlyOwner returns (bool success) {
    require(_value <= balances[msg.sender]);
    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    return true;
  }
",0x4ce6b362bc77a24966dda9078f9cef81b3b886a7/NPERToken.sol:NPERToken:balanceOf(address),0x4ce6b362bc77a24966dda9078f9cef81b3b886a7/NPERToken.sol:NPERToken:burn(uint256),0.0005055611729019212,4,4,0
"    function calculateIdeaSell(uint256 _ideas) public view returns(uint256){
        return calculateTrade(_ideas,marketIdeas,address(this).balance);
    }
","    function getMyIdeas() public view returns(uint256){
        address _caller = msg.sender;
        return claimedIdeas[_caller].add(getIdeasSinceLastDeploy(_caller));
    }
",0x7c0f10bc53c0958e0edccef87a088f52c55843db/CloneFarmFarmer.sol:CloneFarmFarmer:calculateIdeaSell(uint256),0x7c0f10bc53c0958e0edccef87a088f52c55843db/CloneFarmFarmer.sol:CloneFarmFarmer:getMyIdeas(),0.6666666666666666,4,4,0
"    function depositTokens(uint amount) onlyOwner public {
        tokenContract.transferFrom(msg.sender, this, amount);
    }
","    function sellOneStep(uint quantity, uint minSaleReturn, address seller) public {
        uint amountInWei = formulaContract.calculateSaleReturn(
            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),
             address(this).balance + virtualReserveBalance,
             weight,
             quantity
        );
        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));
        
        require (enabled); // ADDED SEMICOLON
        require (amountInWei >= minSaleReturn);
        require (amountInWei <= address(this).balance);
        require (tokenContract.transferFrom(seller, this, quantity));

        collectedFees += (amountInWei * fee) / 1000000;


        emit Sell(seller, quantity, amountInWei);
        seller.transfer(amountInWei); //Always send ether last
    }
",0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:depositTokens(uint256),"0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:sellOneStep(uint256,uint256,address)",1.0,5,5,1
"  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x00f9f4f3ced5d4f6aedea8a92414206557df7167/SNL.sol:Ownable:renounceOwnership(),0x00f9f4f3ced5d4f6aedea8a92414206557df7167/SNL.sol:Ownable:Ownable(),0.152,4,4,0
"    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x4aff7f37696ce3bb0dbe10dd63bae8dc9f634623/Alpon.sol:Alpon:transfer(address,uint256,bytes)","0x4aff7f37696ce3bb0dbe10dd63bae8dc9f634623/Alpon.sol:Alpon:transferToAddress(address,uint256,bytes)",0.9444444444444444,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x1d8ca7baf0895da8afcf153657be064b5092a274/EthLyteToken.sol:EthLyteToken:approveAndCall(address,uint256,bytes)","0x1d8ca7baf0895da8afcf153657be064b5092a274/EthLyteToken.sol:EthLyteToken:transferAnyERC20Token(address,uint256)",0.9663299663299664,5,5,1
"  function refundTokens(address _token, address _refund, uint256 _value) {
    require (msg.sender == owner);
    require(_token != address(this));
    AbstractToken token = AbstractToken(_token);
    token.transfer(_refund, _value);
    RefundTokens(_token, _refund, _value);
  }
","  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      Freeze ();
    }
  }
","0x4acd666e5e13ca28931a9f582c4e55075803bbd0/GTSToken.sol:GTSToken:refundTokens(address,address,uint256)",0x4acd666e5e13ca28931a9f582c4e55075803bbd0/GTSToken.sol:GTSToken:freezeTransfers(),1.0,5,5,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function Owned() public {
        owner = msg.sender;
    }
",0x2a57dab627c3a1bc0b96ec2eeb92300db427e126/testTokan3.sol:Owned:onlyOwner(),0x2a57dab627c3a1bc0b96ec2eeb92300db427e126/testTokan3.sol:Owned:Owned(),0.2446657183499289,4,4,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x1d8ebb2f0345874e9193388ef3a2f063eaa71edc/QuadCoin.sol:QuadCoin:totalSupply(),"0x1d8ebb2f0345874e9193388ef3a2f063eaa71edc/QuadCoin.sol:QuadCoin:allowance(address,address)",0.9963503649635036,5,5,1
"    modifier notNull(address _address) {
        require(_address != 0);
        _;
    }
","    function isConfirmed(uint transactionId)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++) {
            if (confirmations[transactionId][owners[i]])
                count += 1;
            if (count == required)
                return true;
        }
    }
",0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notNull(address),0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:isConfirmed(uint256),0.5,4,4,0
"  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b/SMCT.sol:Ownable:renounceOwnership(),0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b/SMCT.sol:Ownable:Ownable(),0.152,4,4,0
"  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    safeAssert(c>=a && c>=b);
    return c;
  }
","  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    safeAssert(b > 0);
    uint256 c = a / b;
    safeAssert(a == b * c + a % b);
    return c;
  }
","0x0c686cd98f816bf63c037f39e73c1b7a35b51d4c/EPXToken.sol:safeMath:safeAdd(uint256,uint256)","0x0c686cd98f816bf63c037f39e73c1b7a35b51d4c/EPXToken.sol:safeMath:safeDiv(uint256,uint256)",0.9375,5,5,1
"  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }
","  function Crowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) {
    require(_startBlock >= block.number);
    require(_endBlock >= _startBlock);
    require(_rate > 0);
    require(_wallet != 0x0);

    token = createTokenContract();
    startBlock = _startBlock;
    endBlock = _endBlock;
    rate = _rate;
    wallet = _wallet;
  }
",0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:Crowdsale:forwardFunds(),"0x3aca783ca0bd7ae06f4440bf58d3a75e425ec3ee/CappedCrowdsale.sol:Crowdsale:Crowdsale(uint256,uint256,uint256,address)",0.04464285714285714,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) transfersEnabled public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function decreaseApproval(address _spender, uint _subtractedValue) transfersEnabled public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        }
        else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","0x4dda7044db5fa409cc36629077ef6e56ee9a96ee/LINCToken.sol:StandardToken:transferFrom(address,address,uint256)","0x4dda7044db5fa409cc36629077ef6e56ee9a96ee/LINCToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8616438356164383,4,4,0
"  modifier whenPaused {
    require(paused);
    _;
  }
","  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
",0x4ca68c8ecb94acbc736bcb4119fd76aa5170b226/StupidCoin.sol:Pausable:whenPaused(),0x4ca68c8ecb94acbc736bcb4119fd76aa5170b226/StupidCoin.sol:Pausable:unpause(),0.1054421768707483,4,4,0
"    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a - b;
        assert(b <= a && c <= a);
        return c;
    }
","    function SafeMath() public{
    }
","0x7d4bb661561ed8db39ab30221787f5c0ab09bc28/MANXERC20.sol:SafeMath:safeSub(uint256,uint256)",0x7d4bb661561ed8db39ab30221787f5c0ab09bc28/MANXERC20.sol:SafeMath:SafeMath(),0.5,4,4,0
"    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function strConcat(string _a, string _b, string _c) internal returns (string) {
        return strConcat(_a, _b, _c, """", """");
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[5])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:strConcat(string,string,string)",0.8,4,4,0
"	function	getData_7	()	public	constant	returns	(	string	)	{
		return	inData_7	;						
	}									
","	function	getData_20	()	public	constant	returns	(	string	)	{
		return	inData_20	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_7(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_20(),1.0,5,5,1
"    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:transferToContract(address,uint256,bytes)","0x2cc114bbe7b551d62b15c465c7bdcccd9125b182/IdolCoin.sol:IdolCoin:transferToAddress(address,uint256,bytes)",0.9523809523809524,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;

        bytes32 sigr;
        bytes32 sigs;

        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }


        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(sha3(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(sha3(pubkey)) == signer);
        }
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:verifySig(bytes32,bytes,bytes)",0.8,4,4,0
"  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:SafeMath:min256(uint256,uint256)","0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:SafeMath:max64(uint64,uint64)",0.8390804597701149,4,4,0
"    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {
        require(self.mintable);
        require(msg.sender == self.minter || msg.sender == self.owner);
        if (lockAccount) {
            self.accountLocked[tokenOwner] = true;
        }
        self.balances[tokenOwner] = safeAdd(self.balances[tokenOwner], tokens);
        self.totalSupply = safeAdd(self.totalSupply, tokens);
        Mint(tokenOwner, tokens, lockAccount);
        Transfer(address(0), tokenOwner, tokens);
        return true;
    }
","    function signedApproveAndCallCheck(Data storage self, address tokenOwner, address spender, uint tokens, bytes data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {
        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;
        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);
        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;
        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;
        if (self.nextNonce[tokenOwner] != nonce) return BTTSTokenInterface.CheckResult.InvalidNonce;
        if (self.balances[tokenOwner] < fee) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;
        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;
        return BTTSTokenInterface.CheckResult.Success;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:mint(BTTSLib:Data,address,uint256,bool)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedApproveAndCallCheck(BTTSLib:Data,address,address,uint256,bytes,uint256,uint256,bytes,address)",1.0,5,5,1
"    function totalSupply() constant returns (uint256 totalSupply) {        
		return _totalSupply;
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x3D45fd77243365Ba890f32746368a859AE6B7dc9/EtherHealthClub.sol:EtherHealthClub:totalSupply(),0x3D45fd77243365Ba890f32746368a859AE6B7dc9/EtherHealthClub.sol:EtherHealthClub:balanceOf(address),0.5842696629213483,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x5af61166c207e5d08607189d6f8d3da39f5e0d5b/Talius.sol:StandardToken:transferFrom(address,address,uint256)","0x5af61166c207e5d08607189d6f8d3da39f5e0d5b/Talius.sol:StandardToken:approve(address,uint256)",0.9715504978662872,5,5,1
"    function useKnowledge(address ref) external {
        require(initialized);
        if(referrals[msg.sender] == 0 && referrals[msg.sender]!=msg.sender){
            referrals[msg.sender] = ref;
        }
        uint256 knowledgeUsed = getMyKnowledge();
        uint256 newFranklin = SafeMath.div(knowledgeUsed,KNOWLEDGE_TO_GET_1FRANKLIN);
        hatcheryFranklin[msg.sender] = SafeMath.add(hatcheryFranklin[msg.sender],newFranklin);
        claimedKnowledge[msg.sender] = 0;
        lastUse[msg.sender] = now;
        
        //send referral
        claimedKnowledge[referrals[msg.sender]] = SafeMath.add(claimedKnowledge[referrals[msg.sender]],SafeMath.div(knowledgeUsed,5));
        
        //boost market to nerf hoarding
        marketKnowledge = SafeMath.add(marketKnowledge,SafeMath.div(knowledgeUsed,10));
    }
","    function getMyKnowledge() public view returns(uint256){
        return SafeMath.add(claimedKnowledge[msg.sender],getKnowledgeSinceLastUse(msg.sender));
    }
",0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:useKnowledge(address),0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:getMyKnowledge(),0.25,4,4,0
"    modifier onlyCommunity() {
        require(msg.sender == unicornManagement.communityAddress());
        _;
    }
","    modifier onlyBlackBox() {
        require(msg.sender == unicornManagement.blackBoxAddress());
        _;
    }
",0x4fdb91dbce6cee2e08cf85d26eaa3e9bca0c12fe/UnicornBreeding.sol:UnicornAccessControl:onlyCommunity(),0x4fdb91dbce6cee2e08cf85d26eaa3e9bca0c12fe/UnicornBreeding.sol:UnicornAccessControl:onlyBlackBox(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) return false;
        if (balances[msg.sender] < _value) return false;
        if (balances[_to] + _value < balances[_to]) return false;
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowances[_owner][_spender];
    }
","0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:transfer(address,uint256)","0x4dc64a91acc6d3f69da1908935e168e0449db506/ColaToken.sol:ColaToken:allowance(address,address)",0.07692307692307693,4,4,0
"    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }
","0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:allowance(address,address)",0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:disableWhitelist(address[]),0.00904977375565611,4,4,0
"	function	setPI_edit_7	(	string	newPI_edit_7	)	public	onlyOwner	{	
		inPI_edit_7	=	newPI_edit_7	;					
	}									
","	function	getPI_edit_21	()	public	constant	returns	(	string	)	{
		return	inPI_edit_21	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_7(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_21(),1.0,5,5,1
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x0cf55facee33ed2827d78ad2d113efe0aa80a92b/BITTOToken.sol:Ownable:onlyOwner(),0x0cf55facee33ed2827d78ad2d113efe0aa80a92b/BITTOToken.sol:Ownable:Ownable(),0.4556661925082978,4,4,0
"    function distributeDEXT(address[] addresses, uint256 _value, uint256 _ethbal) onlyOwner canDistr public {
         for (uint i = 0; i < addresses.length; i++) {
	     if (getEthBalance(addresses[i]) < _ethbal) {
 	         continue;
             }
             balances[owner] -= _value;
             balances[addresses[i]] += _value;
             Transfer(owner, addresses[i], _value);
         }
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
	 return balances[_owner];
    }
","0x3cd7047117dbfd0dcb470514172ace9f394c31e8/DEXToken.sol:DEXToken:distributeDEXT(address[],uint256,uint256)",0x3cd7047117dbfd0dcb470514172ace9f394c31e8/DEXToken.sol:DEXToken:balanceOf(address),1.0,5,5,1
"    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_setNetworkName(string),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[])",1.0,5,5,1
"	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}
","	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}
","0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:setTokenOwner(uint256,address)","0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:setOwnedArea(address,uint256)",1.0,5,5,1
"    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_useCoupon(string),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)",1.0,5,5,1
"  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {
      
    if(isContract(_to)) {
        return transferToContract(_to, _value, _data);
    }
    else {
        return transferToAddress(_to, _value, _data);
    }
}
","  function getEndICO() public constant returns (uint256){
      return endICO;
  }
","0x6c2fa6691b237c9e453926d8d484d4c5ab635db5/PiperToken.sol:PiperToken:transfer(address,uint256,bytes)",0x6c2fa6691b237c9e453926d8d484d4c5ab635db5/PiperToken.sol:PiperToken:getEndICO(),0.038461538461538464,4,4,0
"    function changeAdmin(address newAdmin) public onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
","    function emergencyERC20Drain( ERC20 token, uint amount ) public onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer( owner, amount );
    }
",0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:WobToken:changeAdmin(address),"0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:WobToken:emergencyERC20Drain(ERC20,uint256)",1.0,5,5,1
"    constructor() public {
        owner = 0xc22F305B804a7AD7684eC4BB07A0553BDf4d51c7;
        name = ""DCEGL"";
        symbol = ""DCEGL"";
        decimals = 18;
        totalSupply = 8600000000 * 10 ** uint256(18);
        
        //init totalSupply to map(db)
        balanceOf[owner] = totalSupply;
    }
","    function _transfer(address _from,address _to, uint256 _value) internal {
        //validate input and other internal limites
        require(_to != 0x0);//check to address
        require(balanceOf[_from] >= _value);//check from address has enough balance 
        require(balanceOf[_to] + _value >balanceOf[_to]);//after transfer the balance of _to address is ok ,no overflow
        uint256 previousBalances = balanceOf[_from]+balanceOf[_to];//store it for add asset to power the security
        //do transfer:sub from _from address,and add to the _to address
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        //after transfer: emit transfer event,and add asset for security
        emit Transfer(_from,_to,_value);
        assert(balanceOf[_from]+balanceOf[_to] == previousBalances);
    }
",0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:constructor(),"0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:_transfer(address,address,uint256)",1.0,5,5,1
"    modifier onlyWallet() {
        if (msg.sender != address(this))
            throw;
        _;
    }
","    function getConfirmationCount(uint transactionId)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionId][owners[i]])
                count += 1;
    }
",0x5aa7ec82de098d957699d78a2515610707e89231/MultiSigWallet.sol:MultiSigWallet:onlyWallet(),0x5aa7ec82de098d957699d78a2515610707e89231/MultiSigWallet.sol:MultiSigWallet:getConfirmationCount(uint256),0.6666666666666666,4,4,0
"    function addCbAddress(address newCbAddress, byte addressType, bytes proof) 
    onlyadmin {
        cbAddresses[newCbAddress] = addressType;
    }
","    function query1_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return query1(_timestamp, _datasource, _arg, _gaslimit);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:addCbAddress(address,bytes1,bytes)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query1_withGasLimit(uint256,string,string,uint256)",1.0,5,5,1
"    function IchigoToken() public {
        symbol = ""ICH"";
        name = ""Ichigo"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0x58237c011DaA0abe2D6e1fda1a014427eFC2D7FB] = _totalSupply;
        Transfer(address(0), 0x58237c011DaA0abe2D6e1fda1a014427eFC2D7FB, _totalSupply);
    }
","    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
",0x6bf83a9507a16e774c0f8ec74ada9314eea9e11e/IchigoToken.sol:IchigoToken:IchigoToken(),0x6bf83a9507a16e774c0f8ec74ada9314eea9e11e/IchigoToken.sol:IchigoToken:totalSupply(),0.9934640522875816,5,5,1
"    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x4f958f4414c5e6366882433a07b67977c6ec45be/MyTestToken1.sol:Owned:transferOwnership(address),0x4f958f4414c5e6366882433a07b67977c6ec45be/MyTestToken1.sol:Owned:onlyOwner(),0.8634920634920635,4,4,0
"  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x3c159c0b03974f4b2befdde6f9f4ef09fd8d697b/CulturalCoinToken.sol:ExtendedToken:decreaseApproval(address,uint256)","0x3c159c0b03974f4b2befdde6f9f4ef09fd8d697b/CulturalCoinToken.sol:ExtendedToken:increaseApproval(address,uint256)",0.9655990510083036,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x2a434a3c1fd28a334b982cd19a973ea412e7f294/PEERBANKS.sol:StandardToken:transfer(address,uint256)",0x2a434a3c1fd28a334b982cd19a973ea412e7f294/PEERBANKS.sol:StandardToken:balanceOf(address),0.9776632302405498,5,5,1
"    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[2])","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[5],uint256)",1.0,5,5,1
"  function transfer_eth_from_contract(address _to, uint256 _amount) private {
    eth_balance = eth_balance.sub(_amount);
    _to.transfer(_amount);
  }
","  function withdraw_arbitrary_token(address _token, uint256 _amount) public only_admin() {
      require(_token != traded_token);
      require(Token(_token).transfer(admin, _amount));
  }
","0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:transfer_eth_from_contract(address,uint256)","0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:withdraw_arbitrary_token(address,uint256)",0.5,4,4,0
"    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
",0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:updateTokensPerEth(uint256),0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:balanceOf(address),1.0,5,5,1
"  function MyBoToken(
  uint256 initialSupply,
  string tokenName,
  uint8 decimalUnits,
  string tokenSymbol
  ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    if (frozenAccount[_from]) throw;                        // Check if frozen
    if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
    if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
    if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
    balanceOf[_from] -= _value;                          // Subtract from the sender
    balanceOf[_to] += _value;                            // Add the same to the recipient
    allowance[_from][msg.sender] -= _value;
    Transfer(_from, _to, _value);
    return true;
  }
","0x3ac96bbe8b60d715fd818b3fe242edf9def20571/MyBoToken.sol:MyBoToken:MyBoToken(uint256,string,uint8,string)","0x3ac96bbe8b60d715fd818b3fe242edf9def20571/MyBoToken.sol:MyBoToken:transferFrom(address,address,uint256)",0.7,4,4,0
"	function add(uint256 a, uint256 b) internal constant returns (uint256) {
		uint256 c = a + b;
		assert(c >= a);
		return c;
	}
","	function mul(uint256 a, uint256 b) internal constant returns (uint256) {
		uint256 c = a * b;
		assert(a == 0 || c / a == b);
		return c;
	}
","0x7D0e4542ef04C83C3C6C5a8FD3CD995a2A1EE283/GexCrypto.sol:SafeMath:add(uint256,uint256)","0x7D0e4542ef04C83C3C6C5a8FD3CD995a2A1EE283/GexCrypto.sol:SafeMath:mul(uint256,uint256)",0.7943820224719101,4,4,0
"    function transfer(address _to, uint256 _value) returns(bool success)
    {
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to])
    {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
    else { return false; }
}
","function balanceOf(address _owner) constant returns(uint256 balance)
{
    return balances[_owner];
}
","0x6b8880260f71d2370cc2b754b4ba0ec9861e04a4/RaliusToken.sol:StandardToken:transfer(address,uint256)",0x6b8880260f71d2370cc2b754b4ba0ec9861e04a4/RaliusToken.sol:StandardToken:balanceOf(address),0.8452380952380952,4,4,0
"    function sellKnowledge() external {
        require(initialized);
        address customerAddress = msg.sender;
        uint256 hasKnowledge = getMyKnowledge();
        uint256 knowledgeValue = calculateKnowledgeSell(hasKnowledge);
        uint256 fee = devFee(knowledgeValue);
        claimedKnowledge[customerAddress] = 0;
        lastUse[customerAddress] = now;
        marketKnowledge = SafeMath.add(marketKnowledge,hasKnowledge);
        owner.transfer(fee);
        //
        uint256 amountLeft = SafeMath.sub(knowledgeValue,fee);
        //customerAddress.transfer(amountLeft);
        contractCall.buy.value(amountLeft)(customerAddress);
        contractCall.transfer(customerAddress, myTokens()); // 50000000000000000 = 0.05 Rev1 tokens
    }
","    function getMyFranklin() public view returns(uint256){
        return hatcheryFranklin[msg.sender];
    }
",0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:sellKnowledge(),0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:getMyFranklin(),1.0,5,5,1
"	function	setData_23	(	string	newData_23	)	public	onlyOwner	{	
		inData_23	=	newData_23	;					
	}									
","	function	getData_5	()	public	constant	returns	(	string	)	{
		return	inData_5	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_23(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_5(),1.0,5,5,1
"    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] > _value);                // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }
","0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf/SmartPayment.sol:SmartPayment:mintToken(address,uint256)","0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf/SmartPayment.sol:SmartPayment:_transfer(address,address,uint256)",0.6416666666666667,4,4,0
"    function parseInt(string _a, uint _b) internal pure returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }
","    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseInt(string,uint256)",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_getPrice(string),0.5,4,4,0
"  function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x3bcfe4786ce5669fe06282ebf11afe3d0f606cda/Leaxcoin.sol:StandardToken:increaseApproval(address,uint256)","0x3bcfe4786ce5669fe06282ebf11afe3d0f606cda/Leaxcoin.sol:StandardToken:approve(address,uint256)",0.2857142857142857,4,4,0
"    function strConcat(string _a, string _b) internal returns (string) {
        return strConcat(_a, _b, """", """", """");
    }
","    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:strConcat(string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:strConcat(string,string,string,string)",1.0,5,5,1
"    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
","    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
",0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:finishDistribution(),"0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:transfer(address,uint256)",1.0,5,5,1
"    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","    function CBRToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
",0x7e750348983e17267dfbe939dfa008b25fd07459/CBRToken.sol:CBRToken:buy(),"0x7e750348983e17267dfbe939dfa008b25fd07459/CBRToken.sol:CBRToken:CBRToken(uint256,string,string)",0.4264705882352941,4,4,0
"  modifier onlyPauseAdmin()
  {
    checkRole(msg.sender, ROLE_PAUSE_ADMIN);
    _;
  }
","  function adminRemoveRole(address addr, string roleName)
    onlyAdmin
    public
  {
    removeRole(addr, roleName);
  }
",0x3cd20d014384c16537a9ac945d7c39e470183e79/Necropolis.sol:RBACWithAdmin:onlyPauseAdmin(),"0x3cd20d014384c16537a9ac945d7c39e470183e79/Necropolis.sol:RBACWithAdmin:adminRemoveRole(address,string)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success)   
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function totalSupply() constant returns (uint256) {
        return _totalSupply;
    }
","0x7e4220f71949024a4dcb46fcc61e2b13f3f4d25a/ZhuhuaToken.sol:StandardToken:approve(address,uint256)",0x7e4220f71949024a4dcb46fcc61e2b13f3f4d25a/ZhuhuaToken.sol:StandardToken:totalSupply(),0.027911969940955447,4,4,0
"    function ba2cbor(bytes[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:ba2cbor(bytes[]),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[4],uint256)",1.0,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x3d5240cd93c8a6471386418dc912923a70e691f8/Neutoken.sol:Neutoken:transfer(address,uint256)","0x3d5240cd93c8a6471386418dc912923a70e691f8/Neutoken.sol:Neutoken:transferAnyERC20Token(address,uint256)",0.9604743083003952,5,5,1
"    function allowance(address _owner, address _spender) 
    public
    constant 
    returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","    function balanceOf(address _addr) 
    public
    constant 
    returns (uint256) {
        return balances[_addr];
    }
","0x1db542d3d1df0ea7746f4a3c32341cb47877c193/SPIKE.sol:BasicSPIKE:allowance(address,address)",0x1db542d3d1df0ea7746f4a3c32341cb47877c193/SPIKE.sol:BasicSPIKE:balanceOf(address),0.0017006802721088435,4,4,0
"    function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
","    modifier onlyWallet() {
        require(msg.sender == address(this));
        _;
    }
",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:confirmTransaction(uint256),0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:onlyWallet(),0.25,4,4,0
"    function decimals() public view returns (uint8) {
        return data.decimals;
    }
","    function enableTransfers() public {
        data.enableTransfers();
    }
",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:decimals(),0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:enableTransfers(),0.5,4,4,0
"  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
","0x01ff50f8b7f74e4f00580d9596cd3d0d6d6e326f/BftToken.sol:PausableToken:increaseApproval(address,uint256)","0x01ff50f8b7f74e4f00580d9596cd3d0d6d6e326f/BftToken.sol:PausableToken:approve(address,uint256)",1.0,5,5,1
"	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}
","	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}
","0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:setImageOwner(uint256,address)","0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getImageData(uint256,uint16)",1.0,5,5,1
"	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}
","	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}
","0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:setRegionCurrentPixelPrice(uint256,uint256)",0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:deleteRegionData(uint256),1.0,5,5,1
"    function sE(string info) private oO { email = info; }
","    function transfer(address _to, uint256 _value) public returns (bool) {require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); return true;}
",0x2f3abc0a1cf1d7d0487fd220aa3283a63982ba60/Coinage.sol:Bitcoin:sE(string),"0x2f3abc0a1cf1d7d0487fd220aa3283a63982ba60/Coinage.sol:Bitcoin:transfer(address,uint256)",0.0,4,4,0
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[2],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[1],uint256)",1.0,5,5,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x04cd5f369825c0b2ae1e7a6e8559734f6080fbb5/MobiCoin.sol:StandardToken:increaseApproval(address,uint256)","0x04cd5f369825c0b2ae1e7a6e8559734f6080fbb5/MobiCoin.sol:StandardToken:approve(address,uint256)",0.9189189189189192,4,4,0
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x7c62752173591de60ed72cfcfc41ca55aa3d87d6/ETUex.sol:ERC20Token:balanceOf(address),"0x7c62752173591de60ed72cfcfc41ca55aa3d87d6/ETUex.sol:ERC20Token:approve(address,uint256)",0.06825075834175935,4,4,0
"    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x0aa8c93dcb9fc992ec46c5d7a42f636989f5887a/ARMYToken.sol:SafeMath:add(uint256,uint256)","0x0aa8c93dcb9fc992ec46c5d7a42f636989f5887a/ARMYToken.sol:SafeMath:sub(uint256,uint256)",0.9774647887323944,5,5,1
"    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:onlyWhitelist(),0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:transferOwnership(address),0.8611111111111112,4,4,0
"    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }
","    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(timestamp, datasource, arg);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:strConcat(string,string,string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string)",0.4444444444444444,4,4,0
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
","  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }
",0x6c541450d0942c99e043e9df791414b34637a8e1/IagonToken.sol:Pausable:unpause(),0x6c541450d0942c99e043e9df791414b34637a8e1/IagonToken.sol:Pausable:pause(),0.9924812030075189,5,5,1
"	function	setPOOL_edit_24	(	string	newPOOL_edit_24	)	public	onlyOwner	{	
		inPOOL_edit_24	=	newPOOL_edit_24	;					
	}									
","	function	getPOOL_edit_21	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_21	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_24(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_21(),1.0,5,5,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:TokenERC20:approve(address,uint256)","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:TokenERC20:approveAndCall(address,uint256,bytes)",0.8964059196617337,4,4,0
"	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}
","	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpContracts:getBdpControllerHelper(address[16]),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpContracts:getBdpPriceStorage(address[16]),1.0,5,5,1
"    function burnFrom(address _from, uint256 _value) returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","    function burn(uint256 _value) returns (bool success) {
        require (balanceOf[msg.sender] > _value);            // Check if the sender has enough
        balanceOf[msg.sender] -= _value;                      // Subtract from the sender
        totalSupply -= _value;                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x7b69b78cc7fee48202c208609ae6d1f78ce42e13/GoalToken.sol:GoalToken:burnFrom(address,uint256)",0x7b69b78cc7fee48202c208609ae6d1f78ce42e13/GoalToken.sol:GoalToken:burn(uint256),0.9738903394255874,5,5,1
"    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {
        z = x / y;
    }
","    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x * y) >= x);
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:div(uint256,uint256)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:mul(uint256,uint256)",0.6666666666666666,4,4,0
"  function setDistributedAutonomousExchange(address _address) external onlyBy(owner) {
    distributedAutonomousExchange = _address;
  }
","  function approve(address _spender, uint256 _value) public notPaused isWhitelistedOrFreeTransferAllowed(msg.sender) returns (bool) {
    return super.approve(_spender, _value);
  }
",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:setDistributedAutonomousExchange(address),"0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:approve(address,uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {
        require(_to != address(0));

        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // require (_value <= _allowance);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        if(transferIns[_from].length > 0) delete transferIns[_from];
        uint64 _now = uint64(now);
        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));
        transferIns[_to].push(transferInStruct(uint128(_value),_now));
        return true;
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x1b3bde49d13aec2d3629be78c341f61fd21a7cc4/Meristem.sol:Meristem:transferFrom(address,address,uint256)","0x1b3bde49d13aec2d3629be78c341f61fd21a7cc4/Meristem.sol:Meristem:allowance(address,address)",1.0,5,5,1
"    function mul(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","    function add(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x2f284c39b25ced8e910155f1c6e358be9ee970e3/MonkeyMan.sol:SafeMath:mul(uint256,uint256)","0x2f284c39b25ced8e910155f1c6e358be9ee970e3/MonkeyMan.sol:SafeMath:add(uint256,uint256)",0.9272131147540984,5,5,1
"    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","0x2cf843901efe9aaa8fd9fa86dcb64e1293370ad5/SUAPPToken.sol:SUAPPToken:distr(address,uint256)",0x2cf843901efe9aaa8fd9fa86dcb64e1293370ad5/SUAPPToken.sol:SUAPPToken:balanceOf(address),0.9166666666666666,4,4,0
"	function	getPI_edit_30	()	public	constant	returns	(	string	)	{
		return	inPI_edit_30	;						
	}									
","	function	getPI_edit_7	()	public	constant	returns	(	string	)	{
		return	inPI_edit_7	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_30(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_7(),1.0,5,5,1
"	function	setData_34	(	string	newData_34	)	public	onlyOwner	{	
		inData_34	=	newData_34	;					
	}									
","	function	setData_13	(	string	newData_13	)	public	onlyOwner	{	
		inData_13	=	newData_13	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_34(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_13(string),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x3bec87639cbf6c3155280ee9fd920ff0b3f66f7a/Unicoin.sol:StandardToken:transferFrom(address,address,uint256)","0x3bec87639cbf6c3155280ee9fd920ff0b3f66f7a/Unicoin.sol:StandardToken:approve(address,uint256)",0.9715504978662872,5,5,1
"		function	setDepositary_function_control	(	uint256	newDepositary_function_control	)	public	onlyOwner	{	
			Depositary_function_control	=	newDepositary_function_control	;					
		}									
","		function	setDepositary_function	(	uint256	newDepositary_function	)	public	onlyOwner	{	
			Depositary_function	=	newDepositary_function	;					
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setDepositary_function_control(uint256),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setDepositary_function(uint256),1.0,5,5,1
"	function Ownable() public 
	{
		owner = msg.sender;
	}
","	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}
",0x2a6a139da8d1f430696663d640591d5199aa718e/JjWorldToken.sol:Ownable:Ownable(),0x2a6a139da8d1f430696663d640591d5199aa718e/JjWorldToken.sol:Ownable:onlyOwner(),0.9294003868471954,5,5,1
"    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        initialize(_from);

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[_from] -= _amount;
                allowed[_from][msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(_from, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
","    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
","0x0a283ed40e2f050b53094d08bde36f67db50bcfa/FreeCoin.sol:FreeCoin:transferFrom(address,address,uint256)","0x0a283ed40e2f050b53094d08bde36f67db50bcfa/FreeCoin.sol:FreeCoin:approve(address,uint256)",0.796875,4,4,0
"  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
","0x4f1d24f8d60b1f8872abbd409e6bfaa54d7a9f40/CTCToken.sol:StandardToken:decreaseApproval(address,uint256)","0x4f1d24f8d60b1f8872abbd409e6bfaa54d7a9f40/CTCToken.sol:StandardToken:approve(address,uint256)",0.8907363420427553,4,4,0
"    function calculateEggSell(uint256 eggs) public view returns(uint256){
        return calculateTrade(eggs,marketEggs, address(this).balance);
    }
","    function getMyCrabs() public view returns(uint256){
        return hatchery[msg.sender];
    }
",0x8c7f97965f6811e5f1e839ef23d38d2ecd86a445/CrabFarm.sol:CrabFarm:calculateEggSell(uint256),0x8c7f97965f6811e5f1e839ef23d38d2ecd86a445/CrabFarm.sol:CrabFarm:getMyCrabs(),1.0,5,5,1
"    function multiPartyTransfer(address[] _toAddresses, uint256[] _amounts) public {
        /* Ensures _toAddresses array is less than or equal to 255 */
        require(_toAddresses.length <= 255);
        /* Ensures _toAddress and _amounts have the same number of entries. */
        require(_toAddresses.length == _amounts.length);

        for (uint8 i = 0; i < _toAddresses.length; i++) {
            transfer(_toAddresses[i], _amounts[i]);
        }
    }
","    function BCCT() public {balanceOf[msg.sender] = totalSupply;}
","0x6a0abbde66e54d4b22d71427076026089d2d6aa7/BCCT.sol:BCCT:multiPartyTransfer(address[],uint256[])",0x6a0abbde66e54d4b22d71427076026089d2d6aa7/BCCT.sol:BCCT:BCCT(),0.75,4,4,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","0x1aad546be24ce0a36d0586c0d605296c2751bdf0/HammerChainBeta.sol:HammerChainBeta:approveAndCall(address,uint256,bytes)",0x1aad546be24ce0a36d0586c0d605296c2751bdf0/HammerChainBeta.sol:HammerChainBeta:burn(uint256),0.7544910179640718,4,4,0
"    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balanceOf[_owner];
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x1d07f0704dbb88298c69e351c92a82272f0daf75/SoundTribeToken.sol:SoundTribeToken:balanceOf(address),"0x1d07f0704dbb88298c69e351c92a82272f0daf75/SoundTribeToken.sol:SoundTribeToken:transferFrom(address,address,uint256)",0.3488372093023256,4,4,0
"  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }
","  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }
",0x0bcaa1c8da60b9f9711191ebf192c879870b322a/SkillChainPrivateSale.sol:Crowdsale:createTokenContract(),0x0bcaa1c8da60b9f9711191ebf192c879870b322a/SkillChainPrivateSale.sol:Crowdsale:forwardFunds(),0.6938775510204082,4,4,0
"    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[3],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getPrice(string,uint256)",0.8,4,4,0
"	function Cryptoya(
    	) public{
    	fulltoken = 500000000;  	 
    	decimals = 18;                        	// Amount of decimals for display purposes
    	_totalSupply = fulltoken.mul(10 ** uint256(decimals)); // Update total supply (100000 for example)
    	balances[msg.sender] = _totalSupply;           	// Give the creator all initial tokens (100000 for example)
    	name = ""Cryptoya"";                               	// Set the name for display purposes
    	symbol = ""CRA"";                           	// Set the symbol for display purposes
	}
","	function totalSupply() constant public returns (uint256 supply){
   	 
    	return _totalSupply;
	}
",0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:Cryptoya:Cryptoya(),0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:Cryptoya:totalSupply(),0.0,4,4,0
"    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
        
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
","0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:distr(address,uint256)","0x0dba7ca3d25f8c2f46d9b06ba7b1b3144e206f38/BFTToken.sol:BFTToken:allowance(address,address)",0.8888888888888888,4,4,0
"  function decreaseApproval (address _spender, uint _subtractedValue) 
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval (address _spender, uint _addedValue) 
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x1f8b657d1008798842edf8ea80b135ca723295a1/Spacoin.sol:StandardToken:decreaseApproval(address,uint256)","0x1f8b657d1008798842edf8ea80b135ca723295a1/Spacoin.sol:StandardToken:increaseApproval(address,uint256)",0.9655990510083036,5,5,1
"    function withdrawEther()
        external
        onlyOwner
    {
        owner.transfer(this.balance);
    }
","    function BsktToken(
        address[] addresses,
        uint256[] quantities,
        uint256 _creationUnit,
        string _name,
        string _symbol
    ) public {
        require(0 < addresses.length && addresses.length < 256);
        require(addresses.length == quantities.length);
        require(_creationUnit >= 1);

        for (uint256 i = 0; i < addresses.length; i++) {
            tokens.push(TokenInfo({
                addr: addresses[i],
                quantity: quantities[i]
            }));
        }

        creationUnit_ = _creationUnit;
        name = _name;
        symbol = _symbol;
    }
",0x1d1af2ba9a9cb472a7d6c2499b6622265822df5d/BsktToken.sol:BsktToken:withdrawEther(),"0x1d1af2ba9a9cb472a7d6c2499b6622265822df5d/BsktToken.sol:BsktToken:BsktToken(address[],uint256[],uint256,string,string)",0.047619047619047616,4,4,0
"    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[4],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_getPrice(string,uint256)",0.8,4,4,0
"    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {
        return oraclize.setConfig(config);
    }
","    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_setConfig(bytes32),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string)",1.0,5,5,1
"    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
","    function Visualrocktoken() public {
        balanceOf[msg.sender] = totalSupply;
    }
",0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:finishMinting(),0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:Visualrocktoken(),0.020202020202020204,4,4,0
"	function withdrawForThreeStep() external
		onlyOwner
		assertFalse(hasThreeStepWithdraw)
		notBeforeTime(1567785600)
	{
		processFunding(msg.sender,TEAM_UNFREEZE,1);
		//???????
		hasThreeStepWithdraw = true;
	}
","	modifier notBeforeTime(uint256 targetTime){
		assert(now>targetTime);
		_;
	}
",0x2a5294b5d15c582eb33b9dae0e271d9003d26826/BTMC.sol:BTMC:withdrawForThreeStep(),0x2a5294b5d15c582eb33b9dae0e271d9003d26826/BTMC.sol:BTMC:notBeforeTime(uint256),1.0,5,5,1
"    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:SafeMath:mul(uint256,uint256)","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:SafeMath:div(uint256,uint256)",0.6934189406099518,4,4,0
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x01f673e1af7416ff3795ff62393cdf014ce050fd/DiscardToken.sol:DiscardToken:balanceOf(address),"0x01f673e1af7416ff3795ff62393cdf014ce050fd/DiscardToken.sol:DiscardToken:allowance(address,address)",0.996875,5,5,1
"    constructor(string symbol_) public {
        symbol = symbol_;
    }
","    function pull(address src, uint wad) public {
        transferFrom(src, msg.sender, wad);
    }
",0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:CARSToken:constructor(string),"0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:CARSToken:pull(address,uint256)",1.0,5,5,1
"    function setPlatformFeePer10000(uint newFee)
    external
    only(owner) {
        require (newFee <= 10000); //formally maximum fee is 100% (completely insane but technically possible)
        PLATFORM_FEE_PER_10000 = newFee;
    }
","    function setBeneficiary(address newBeneficiary)
    external
    only(owner) {
        beneficiary = newBeneficiary;
    }
",0x2d4370400cdcbec8f26ee4face1fa120227271e4/SAN.sol:SAN:setPlatformFeePer10000(uint256),0x2d4370400cdcbec8f26ee4face1fa120227271e4/SAN.sol:SAN:setBeneficiary(address),1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed [_owner][_spender];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances [_from] > _value
            && _value > 0 
            );
            balances[_from] -= _value;
            balances[_to] += _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
    }
","0x2c3b9d47f9a80507e93c9401eb22e111672604a3/JCoinz.sol:JCoinz:allowance(address,address)","0x2c3b9d47f9a80507e93c9401eb22e111672604a3/JCoinz.sol:JCoinz:transferFrom(address,address,uint256)",0.280187074829932,4,4,0
"    function STVCOIN(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","0x6ccf98a13ed658678bfe9a319d4454e5f170114d/STVCOIN.sol:STVCOIN:STVCOIN(uint256,string,string)",0x6ccf98a13ed658678bfe9a319d4454e5f170114d/STVCOIN.sol:STVCOIN:burn(uint256),0.8482142857142857,4,4,0
"    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;

        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);

        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);

        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = 1; //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);

        if (sigok == false) return false;


        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";

        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);

        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);

        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);

        return sigok;
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setNetwork(uint8),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x4e1946d7a66e09616933e11626b508f315a8aaee/VIRTVEN.sol:StandardToken:approve(address,uint256)","0x4e1946d7a66e09616933e11626b508f315a8aaee/VIRTVEN.sol:StandardToken:allowance(address,address)",0.907139023081052,4,4,0
"  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","  function Ownable() {
    owner = msg.sender;
  }
",0x2B80455F56ca8b84E73460aC9b4db2a5e7c6030C/IFOFirstRound.sol:Ownable:onlyOwner(),0x2B80455F56ca8b84E73460aC9b4db2a5e7c6030C/IFOFirstRound.sol:Ownable:Ownable(),0.4556661925082978,4,4,0
"	function setSetupComplete() external onlyOwner {
		setupComplete = true;
	}
","	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}
",0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpBase:setSetupComplete(),0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpBase:setOwner(address),1.0,5,5,1
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[2],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),0.8,4,4,0
"    function YSS(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits, address centralMinter) public {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        if (centralMinter != 0) {owner = centralMinter;}
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }
","0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43/YSS.sol:YSS:YSS(uint256,string,string,uint8,address)","0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43/YSS.sol:YSS:_transfer(address,address,uint256)",0.0,4,4,0
"	function	setData_16	(	string	newData_16	)	public	onlyOwner	{	
		inData_16	=	newData_16	;					
	}									
","	function	getData_11	()	public	constant	returns	(	string	)	{
		return	inData_11	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_16(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_11(),1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function toUINT120(uint256 a) internal pure returns(uint120) {
    assert(uint120(a) == a);
    return uint120(a);
  }
","0x2aa215697a6f2a87a200fb8a34b24de69d9debcb/TimeBankChain.sol:SafeMath:mul(uint256,uint256)",0x2aa215697a6f2a87a200fb8a34b24de69d9debcb/TimeBankChain.sol:SafeMath:toUINT120(uint256),0.003934426229508197,4,4,0
"  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x5e046ccca2b0629f2eef9146cd091a5dcfed0a85/TRVLToken.sol:StandardToken:transferFrom(address,address,uint256)","0x5e046ccca2b0629f2eef9146cd091a5dcfed0a85/TRVLToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8431635388739946,4,4,0
"    function __callback(bytes32 myid, string result) public {
        __callback(myid, result, new bytes(0));
    }
","    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:__callback(bytes32,string)",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),1.0,5,5,1
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
",0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:onlyOwner(),"0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:adminClaimAirdropMultiple(address[],uint256)",0.00948316737790422,4,4,0
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x4d650c012bcc985648806b22e4acd5966058eb9d/TAKE.sol:TAKE:approveAndCall(address,uint256,bytes)","0x4d650c012bcc985648806b22e4acd5966058eb9d/TAKE.sol:TAKE:transferFrom(address,address,uint256)",0.7744107744107744,4,4,0
"  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
","  function withdrawTokens() public onlyOwner {
    uint256 unsold = token.balanceOf(this);
    token.transfer(owner, unsold);
  }
",0x4fc6f746dd8d4bd24cb0b19b6a17c4845765d0c9/OODCrowdsale.sol:OODCrowdsale:_forwardFunds(),0x4fc6f746dd8d4bd24cb0b19b6a17c4845765d0c9/OODCrowdsale.sol:OODCrowdsale:withdrawTokens(),0.03571428571428571,4,4,0
"    function setWallet(address _to) onlyowner {
        walletOut = _to;
    }
","    function burn(uint256 _value) onlyowner returns (bool success)
    {
        if (balances[msg.sender] < _value) {
            return false;
        }
        totalSupply -= _value;
        balances[msg.sender] -= _value;
        return true;
    }
",0x5c0b958f75123557712380480b4c99eddd04958f/CryptoShowCoin.sol:CryptoShowCoin:setWallet(address),0x5c0b958f75123557712380480b4c99eddd04958f/CryptoShowCoin.sol:CryptoShowCoin:burn(uint256),0.0,4,4,0
"  function add(uint256 a, uint256 b) constant public returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function div(uint256 a, uint256 b) constant public returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x2ceac2f743d4b599b931e778481bc01819cffcd5/GreenCoin.sol:SafeMath:add(uint256,uint256)","0x2ceac2f743d4b599b931e778481bc01819cffcd5/GreenCoin.sol:SafeMath:div(uint256,uint256)",0.7325842696629213,4,4,0
"    function compare(slice self, slice other) internal returns (int) {
        uint shortest = self._len;
        if (other._len < self._len)
            shortest = other._len;

        var selfptr = self._ptr;
        var otherptr = other._ptr;
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                var diff = (a & mask) - (b & mask);
                if (diff != 0)
                    return int(diff);
            }
            selfptr += 32;
            otherptr += 32;
        }
        return int(self._len) - int(other._len);
    }
","    function join(slice self, slice[] parts) internal returns (string) {
        if (parts.length == 0)
            return """";

        uint length = self._len * (parts.length - 1);
        for(uint i = 0; i < parts.length; i++)
            length += parts[i]._len;

        var ret = new string(length);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        for(i = 0; i < parts.length; i++) {
            memcpy(retptr, parts[i]._ptr, parts[i]._len);
            retptr += parts[i]._len;
            if (i < parts.length - 1) {
                memcpy(retptr, self._ptr, self._len);
                retptr += self._len;
            }
        }

        return ret;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:compare(strings:slice,strings:slice)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:join(strings:slice,strings:slice[])",1.0,5,5,1
"    function transfer(address _to, uint256 _value) public returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        
        _transfer(msg.sender,_to,_value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        
        require(_value <= allowed[_from][msg.sender]);
        allowed[_from][msg.sender] -= _value;
        _transfer(_from,_to,_value);
        return true;
    }
","0x2c1bf16a6ab64c2d55d916ba928138e488d3785a/XRTToken.sol:StandardToken:transfer(address,uint256)","0x2c1bf16a6ab64c2d55d916ba928138e488d3785a/XRTToken.sol:StandardToken:transferFrom(address,address,uint256)",0.13333333333333333,4,4,0
"    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
","    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
",0x3c149493d0B69B42d8F70D4762052ADfA2f4457c/Archetypal.sol:Archetypal:transferOwnership(address),"0x3c149493d0B69B42d8F70D4762052ADfA2f4457c/Archetypal.sol:Archetypal:doAirdrop(address,uint256)",0.05301204819277108,4,4,0
"    function mint(address dst,uint128 wad) auth stoppable {
        _balances[dst] = add(_balances[dst], wad);
        _supply = add(_supply, wad);
    }
","    function transferFrom(address src, address dst, uint wad)stoppable returns (bool) {
        assert(_balances[src] >= wad);
        assert(_approvals[src][msg.sender] >= wad);

        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);
        _balances[src] = sub(_balances[src], wad);
        _balances[dst] = add(_balances[dst], wad);

        Transfer(src, dst, wad);

        return true;
    }
","0x0f1ed66c251bcb52ecf7e67ac64bb72482048adb/SEER.sol:SEER:mint(address,uint128)","0x0f1ed66c251bcb52ecf7e67ac64bb72482048adb/SEER.sol:SEER:transferFrom(address,address,uint256)",1.0,5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x1a8ad0f390d933038a9daa21c906ccd63420b3e4/Studx.sol:Studx:burn(uint256),"0x1a8ad0f390d933038a9daa21c906ccd63420b3e4/Studx.sol:Studx:approveAndCall(address,uint256,bytes)",0.8849765258215962,4,4,0
"		function	retrait_3				()	public	{		
			require(	msg.sender == User_3			);				
			require(	Securities_3.transfer(User_3, Standard_3)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		function	retrait_5				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_5.transfer(User_5, Standard_5)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:retrait_3(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:retrait_5(),1.0,5,5,1
"    function create(uint _amount) public onlyOwner {
        balances[msg.sender] = safeAdd(balances[msg.sender], _amount);
        totalSupply = safeAdd(totalSupply, _amount);
    }
","    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
",0x5f5d0767fb8ba2c2793bf7957993a63b5e67d92b/CryptoBotsIdleToken.sol:CryptoBotsIdleToken:create(uint256),0x5f5d0767fb8ba2c2793bf7957993a63b5e67d92b/CryptoBotsIdleToken.sol:CryptoBotsIdleToken:balanceOf(address),1.0,5,5,1
"    function disableTransfers(bool _disable) public ownerOnly {
        transfersEnabled = !_disable;
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {
        assert(super.transfer(_to, _value));
        return true;
    }
",0x1bce0e684a1607fd86407909073eea2336042bf7/SmartToken.sol:SmartToken:disableTransfers(bool),"0x1bce0e684a1607fd86407909073eea2336042bf7/SmartToken.sol:SmartToken:transfer(address,uint256)",0.5714285714285714,4,4,0
"    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[2])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",1.0,5,5,1
"    function getProofOfStakeReward(address _address) internal returns (uint) {
        require( (now >= stakeStartTime) && (stakeStartTime > 0) );

        uint _now = now;
        uint _coinAge = getCoinAge(_address, _now);
        if(_coinAge <= 0) return 0;

        uint interest = maxMintProofOfStake;
        // Due to the high interest rate for the first two years, compounding should be taken into account.
        // Effective annual interest rate = (1 + (nominal rate / number of compounding periods)) ^ (number of compounding periods) - 1
        //Scarcecoin - Modified initial interest rate to 100%
        if((_now.sub(stakeStartTime)).div(1 years) == 0) {
            // 1st year effective annual interest rate is 100% when we select the stakeMaxAge (90 days) as the compounding period.
            interest = (770 * maxMintProofOfStake).div(100);
        } else if((_now.sub(stakeStartTime)).div(1 years) == 1) {
            // 2nd year effective annual interest rate is 50% when we select the stakeMaxAge (90 days) as the compounding period.
            interest = (435 * maxMintProofOfStake).div(100);
        }

        return (_coinAge * interest).div(365 * (10**decimals));
    }
","    function coinAge(address who) constant returns (uint myCoinAge) {
        myCoinAge = getCoinAge(who,now);
    }
",0x0df600c873da796c3ef6d6a0472772eb954d6986/ScarceCoinToken.sol:ScarceCoinToken:getProofOfStakeReward(address),0x0df600c873da796c3ef6d6a0472772eb954d6986/ScarceCoinToken.sol:ScarceCoinToken:coinAge(address),0.0,4,4,0
"		function	retrait_1				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_1.transfer(User_1, Standard_1)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		function	setID	(	uint256	newID	)	public	onlyOwner	{	
			ID	=	newID	;					
		}									
",0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:retrait_1(),0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:setID(uint256),1.0,5,5,1
"  modifier whenNotPaused() {
    require(!paused);
    _;
  }
","  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
",0x1e61529215ebeeb967f6d799058382cdddb148b1/KRWT.sol:Pausable:whenNotPaused(),0x1e61529215ebeeb967f6d799058382cdddb148b1/KRWT.sol:Pausable:unpause(),0.3848797250859107,4,4,0
"	function	setPOOL_edit_20	(	string	newPOOL_edit_20	)	public	onlyOwner	{	
		inPOOL_edit_20	=	newPOOL_edit_20	;					
	}									
","	function	setPOOL_edit_7	(	string	newPOOL_edit_7	)	public	onlyOwner	{	
		inPOOL_edit_7	=	newPOOL_edit_7	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_20(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_7(string),1.0,5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function iWAMToken() public {
        symbol = ""iWAM"";
        name = ""WAMAN"";
        decimals = 18;
        _totalSupply = 400000000 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
",0x8b9d3f0b91ffb9b5323422ea9217abcfb2d604fd/iWAMToken.sol:iWAMToken:totalSupply(),0x8b9d3f0b91ffb9b5323422ea9217abcfb2d604fd/iWAMToken.sol:iWAMToken:iWAMToken(),0.0948905109489051,4,4,0
"    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false 
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender] 
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
",0x8b3d0703b30a6c2eb8b88a479648391186e4cc8f/FIGHTMONEY.sol:FIGHTMONEY:totalSupply(),"0x8b3d0703b30a6c2eb8b88a479648391186e4cc8f/FIGHTMONEY.sol:FIGHTMONEY:transfer(address,uint256,bytes,string)",0.19101123595505612,4,4,0
"  function setWidthrawFor(string _paySystem,uint256 _stat, uint256 _perc) public onlyOwner returns (uint256) {
    widthrawPaySystemInfo[_paySystem].stat = _stat;
    widthrawPaySystemInfo[_paySystem].perc = _perc;

    WidthrawCommisionIsChanged(_paySystem, _stat, _perc);
  }
","  function setRefillFor(string _paySystem, uint256 _stat, uint256 _perc) public onlyOwner returns (uint256) {
    refillPaySystemInfo[_paySystem].stat = _stat;
    refillPaySystemInfo[_paySystem].perc = _perc;

    RefillCommisionIsChanged(_paySystem, _stat, _perc);
  }
","0x8aa3aeb44af42d4ff0f68066cace6658a076dee8/EvaCurrency.sol:ComissionList:setWidthrawFor(string,uint256,uint256)","0x8aa3aeb44af42d4ff0f68066cace6658a076dee8/EvaCurrency.sol:ComissionList:setRefillFor(string,uint256,uint256)",1.0,5,5,1
"    function setProofType(byte _proofType)
    external
    {
        addr_proofType[msg.sender] = _proofType;
    }
","    function Oraclize() {
        owner = msg.sender;
    }
",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:setProofType(bytes1),0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:Oraclize(),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    modifier coupon(string code){
        oraclize = OraclizeI(OAR.getAddress());
        oraclize.useCoupon(code);
        _;
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[3],uint256)",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:coupon(string),0.6,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function openSale() public onlyOwner {
        saleClosed = false;
    }
","0x0Ff758756e8f594fF463c9e7A41802e9Ef717265/OysterPrePearl.sol:OysterPrePearl:transferFrom(address,address,uint256)",0x0Ff758756e8f594fF463c9e7A41802e9Ef717265/OysterPrePearl.sol:OysterPrePearl:openSale(),0.002320185614849188,4,4,0
"	modifier when_has_allowance(address _owner, address _spender, uint _amount) {
		require (accounts[_owner].allowanceOf[_spender] >= _amount);
		_;
	}
","	function allowance(address _owner, address _spender)
		constant
		returns (uint256)
	{
		return accounts[_owner].allowanceOf[_spender];
	}
","0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:when_has_allowance(address,address,uint256)","0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:allowance(address,address)",1.0,5,5,1
"    function buy() payable public {
        uint amount = msg.value * buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }
","    function mintToken(address target, uint256 mintedAmount) onlyCrowdsaleAgent public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
",0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:buy(),"0x04a4b43352a78294bc7b6d520450825ac639ea21/RajTestICO.sol:RajTest:mintToken(address,uint256)",0.8676470588235294,4,4,0
"    function totalSupply() public constant returns (uint256 totalSup) {
        return _totalSupply;
    }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaing) {
        return allowed[_owner][_spender];
    }
",0x2AeD2725378013f66a2462D7C6B0F365494Cdc0c/WXC.sol:WXC:totalSupply(),"0x2AeD2725378013f66a2462D7C6B0F365494Cdc0c/WXC.sol:WXC:allowance(address,address)",0.5555555555555556,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function indexOf(string _haystack, string _needle) internal returns (int) {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:indexOf(string,string)",0.8,4,4,0
"  function tokensOf(address _owner) public view returns (uint256[]) {
    return ownedTokens[_owner];
  }
","  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    clearApprovalAndTransfer(msg.sender, _to, _tokenId);
  }
",0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:tokensOf(address),"0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:transfer(address,uint256)",0.75,4,4,0
"  function allowance(address _owner, address _spender) public constant returns (uint256) {
    return allowed[_owner][_spender];
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x1fe70be734e473e5721ea57c8b5b01e6caa52686/RNTBToken.sol:StandardToken:allowance(address,address)","0x1fe70be734e473e5721ea57c8b5b01e6caa52686/RNTBToken.sol:StandardToken:transferFrom(address,address,uint256)",0.3171945701357466,4,4,0
"  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x4dbabd055d978bb65911fc557141bea14a86aa14/IsToken.sol:SafeMath:safeSub(uint256,uint256)","0x4dbabd055d978bb65911fc557141bea14a86aa14/IsToken.sol:SafeMath:safeMul(uint256,uint256)",0.9572649572649572,5,5,1
"    function burnFrom(address _from, uint256 _value) returns (bool success) {
        require (balanceOf[_from] >= _value) ;                // Check if the sender has enough
        require (_value <= allowance[_from][msg.sender]) ;    // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        totalSupply -= _value;                               // Updates totalSupply
        Burn(_from, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require (_to != 0x0) ;                                // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value) ;                 // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]) ;  // Check for overflows
        require (_value <= allowance[_from][msg.sender]) ;     // Check allowance
        balanceOf[_from] -= _value;                           // Subtract from the sender
        balanceOf[_to] += _value;                             // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","0x6d16d82136e4979768fdf1bf617ea5298a131625/MyToken.sol:MyToken:burnFrom(address,uint256)","0x6d16d82136e4979768fdf1bf617ea5298a131625/MyToken.sol:MyToken:transferFrom(address,address,uint256)",0.8125,4,4,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0 || b == 0){
        return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x0ae68d667ace51eec78b2d8ffb707fb44bece69d/HeliosToken.sol:SafeMath:sub(uint256,uint256)","0x0ae68d667ace51eec78b2d8ffb707fb44bece69d/HeliosToken.sol:SafeMath:mul(uint256,uint256)",0.00170261066969353,4,4,0
"    constructor() public {
        symbol = ""NKM""; 
        name = ""Nakama"";
        decimals = 18;
        _totalSupply = 10422698937 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
","    function setName(string _name) public onlyOwner {
        name = _name;
    }
",0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:constructor(),0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:setName(string),0.0,4,4,0
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  function Ownable() public {
    owner = msg.sender;
  }
",0x4bc263822e6bb16f96c44ebac73a5d9a6a3b2831/TokenVesting.sol:Ownable:transferOwnership(address),0x4bc263822e6bb16f96c44ebac73a5d9a6a3b2831/TokenVesting.sol:Ownable:Ownable(),0.8385481852315394,5,5,1
"  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    // Removed because recovering crowdsale
    // require(_startTime >= now); 
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }
","  function hasEnded() public view returns (bool) {
    return now > endTime;
  }
","0x2aa0a30006fdf8cf273ddf7a80c56eb3646f28b7/LSDCrowdsale.sol:Crowdsale:Crowdsale(uint256,uint256,uint256,address)",0x2aa0a30006fdf8cf273ddf7a80c56eb3646f28b7/LSDCrowdsale.sol:Crowdsale:hasEnded(),1.0,5,5,1
"    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
","    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
",0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:transferOwnership(address),"0x1f36c5611a402876b75dd3a6595c6ee4718f794c/CyberClassicToken.sol:CyberClassicToken:adminClaimAirdrop(address,uint256)",0.04819277108433735,4,4,0
"	function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply
        Freeze(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }
",0x5abfb7ba5d54a21d8b89d1d372f557756f3c6078/EasyPocketCoin.sol:EasyPocketCoin:freeze(uint256),"0x5abfb7ba5d54a21d8b89d1d372f557756f3c6078/EasyPocketCoin.sol:EasyPocketCoin:transferFrom(address,address,uint256)",0.8888888888888888,4,4,0
"    function ownerSetStakeStartTime(uint timestamp) public onlyOwner {
        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));
        stakeStartTime = timestamp;
    }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
",0x7d446f1eb4aaeb2bad37ca372db49a7667ddc2fb/ZIC_Token.sol:ZIC_Token:ownerSetStakeStartTime(uint256),"0x7d446f1eb4aaeb2bad37ca372db49a7667ddc2fb/ZIC_Token.sol:ZIC_Token:allowance(address,address)",1.0,5,5,1
"    function wedding() public {
        symbol = ""wedding"";
        name = ""wedding"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xE15902055f380BbB907705054800c3f5Bf2Cf72B] = _totalSupply;
        Transfer(address(0),0xE15902055f380BbB907705054800c3f5Bf2Cf72B , _totalSupply);
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x1f0d98ea3f51e20aa60d9d1f600c1142d4c21b8e/wedding.sol:wedding:wedding(),"0x1f0d98ea3f51e20aa60d9d1f600c1142d4c21b8e/wedding.sol:wedding:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[1])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[2],uint256)",1.0,5,5,1
"  function NPERToken() public {
    name = ""NPER"";
    symbol = ""NPER"";
    decimals = 18;
    initialSupply = 250000000;
    totalSupply_ = initialSupply * 10 ** uint(decimals);
    balances[owner] = totalSupply_;
    Transfer(address(0), owner, totalSupply_);
  }
","  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(locks[_from] == false);
    
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
",0x4ce6b362bc77a24966dda9078f9cef81b3b886a7/NPERToken.sol:NPERToken:NPERToken(),"0x4ce6b362bc77a24966dda9078f9cef81b3b886a7/NPERToken.sol:NPERToken:transferFrom(address,address,uint256)",1.0,5,5,1
"  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x6ea89484b983a40b1571914561a41c34c075e3af/GoldBoxToken.sol:StandardToken:increaseApproval(address,uint256)","0x6ea89484b983a40b1571914561a41c34c075e3af/GoldBoxToken.sol:StandardToken:transferFrom(address,address,uint256)",0.7626076260762608,4,4,0
"    function setBeneficiary(address newBeneficiary)
    external
    only(owner) {
        beneficiary = newBeneficiary;
    }
","    modifier isNotStartedOnly() {
        if (isStarted) throw;
        _;
    }
",0x7c5a0ce9267ed19b22f8cae653f198e3e8daf098/SAN.sol:SAN:setBeneficiary(address),0x7c5a0ce9267ed19b22f8cae653f198e3e8daf098/SAN.sol:SAN:isNotStartedOnly(),1.0,5,5,1
"    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {
        uint256 z = _x + _y;
        assert(z >= _x);
        return z;
    }
","    modifier validAddress(address _address) {
        require(_address != 0x0);
        _;
    }
","0x5bb5b32cb114c7f558a3f5b0933dcfa74be9611a/KickcityCrowdsale.sol:Utils:safeAdd(uint256,uint256)",0x5bb5b32cb114c7f558a3f5b0933dcfa74be9611a/KickcityCrowdsale.sol:Utils:validAddress(address),0.0743801652892562,4,4,0
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x5fB7340DA1FF2760bCc78C59b4f3691D5D67Dde1/PrettyGirl.sol:PrettyGirl:burn(uint256),"0x5fB7340DA1FF2760bCc78C59b4f3691D5D67Dde1/PrettyGirl.sol:PrettyGirl:transferFrom(address,address,uint256)",0.8826291079812206,4,4,0
"    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[5],uint256)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:uint2str(uint256),0.8,4,4,0
"  function setAdvisorsTokensWallet(address newAdvisorsTokensWallet) public onlyOwner {
    advisorsTokensWallet = newAdvisorsTokensWallet;
  }
","  function setToken(address newToken) public onlyOwner {
    token = KITToken(newToken);
  }
",0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:CommonCrowdsale:setAdvisorsTokensWallet(address),0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:CommonCrowdsale:setToken(address),0.0,4,4,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
",0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:onlyOwner(),"0x7b2dF125567815ac9b57DA04B620F50bc93B320C/Archetypal.sol:Archetypal:transfer(address,uint256)",0.02987197724039829,4,4,0
"    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;
        
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);
        
        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);
        
        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = 1; //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);
        
        if (sigok == false) return false;
        
        
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";
        
        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);
        
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);
        
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);
        
        return sigok;
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)",0.8,4,4,0
"  function approve (address _spender, uint256 _value)
    returns (bool success) {
	require(allowance (msg.sender, _spender) == 0 || _value == 0);
    return AbstractToken.approve (_spender, _value);
  }
","  function transfer(address _to, uint256 _value) returns (bool success) {
    require(!frozenAccount[msg.sender]);
	if (frozen) return false;
    else return AbstractToken.transfer (_to, _value);
  }
","0x0b5a15b95b023317651cd1e09e5b23f31170a761/MTYToken.sol:MTYToken:approve(address,uint256)","0x0b5a15b95b023317651cd1e09e5b23f31170a761/MTYToken.sol:MTYToken:transfer(address,uint256)",1.0,5,5,1
"    function distributeDividends() onlyOwner public noEth(){
        for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
        {
            var (key, value) = IterableMapping.iterate_get(data, i);
            uint tmp = balances[dividendAddress] / globalShares * value;
            balances[key] = balances[key].add(tmp);
            Dividends(dividendAddress, key, tmp);
        }
        balances[dividendAddress] = balances[dividendAddress].sub(balances[dividendAddress] / globalShares * globalShares);
    }
","    modifier noEth() {
        if (msg.value < 0) {
            throw;
        }
        _;
    }
",0x4E4019c632579fB81E8c26503140aa2C9b55c065/GlobalCoin.sol:GlobalCoin:distributeDividends(),0x4E4019c632579fB81E8c26503140aa2C9b55c065/GlobalCoin.sol:GlobalCoin:noEth(),1.0,5,5,1
"    function DrugDealer() public{
        ceoAddress=msg.sender;
    }
","    function seedMarket(uint256 drugs) public payable{
        require(marketDrugs==0);
        initialized=true;
        marketDrugs=drugs;
    }
",0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:DrugDealer(),0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:seedMarket(uint256),0.0,4,4,0
"	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}
","	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}
",0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpOwnershipStorage:decrementOwnedTokensLength(address),0x3aa343d578050e333676b560f6465fa181c02edf/BdpOwnershipStorage.sol:BdpOwnershipStorage:getTokenIdByIndex(uint256),1.0,5,5,1
"    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }
","    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:Academicon:distributeAmounts(address[],uint256[])",0x7d2624470429a4fa48f09206238749fbbb45eaa8/Academicon.sol:Academicon:withdrawForeignTokens(address),1.0,5,5,1
"    function transferPauseOperator(address newPauseOperator) onlyPauseOperator public {
        require(newPauseOperator != address(0));
        emit PauseOperatorTransferred(pauseOperator, newPauseOperator);
        pauseOperator = newPauseOperator;
    }
","    modifier whenPaused() {
        require(paused);
        _;
    }
",0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:transferPauseOperator(address),0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:whenPaused(),1.0,5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
",0x6a95771d66731e1f59681b9f71f45dc2d248790c/KruhftsToken.sol:KruhftsToken:totalSupply(),"0x6a95771d66731e1f59681b9f71f45dc2d248790c/KruhftsToken.sol:KruhftsToken:transferFrom(address,address,uint256)",0.8175182481751825,4,4,0
"    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x6d8c10b650da8b789f898bb7ddc65d2227a0785b/BitKao.sol:Owned:transferOwnership(address),0x6d8c10b650da8b789f898bb7ddc65d2227a0785b/BitKao.sol:Owned:onlyOwner(),0.8634920634920635,4,4,0
"    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[1])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",1.0,5,5,1
"    function Owned() public {
        owner = msg.sender;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x3f21b20a9ee87c5e6945117ee37ef83b195ebd7b/Owned.sol:Owned:Owned(),0x3f21b20a9ee87c5e6945117ee37ef83b195ebd7b/Owned.sol:Owned:transferOwnership(address),0.7699530516431925,4,4,0
"    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
","    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
",0x2c78ac7859423ab8d3efc4ae1f1fc842573830ff/INT.sol:INTToken:buy(),0x2c78ac7859423ab8d3efc4ae1f1fc842573830ff/INT.sol:INTToken:sell(uint256),0.875,5,5,1
"  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x6f430927861d828bd625754a03d17a65eef5eb7e/DropletCrowdSale.sol:StandardToken:allowance(address,address)","0x6f430927861d828bd625754a03d17a65eef5eb7e/DropletCrowdSale.sol:StandardToken:approve(address,uint256)",0.7343891402714933,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
","    function IstriumToken(address _addressFounder) public {
        owner = msg.sender;
        totalSupply = valueFounder;
        balanceOf[_addressFounder] = valueFounder;
       emit Transfer(0x0, _addressFounder, valueFounder);
    }
","0x08c3b0b55908ee37253ffcfd55bb957aa870bcfd/IstriumICO.sol:IstriumICO:transferFrom(address,address,uint256)",0x08c3b0b55908ee37253ffcfd55bb957aa870bcfd/IstriumICO.sol:IstriumICO:IstriumToken(address),0.009615384615384616,4,4,0
"    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(tokens <= balances[from]);
        require(tokens <= allowed[from][msg.sender]);
        require(to != address(0));

        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        emit Transfer(from, to, tokens);
        return true;

    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x4e9f54163bb5dbd62d94bfdf10347c7313d74805/VET.sol:VET:transferFrom(address,address,uint256)","0x4e9f54163bb5dbd62d94bfdf10347c7313d74805/VET.sol:VET:transferAnyERC20Token(address,uint256)",0.08,4,4,0
"    function changeAdmin(address _newAdmin)
    external
    {
        onlyadmin();
        owner = _newAdmin;
    }
","    function query2(string _datasource, string _arg1, string _arg2)
    payable
    external
    returns (bytes32 _id)
    {
        return query2(0, _datasource, _arg1, _arg2, 200000);
    }
",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:changeAdmin(address),"0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:query2(string,string,string)",1.0,5,5,1
"    function setApprovalForAll(address _to, bool _approved) public {
        require(_to != msg.sender);
        operatorApprovals[msg.sender][_to] = _approved;
        emit ApprovalForAll(msg.sender, _to, _approved);
    }
","    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0));
        return ownedTokensCount[_owner];
    }
","0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:setApprovalForAll(address,bool)",0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:balanceOf(address),1.0,5,5,1
"    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
","0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:adminClaimAirdropMultiple(address[],uint256)",0x6e463d927a43da787157afed4427d8d3df1a1cfb/TokenOfEightSilver.sol:TokenOfEightSilver:updateTokensPerEth(uint256),1.0,5,5,1
"    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x1b69cd0f0ef8f13e13e32328dc1db9e1128ea358/Evernal.sol:SafeMath:max64(uint64,uint64)","0x1b69cd0f0ef8f13e13e32328dc1db9e1128ea358/Evernal.sol:SafeMath:sub(uint256,uint256)",0.2297297297297297,4,4,0
"    function withdrawEther(uint amount) external onlyOwner {
        withdrawAddress1.transfer(amount / 2);
        withdrawAddress2.transfer(amount / 2);
    }
","    function makePurchase(address beneficiary, uint amount) private {
        require(beneficiary != 0x0);
        require(isActive());
        uint minimumTokens = 20000;
        if(tokensSold < hardCap.sub(minimumTokens)) {
            require(amount >= minimumTokens);
        }
        require(amount.add(tokensSold) <= hardCap);
        tokensSold = tokensSold.add(amount);
        token.mint(beneficiary, amount);
    }
",0x3cb7a642b1966c94c425c0a903f4c0e033e9b7e9/TempusPreIco.sol:TempusPreIco:withdrawEther(uint256),"0x3cb7a642b1966c94c425c0a903f4c0e033e9b7e9/TempusPreIco.sol:TempusPreIco:makePurchase(address,uint256)",1.0,5,5,1
"    modifier onlyNewOwner() {
        require(msg.sender != address(0));
        require(msg.sender == newOwner);
        _;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }
",0x1a66e09f7dccc10eae46e27cfa6b8d44a50df1e7/PRASMToken.sol:Ownable:onlyNewOwner(),0x1a66e09f7dccc10eae46e27cfa6b8d44a50df1e7/PRASMToken.sol:Ownable:transferOwnership(address),1.0,5,5,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","0x2f66909464471af55e63f13e6ca0a49db1cfca3c/DatePlus.sol:SafeMath:div(uint256,uint256)","0x2f66909464471af55e63f13e6ca0a49db1cfca3c/DatePlus.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,5,5,1
"    function approve(address _spender, uint256 _value) {

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }
","    function transferFrom(address _from, address _to, uint256 _value) {
        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // if (_value > _allowance) throw;

        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
    }
","0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:ERC23StandardToken:approve(address,uint256)","0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:ERC23StandardToken:transferFrom(address,address,uint256)",0.8059701492537313,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x0b7093536abf6943278a310cfe87ee15cecbf337/EncryptedToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)","0x0b7093536abf6943278a310cfe87ee15cecbf337/EncryptedToken.sol:TokenERC20:transferFrom(address,address,uint256)",0.7345309381237525,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strConcat(string,string,string,string,string)",0.8,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function VenusToken (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x1e4e36b3f011d862fd70006804da8fcefe89d3d8/VenusToken.sol:VenusToken:approveAndCall(address,uint256,bytes)","0x1e4e36b3f011d862fd70006804da8fcefe89d3d8/VenusToken.sol:VenusToken:VenusToken(uint256,string,string)",0.4251497005988024,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    modifier coupon(string code){
        oraclize = OraclizeI(OAR.getAddress());
        oraclize.useCoupon(code);
        _;
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[5])",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:coupon(string),0.6,2,2,0
"		function balanceOf(address _owner) constant returns (uint balance) {									
			return balances[_owner];								
		}									
","		function	setData_4	(	string	newData_4	)	public	onlyOwner	{	
			inData_4	=	newData_4	;					
		}									
",0x3c32120b3c1ec08820c1ede5efd6d62f0177fc57/PLAY_A3.sol:PLAY_A3:balanceOf(address),0x3c32120b3c1ec08820c1ede5efd6d62f0177fc57/PLAY_A3.sol:PLAY_A3:setData_4(string),0.0010121457489878543,2,2,0
"    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[1],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)",1.0,5,5,1
"	function	getData_18	()	public	constant	returns	(	string	)	{
		return	inData_18	;						
	}									
","	function	setData_4	(	string	newData_4	)	public	onlyOwner	{	
		inData_4	=	newData_4	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_18(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_4(string),1.0,5,5,1
"    function getApplicationState() public view returns (uint8) {
        return ApplicationEntityABI(owner).CurrentEntityState();
    }
","    function setAssetStates() internal {
        // Asset States
        EntityStates[""__IGNORED__""]     = 0;
        EntityStates[""NEW""]             = 1;
        // Funding Stage States
        RecordStates[""__IGNORED__""]     = 0;
    }
",0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:getApplicationState(),0x5f03b7561e62efdab8b2fb740d83630d4d2710d7/ListingContract.sol:ApplicationAsset:setAssetStates(),1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));



    uint256 _allowance = allowed[_from][msg.sender];



    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met

    // require (_value <= _allowance);



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = _allowance.sub(_value);

    Transfer(_from, _to, _value);

    return true;

  }
","  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }
","0x0f42d209fc46f678e8d31717d7ce14c69724a60e/SAATCoin.sol:StandardToken:transferFrom(address,address,uint256)","0x0f42d209fc46f678e8d31717d7ce14c69724a60e/SAATCoin.sol:StandardToken:approve(address,uint256)",0.33791208791208793,2,2,0
"  function batchTransfer(address[] _receivers, uint256 _value) public  whenNotPaused returns (bool) {

      // cnt = 2
      uint cnt = _receivers.length;
      // the limit of uint before it overflows is 2**256-1
      // which is 1.15792089237316195423570985008E+77
      // so the value passed in is 5.78960446186580977117854925043E+76
      // multipled by cnt(2), the amount is now overflowed, ie = 0.
      uint256 amount = uint256(cnt).mul(_value);

      // cnt fulfils this condition
      require(cnt > 0 && cnt <= 100);
      // _value is > 0 and balances[msg.sender] always >= 0
      require(_value > 0 && balances[msg.sender] >= amount);
      // sender's acct not affected after it was subtracted by 0
      balances[msg.sender] = balances[msg.sender].sub(amount);
      // for loop is limited to 20. there will always be enough gas.
      for (uint i = 0; i < cnt; i++) {
          // both receiver address gets lots of free money here!
          balances[_receivers[i]] = balances[_receivers[i]].add(_value);
          emit Transfer(msg.sender, _receivers[i], _value);
      }
      return true;
    }
","  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","0x3bd82e49a5013dddde9ae96b22fdb83cc6e27fdf/KaiGameCoin.sol:PausableToken:batchTransfer(address[],uint256)","0x3bd82e49a5013dddde9ae96b22fdb83cc6e27fdf/KaiGameCoin.sol:PausableToken:decreaseApproval(address,uint256)",0.0,4,4,0
"    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }
","    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
","0x5f2539a5dc504493ba9ae1207803c08634cbb091/SCH.sol:SCH:distributeAmounts(address[],uint256[])",0x5f2539a5dc504493ba9ae1207803c08634cbb091/SCH.sol:SCH:onlyPayloadSize(uint256),1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x2b789d8b08608302b108f8cb466e8b49db8525a3/NEOO.sol:StandardToken:transfer(address,uint256)","0x2b789d8b08608302b108f8cb466e8b49db8525a3/NEOO.sol:StandardToken:allowance(address,address)",0.9776632302405498,5,5,1
"    function balanceOf(address _owner) constant returns (uint256) {
      return balances[_owner];
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
      require(0x0!=_to);

      balances[_to] = safeAdd(balances[_to],_value);
      balances[_from] = safeSub(balances[_from],_value);
      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);

      Transfer(_from, _to, _value);
      return true;
    }
",0x2fe7408cef927cc48878bb05fd23879a9427cd0b/GoldFee.sol:StdToken:balanceOf(address),"0x2fe7408cef927cc48878bb05fd23879a9427cd0b/GoldFee.sol:StdToken:transferFrom(address,address,uint256)",0.002564102564102564,2,2,0
"	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}
","	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) > 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}
","0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpCalculator:calculateArea(address[16],uint256)","0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpCalculator:calculateRegionInitialSalePixelPrice(address[16],uint256)",1.0,5,5,1
"    modifier isActive {
        require(!isMaintaining);
        _;
    }
","    function BasicAccessControl() public {
        owner = msg.sender;
    }
",0x6c8dce6d842e0d9d109dc4c69f35cf8904fc4cbf/EtheremonEnergy.sol:BasicAccessControl:isActive(),0x6c8dce6d842e0d9d109dc4c69f35cf8904fc4cbf/EtheremonEnergy.sol:BasicAccessControl:BasicAccessControl(),0.0,2,2,0
"    function updatePartner1_vows(string _partner1_vows) public {
        require((msg.sender == owner || msg.sender == partner1_address) && (bytes(partner1_vows).length == 0));
        partner1_vows = _partner1_vows;
    }
","    function updateMarriageLicenceImageIPFShash(bytes _marriageLicenceImageIPFShash) public{
        require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address);
        marriageLicenceImageIPFShash = _marriageLicenceImageIPFShash;
    }
",0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:updatePartner1_vows(string),0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:updateMarriageLicenceImageIPFShash(bytes),1.0,5,5,1
"    function setStartBlock(uint256 _startBlock) onlyOwner public {
        startBlock = _startBlock;
    }
","    function hasEnded() public constant returns (bool) {
        return block.number >= endBlock;
    }
",0x5beeC0Cf71d30ED317979917896C677f3701A1c6/FaradTokenSwap.sol:FaradTokenSwap:setStartBlock(uint256),0x5beeC0Cf71d30ED317979917896C677f3701A1c6/FaradTokenSwap.sol:FaradTokenSwap:hasEnded(),0.6666666666666666,2,2,0
"    function parseAddr(string _a) internal pure returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:parseAddr(string),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[1])",1.0,5,5,1
"    modifier auth {
        assert (msg.sender==owner);
        _;
    }
","    function totalSupply() constant returns (uint256) {
        return _supply;
    }
",0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:auth(),0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:totalSupply(),1.0,5,5,1
"    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }
","    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x8afcc83ad2fa781e00efa95967f3cbb87c591af1/AICQ.sol:RegularToken:balanceOf(address),"0x8afcc83ad2fa781e00efa95967f3cbb87c591af1/AICQ.sol:RegularToken:transfer(address,uint256)",0.02325581395348837,2,2,0
"    function balanceOf(address _owner) constant returns (uint256 balance){
        return balanceOf[_owner];
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowance[_owner][_spender];
}
",0x7bdb9d2f09c49cadbc0a32296b37a78caaec0bb7/MithrilGauntlet.sol:MithrilGauntlet:balanceOf(address),"0x7bdb9d2f09c49cadbc0a32296b37a78caaec0bb7/MithrilGauntlet.sol:MithrilGauntlet:allowance(address,address)",0.7209302325581395,2,2,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x7fafdfe0413f47cfac4a5f3a0ed8bf4f32a1b3e4/VODToken.sol:SafeMath:add(uint256,uint256)","0x7fafdfe0413f47cfac4a5f3a0ed8bf4f32a1b3e4/VODToken.sol:SafeMath:div(uint256,uint256)",0.20450704225352112,2,2,0
"	function unfreeze(uint256 _value) public returns (bool success){
		require(freezeOf[msg.sender] >= _value); // Check if the sender has enough
		require(_value > 0);
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
		balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
",0x1b4217a81200b64ca205f12c64196b7897d75564/CoinhiToken.sol:CoinhiToken:unfreeze(uint256),"0x1b4217a81200b64ca205f12c64196b7897d75564/CoinhiToken.sol:CoinhiToken:_transfer(address,address,uint256)",0.0,2,2,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x0ade0c035b3b541db470db1b9e62f83adcd73694/Illuminati.sol:StandardToken:approve(address,uint256)","0x0ade0c035b3b541db470db1b9e62f83adcd73694/Illuminati.sol:StandardToken:transfer(address,uint256)",0.3043478260869565,2,2,0
"  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    address owner = ownerOf(_tokenId);
    require(_to != owner);
    if (approvedFor(_tokenId) != 0 || _to != 0) {
      tokenApprovals[_tokenId] = _to;
      Approval(owner, _to, _tokenId);
    }
  }
","  function totalSupply() public view returns (uint256) {
    return totalTokens;
  }
","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:approve(address,uint256)",0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:totalSupply(),1.0,5,5,1
"    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x3e7eb1d871e97bc43a7c632bc15d2a1e09e747f2/Blobs.sol:Blobs:constructor(uint256,string,string)","0x3e7eb1d871e97bc43a7c632bc15d2a1e09e747f2/Blobs.sol:Blobs:approveAndCall(address,uint256,bytes)",0.9461883408071748,5,5,1
"		function	getData_8	()	public	constant	returns	(	string	)	{
			return	inData_8	;						
		}									
","		function	setData_26	(	string	newData_26	)	public	onlyOwner	{	
			inData_26	=	newData_26	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_8(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_26(string),0.5,2,2,0
"    function _buy() internal returns (uint256 amount){
        require(buyOpen);
        require(buyPrice>0);
        require(msg.value>0);
        amount = msg.value / buyPrice;                    // calculates the amount
        _transfer(owner,msg.sender,amount);
        BuyToken(msg.sender,buyPrice,amount,msg.value);
        return amount;                                    // ends function and returns
    }
","    function setBuyOpen(bool newBuyOpen) onlyOwner public{
        require(buyPrice>0);
        buyOpen = newBuyOpen;
    }
",0x0a9A9ce600D08BF9b76F49FA4e7b38A67EBEB1E6/GrowToken.sol:GrowToken:_buy(),0x0a9A9ce600D08BF9b76F49FA4e7b38A67EBEB1E6/GrowToken.sol:GrowToken:setBuyOpen(bool),1.0,5,5,1
"    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowance[msg.sender][_spender] = SafeMath.add(allowance[msg.sender][_spender], _addedValue);
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    } 
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x1a8f615f0dd39b9de8ad26db89cfa76f7c9d0274/UTOToken.sol:UTOToken:increaseApproval(address,uint256)","0x1a8f615f0dd39b9de8ad26db89cfa76f7c9d0274/UTOToken.sol:UTOToken:approveAndCall(address,uint256,bytes)",0.019230769230769232,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x0f9b1d1d39118480cf8b9575419ea4e5189c88dd/wellieat.sol:wellieat:transfer(address,uint256)",0x0f9b1d1d39118480cf8b9575419ea4e5189c88dd/wellieat.sol:wellieat:burn(uint256),0.8060046189376443,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        }
        Transfer(_from, _to, _value);
        return true;
    }
","  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0d4be1e3a27aeae34d289d7fa47c612606d6420f/EVM.sol:EVM:transferFrom(address,address,uint256)","0x0d4be1e3a27aeae34d289d7fa47c612606d6420f/EVM.sol:EVM:increaseApproval(address,uint256)",0.7449494949494949,2,2,0
"  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x4a5c0f28d459cc0fb860f946fffabd8a36d4327c/XCNTToken.sol:StandardToken:increaseApproval(address,uint256)","0x4a5c0f28d459cc0fb860f946fffabd8a36d4327c/XCNTToken.sol:StandardToken:transferFrom(address,address,uint256)",0.7628992628992629,2,2,0
"  function upgradeCardShield(uint256 _cardId) public {
    require(cardShieldUpgradeLevel[_cardId].isLessThan(maxCardUpgradeLevel));
    uint256 costOfUpgrade = 32 * (cardShieldUpgradeLevel[_cardId] + 1);

    MythereumERC20Token mythexContract = MythereumERC20Token(mythexTokenAddress);
    require(mythexContract.balanceOf(msg.sender).isAtLeast(costOfUpgrade));
    burnMythexTokens(msg.sender, costOfUpgrade);

    cardShieldUpgradeLevel[_cardId]++;
    _improveCard(_cardId, 0, 1);
  }
","  function grantMythexTokens(address _recipient, uint256 _amount) public onlyHosts {
    require(_recipient != address(0));
    MythereumERC20Token(mythexTokenAddress).mint(_recipient, _amount);
  }
",0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd/Mythereum.sol:Mythereum:upgradeCardShield(uint256),"0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd/Mythereum.sol:Mythereum:grantMythexTokens(address,uint256)",1.0,5,5,1
"    function Nookoin(
        uint256 _initialAmount,         //1000000
        string _tokenName,              //Nookoin
        uint8 _decimalUnits,            //0
        string _tokenSymbol             //NKO
    ) public {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }
","    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
","0x7b4f2f69abf9d217dc82a24761508b7e35477f93/Nookoin.sol:Nookoin:Nookoin(uint256,string,uint8,string)","0x7b4f2f69abf9d217dc82a24761508b7e35477f93/Nookoin.sol:Nookoin:allowance(address,address)",0.3055555555555556,2,2,0
"    function autoDistribute() payable public {
        require(distributeAmount > 0
                && balanceOf[activityFunds] >= distributeAmount
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
        if(msg.value > 0) activityFunds.transfer(msg.value);
        
        balanceOf[activityFunds] = balanceOf[activityFunds].sub(distributeAmount);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(distributeAmount);
        Transfer(activityFunds, msg.sender, distributeAmount);
    }
","    function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length);

        uint256 totalAmount = 0;
        
        for (uint j = 0; j < addresses.length; j++) {
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            require(balanceOf[addresses[j]] >= amounts[j]);
            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);
            totalAmount = totalAmount.add(amounts[j]);
            Transfer(addresses[j], msg.sender, amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].add(totalAmount);
        return true;
    }
",0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:autoDistribute(),"0x02c41cde8a11fcf333277f2bc543eb2b0925809c/DHAMAR.sol:DHAMAR:collectTokens(address[],uint256[])",1.0,5,5,1
"    modifier ownerExists(address owner) {
        require(isOwner[owner]);
        _;
    }
","    modifier notExecuted(uint transactionId) {
        require(!transactions[transactionId].executed);
        _;
    }
",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:ownerExists(address),0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notExecuted(uint256),0.16666666666666666,2,2,0
"    modifier notConfirmed(uint transactionId, address owner) {
        require(!confirmations[transactionId][owner]);
        _;
    }
","    function isConfirmed(uint transactionId)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++) {
            if (confirmations[transactionId][owners[i]])
                count += 1;
            if (count == required)
                return true;
        }
    }
","0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notConfirmed(uint256,address)",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:isConfirmed(uint256),1.0,5,5,1
"	function finalise()
		only_owner
		public
	{
		locked = false;
		owner = 0;
		phaseStart = now;
	}
","	function unlockTokens(address _who)
		public
	{
		uint phase = currentPhase();
		uint tokens = accounts[_who].tokensPerPhase;
		uint nextPhase = accounts[_who].nextPhase;
		if (tokens > 0 && phase > nextPhase) {
			accounts[_who].balance += tokens * (phase - nextPhase);
			accounts[_who].nextPhase = phase;
		}
	}
",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:finalise(),0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:unlockTokens(address),1.0,5,5,1
"  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x1e886ce6d18bf524373a546300dfe97674f5c6d2/WubCoin.sol:SafeMath:max64(uint64,uint64)","0x1e886ce6d18bf524373a546300dfe97674f5c6d2/WubCoin.sol:SafeMath:mul(uint256,uint256)",0.6351351351351351,2,2,0
"    function contains(slice self, slice needle) internal returns (bool) {
        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;
    }
","    function nextRune(slice self) internal returns (slice ret) {
        nextRune(self, ret);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:contains(strings:slice,strings:slice)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:nextRune(strings:slice),1.0,5,5,1
"		function	setCmd	(	uint256	newCmd	)	public	onlyOwner	{	
			Cmd	=	newCmd	;					
		}									
","		function	retrait_4				()	public	{		
			require(	msg.sender == User_4			);				
			require(	Securities_4.transfer(User_4, Standard_4)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setCmd(uint256),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:retrait_4(),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) {
            revert();                                        // Check if the sender has enough
        }                 
        if (balanceOf[_to] + _value < balanceOf[_to]) {
            revert();  // Check for overflows
        }
        if (_value > allowance[_from][msg.sender]) {
            revert();   // Check allowance
        }

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    returns (bool success) 
    {    
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(
                msg.sender,
                _value,
                this,
                _extraData
            );
            return true;
        }
    }
","0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:Token:transferFrom(address,address,uint256)","0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:Token:approveAndCall(address,uint256,bytes)",0.5686274509803921,2,2,0
"  function activate_kill_switch() {
    // Only allow the developer to activate the kill switch.
    if (msg.sender != developer_address) throw;
    // Irreversibly activate the kill switch.
    kill_switch = true;
  }
","    function max64(uint64 a, uint64 b) internal constant returns (uint64) {
      return a >= b ? a : b;
    }
",0x6F7e6b48d610b903F28AAcAB271Bdad8B7612495/ZiberToken.sol:ZiberToken:activate_kill_switch(),"0x6F7e6b48d610b903F28AAcAB271Bdad8B7612495/ZiberToken.sol:ZiberToken:max64(uint64,uint64)",1.0,5,5,1
"    function add(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function div(uint256 a, uint256 b) internal pure returns(uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","0x5c7c8c2c5c90b8c3e9319ab1d9bebebd280841b7/HomeLoansToken.sol:SafeMath:add(uint256,uint256)","0x5c7c8c2c5c90b8c3e9319ab1d9bebebd280841b7/HomeLoansToken.sol:SafeMath:div(uint256,uint256)",0.7325842696629213,2,2,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
",0x0c92580d834945789196a473d499a4ae65c7a26a/TFTOKEN.sol:BasicToken:totalSupply(),0x0c92580d834945789196a473d499a4ae65c7a26a/TFTOKEN.sol:BasicToken:balanceOf(address),0.44639376218323584,2,2,0
"    function getReserveBalances() public view returns (uint256, uint256) {
        return (tokenContract.balanceOf(this), address(this).balance+virtualReserveBalance);
    }
","    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {
        virtualReserveBalance = amountInWei;
    }
",0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:getReserveBalances(),0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:setVirtualReserveBalance(uint256),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af/OysterPrePearl.sol:OysterPrePearl:transferFrom(address,address,uint256)","0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af/OysterPrePearl.sol:OysterPrePearl:_transfer(address,address,uint256)",0.8445475638051044,2,2,0
"    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
","    function _isContract(address _user) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_user) }
        return size > 0;
    }
","0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:isApprovedForAll(address,address)",0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:_isContract(address),0.0,2,2,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x01ec2fb34a6640acfb59861bbdf6aa65af18bd43/WatTestCoin4.sol:StandardToken:approve(address,uint256)","0x01ec2fb34a6640acfb59861bbdf6aa65af18bd43/WatTestCoin4.sol:StandardToken:transfer(address,uint256)",0.3043478260869565,2,2,0
"  function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {
    if (_price < increaseLimit1) {
      return _price.mul(5).div(100); // 5%
    } else if (_price < increaseLimit2) {
      return _price.mul(4).div(100); // 4%
    } else if (_price < increaseLimit3) {
      return _price.mul(3).div(100); // 3%
    } else if (_price < increaseLimit4) {
      return _price.mul(3).div(100); // 3%
    } else {
      return _price.mul(2).div(100); // 2%
    }
  }
","  function addAdmin (address _admin) onlyOwner() public {
    admins[_admin] = true;
  }
",0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:calculateDevCut(uint256),0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:addAdmin(address),0.0,2,2,0
"	function	setPOOL_edit_17	(	string	newPOOL_edit_17	)	public	onlyOwner	{	
		inPOOL_edit_17	=	newPOOL_edit_17	;					
	}									
","	function	setPOOL_edit_5	(	string	newPOOL_edit_5	)	public	onlyOwner	{	
		inPOOL_edit_5	=	newPOOL_edit_5	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_17(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_5(string),0.6666666666666666,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) revert();                        // Check if frozen            
        if (balanceOf[_from] < _value) revert();                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows
        if (_value > allowance[_from][msg.sender]) revert();   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","0x2a05d22db079bc40c2f77a1d1ff703a56e631cc1/BitAseanToken.sol:BitAseanToken:transferFrom(address,address,uint256)","0x2a05d22db079bc40c2f77a1d1ff703a56e631cc1/BitAseanToken.sol:BitAseanToken:mintToken(address,uint256)",0.102803738317757,2,2,0
"    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
",0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:balanceOf(address),"0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:transfer(address,uint256)",0.16153846153846155,2,2,0
"    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(transfers != 0);
        
        require( admins[msg.sender] == 1 || now > 1522799999 );
        
        require(_to != address(0));
        
        require(balances[msg.sender] >= _value);
        
        balances[msg.sender] -= _value;
        
        balances[_to] += _value;
        
        Transfer(msg.sender, _to, _value);
        
        return true;
    }
","    function EIP20() public {
        balances[msg.sender] = 5174000;
        totalSupply = 5174000;
        name = ""GoldStyxCoin"";
        decimals = 0;
        symbol = ""GSXC"";
        owner = msg.sender;
    }
","0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6/EIP20.sol:EIP20:transfer(address,uint256)",0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6/EIP20.sol:EIP20:EIP20(),0.0,2,2,0
"	function	getData_34	()	public	constant	returns	(	string	)	{
		return	inData_34	;						
	}									
","	function	getData_25	()	public	constant	returns	(	string	)	{
		return	inData_25	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_34(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_25(),1.0,5,5,1
"	function BdpControllerHelper(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}
","	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageDescriptor(_imageId);
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:BdpControllerHelper(bytes8),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageDescriptor(uint256),0.3333333333333333,2,2,0
"  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        revert();
    }
    _;
  }  
","  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }
",0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:ReleasableToken:inReleaseState(bool),"0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:ReleasableToken:transferFrom(address,address,uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function Distribute(address[] _addresses, uint256[] _values) payable returns(bool){
        for (uint i = 0; i < _addresses.length; i++) {
            transfer(_addresses[i], _values[i]);
        }
        return true;
    }
","0x7c833af22bd7da8ad29541c35230d1c822e23889/EthchangeToken.sol:EthchangeToken:transferFrom(address,address,uint256)","0x7c833af22bd7da8ad29541c35230d1c822e23889/EthchangeToken.sol:EthchangeToken:Distribute(address[],uint256[])",0.0196078431372549,2,2,0
"    modifier transfersAllowed {
        assert(transfersEnabled);
        _;
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {
        assert(super.transfer(_to, _value));

        // transferring to the contract address destroys tokens
        if (_to == address(this)) {
            balanceOf[_to] -= _value;
            totalSupply -= _value;
            Destruction(_value);
        }

        return true;
    }
",0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:transfersAllowed(),"0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:transfer(address,uint256)",0.25,2,2,0
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
",0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:totalSupply(),0x6ef88e1ce5b3ba4d1c4d90a66b2ad0105ce60148/LamaToken.sol:LamaToken:balanceOf(address),0.9963503649635036,5,5,1
"  function mint(address _to, uint _amount) onlyOwner canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }
","  function finishMinting() onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
","0x6a7868aee3e5dF94493d8F6aa57b6593e6866d69/OMGToken.sol:MintableToken:mint(address,uint256)",0x6a7868aee3e5dF94493d8F6aa57b6593e6866d69/OMGToken.sol:MintableToken:finishMinting(),0.8947368421052632,5,5,1
"    function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {
        require( _recipients.length > 0 && _recipients.length == _values.length);

        uint total = 0;
        for(uint i = 0; i < _values.length; i++){
            total = total.add(_values[i]);
        }
        require(total <= balances[msg.sender]);

        uint64 _now = uint64(now);
        for(uint j = 0; j < _recipients.length; j++){
            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);
            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));
            Transfer(msg.sender, _recipients[j], _values[j]);
        }

        balances[msg.sender] = balances[msg.sender].sub(total);
        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));

        return true;
    }
","    function ownerSetStakeStartTime(uint timestamp) onlyOwner {
        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));
        stakeStartTime = timestamp;
    }
","0x4a2c5a2c189fa9a9d69f7ae4265a4c83224fd15d/ICOBIDToken.sol:ICOBIDToken:batchTransfer(address[],uint256[])",0x4a2c5a2c189fa9a9d69f7ae4265a4c83224fd15d/ICOBIDToken.sol:ICOBIDToken:ownerSetStakeStartTime(uint256),0.9375,5,5,1
"  function balanceOf(address _owner) constant public returns (uint balance) {
    return balances[_owner].value;
  }
","  modifier addIfNotExist(address holder) {
    if(!balances[holder].exist)
      holders.push(holder);
    _;
  }
",0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:TokenAdrToken:balanceOf(address),0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:TokenAdrToken:addIfNotExist(address),1.0,5,5,1
"  function freezeAccount(address target, bool freeze) onlyOwner public {
    frozenAccount[target] = freeze;
    FrozenFunds(target, freeze);
  }
","  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }
","0x7e74ebfd6d2e1adca6dabe8775b450a1622ceccc/ELIX.sol:PausableToken:freezeAccount(address,bool)","0x7e74ebfd6d2e1adca6dabe8775b450a1622ceccc/ELIX.sol:PausableToken:transferFrom(address,address,uint256)",0.0049261083743842365,2,2,0
"  function allowance(address _owner, address _spender) public view returns (uint256){
    return allowed[_owner][_spender];
  }
","  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public returns (bool)
  {
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(_to != address(0));

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","0x1c56935e7dd6fabffd02d6d13cb10124cd90abaf/POBTokenERC20.sol:StandardToken:allowance(address,address)","0x1c56935e7dd6fabffd02d6d13cb10124cd90abaf/POBTokenERC20.sol:StandardToken:transferFrom(address,address,uint256)",0.3221719457013575,2,2,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x2cb4bbe398d4d6312533ffbfd0aebcb34c1febb6/Kildoneum.sol:StandardToken:allowance(address,address)","0x2cb4bbe398d4d6312533ffbfd0aebcb34c1febb6/Kildoneum.sol:StandardToken:approve(address,uint256)",0.7185374149659864,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string,string)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",1.0,5,5,1
"  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {
    uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);
    uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);
    uint feeRebateXfer = 0;
    if (accountLevelsAddr != 0x0) {
      uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);
      if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);
      if (accountLevel==2) feeRebateXfer = feeTakeXfer;
    }
    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));
    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));
    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));
    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);
    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);
  }
","  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    return orderFills[user][hash];
  }
","0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:tradeBalances(address,uint256,address,uint256,address,uint256)","0x2b7932875085330b421b0af9f6b237bfe02f5e5f/Metaexchange.sol:Metaexchange:amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)",0.6666666666666666,2,2,0
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x5f24ed71ac6ddea5aa2dee7b521b98763520c6ed/TessrnetToken.sol:Owned:onlyOwner(),0x5f24ed71ac6ddea5aa2dee7b521b98763520c6ed/TessrnetToken.sol:Owned:transferOwnership(address),0.2579421526789948,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x1be0fe534e593f83ec016028d3c91b5dd66ba5aa/SendMe.sol:SendMe:transferFrom(address,address,uint256)","0x1be0fe534e593f83ec016028d3c91b5dd66ba5aa/SendMe.sol:SendMe:burnFrom(address,uint256)",0.8538283062645011,2,2,0
"    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
        if ((_proof[0] != ""L"")||(_proof[1] != ""P"")||(_proof[2] != 1)) throw;

        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
        if (proofVerified == false) throw;

        _;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[5])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_randomDS_proofVerify(bytes32,string,bytes)",0.6,2,2,0
"  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    emit Pause();
    return true;
  }
","  modifier whenPaused {
    if (!paused) revert();
    _;
  }
",0x0c8a503b2531ca1777f42b3cd57c30c33e179096/AAAToken.sol:Pausable:pause(),0x0c8a503b2531ca1777f42b3cd57c30c33e179096/AAAToken.sol:Pausable:whenPaused(),0.1388888888888889,2,2,0
"    function imax(int x, int y) internal pure returns (int z) {
        return x >= y ? x : y;
    }
","    function imin(int x, int y) internal pure returns (int z) {
        return x <= y ? x : y;
    }
","0x8a4774fe82c63484afef97ca8d89a6ea5e21f973/PriceFeed.sol:DSMath:imax(int256,int256)","0x8a4774fe82c63484afef97ca8d89a6ea5e21f973/PriceFeed.sol:DSMath:imin(int256,int256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[2])",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:uint2str(uint256),0.8,2,2,0
"    function transfer(address _to, uint256 _value) public crowdsaleTransferLock {
        super.transfer(_to, _value);
    }
","    function finalize() external onlyTeam{
        require(!isFinalized);//check if already ran        
        require(totalSupply >= tokenCreationMinMile1); // have to sell minimum to move to operational
        require(block.number > fundingEndBlock || totalSupply >= tokenCreationMaxCap);//don't end before ico period ends or max cap reached

        uint256 strVal = totalSupply.div(2);
        balances[strFundDeposit] = strVal; // deposit Strim share
        CreateSTR(msg.sender, strVal); // logs token creation

        // move to operational        
        if (!ethFundDeposit.send(this.balance)) revert(); // send the eth to Strim Team
        if (!strFundDeposit.send(this.balance)) revert(); // send the str to Strim Team
        isFinalized = true;
    }
","0x8bc7468bfd4c09d334071e954e1b06eb0e6c67e3/STRIMToken.sol:STRIMToken:transfer(address,uint256)",0x8bc7468bfd4c09d334071e954e1b06eb0e6c67e3/STRIMToken.sol:STRIMToken:finalize(),1.0,5,5,1
"    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[2])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:__callback(bytes32,string)",0.8,2,2,0
"    modifier transactionExists(uint transactionId) {
        require(transactions[transactionId].destination != 0);
        _;
    }
","    function getTransactionIds(uint from, uint to, bool pending, bool executed)
        public
        constant
        returns (uint[] _transactionIds)
    {
        uint[] memory transactionIdsTemp = new uint[](transactionCount);
        uint count = 0;
        uint i;
        for (i=0; i<transactionCount; i++)
            if (   pending && !transactions[i].executed
                || executed && transactions[i].executed)
            {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        _transactionIds = new uint[](to - from);
        for (i=from; i<to; i++)
            _transactionIds[i - from] = transactionIdsTemp[i];
    }
",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:transactionExists(uint256),"0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getTransactionIds(uint256,uint256,bool,bool)",1.0,5,5,1
"    function transfer(address _to, uint256 _amount)
        external
        notZeroAddress(_to)
        returns (bool success)
    {
        balances[msg.sender] = balances[msg.sender].SUB(_amount);
        balances[_to] = balances[_to].ADD(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function burn(uint256 _value) external returns (bool success) {
        //Subtract from the sender
        balances[msg.sender] = balances[msg.sender].SUB(_value);
        //Update _totalSupply
        _totalSupply = _totalSupply.SUB(_value);
        Burn(msg.sender, _value);
        return true;
    }
","0x1b1b94a8936bbd9d6a0d83b12eb51d7e09a05829/TheWolfCoin.sol:StandardToken:transfer(address,uint256)",0x1b1b94a8936bbd9d6a0d83b12eb51d7e09a05829/TheWolfCoin.sol:StandardToken:burn(uint256),0.0,2,2,0
"    function Ownable() {
        owner = msg.sender;
    }
","    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
",0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Ownable:Ownable(),0x2bdc0d42996017fce214b21607a515da41a9e0c5/SkinCoin.sol:Ownable:onlyOwner(),0.0609284332688588,2,2,0
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x7fccf800568747b178c6cbbe4bf3d147df75ac61/CBCToken.sol:SafeMath:sub(uint256,uint256)","0x7fccf800568747b178c6cbbe4bf3d147df75ac61/CBCToken.sol:SafeMath:mul(uint256,uint256)",0.9659477866061292,5,5,1
"    function hatchEggs(address ref) public{
        require(initialized);
        if(referrals[msg.sender]==0 && referrals[msg.sender]!=msg.sender){
            referrals[msg.sender]=ref;
        }
        uint256 eggsUsed=getMyEggs();
        uint256 newShrimp=SafeMath.div(eggsUsed,EGGS_TO_HATCH_1SHRIMP);
        hatcheryShrimp[msg.sender]=SafeMath.add(hatcheryShrimp[msg.sender],newShrimp);
        claimedEggs[msg.sender]=0;
        lastHatch[msg.sender]=now;

        //send referral eggs
        claimedEggs[referrals[msg.sender]]=SafeMath.add(claimedEggs[referrals[msg.sender]],SafeMath.div(eggsUsed,5));

        //boost market to nerf shrimp hoarding
        marketEggs=SafeMath.add(marketEggs,SafeMath.div(eggsUsed,10));
    }
","    function _isContract(address _user) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_user) }
        return size > 0;
    }
",0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:hatchEggs(address),0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:_isContract(address),0.0625,2,2,0
"    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function add(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x7d9238e1c39e91089bfe5e72a503e32f2dac526e/ChickenToken.sol:SafeMath:div(uint256,uint256)","0x7d9238e1c39e91089bfe5e72a503e32f2dac526e/ChickenToken.sol:SafeMath:add(uint256,uint256)",0.9931454683929932,5,5,1
"  function totalSupply() constant returns (uint256 _totalSupply) {
      return totalSupply;
  }
","  function transfer(address _to, uint256 _value) returns (bool success) {
      
    //standard function transfer similar to ERC20 transfer with no _data
    //added due to backwards compatibility reasons
    bytes memory empty;
    if(isContract(_to)) {
        transferToContract(_to, _value, empty);
    }
    else {
        transferToAddress(_to, _value, empty);
    }
    return true;
  }
",0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:totalSupply(),"0x1DC5b8CcBe7A3669ED59dcd3B3d5AFA0FeD4eE57/ABCToken.sol:ERC23Token:transfer(address,uint256)",0.19101123595505612,2,2,0
"    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }
","    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
",0x1A8081fEe8393822f1Fb9966f9Ac10b226817728/AUACoin.sol:AUACoin:balanceOf(address),"0x1A8081fEe8393822f1Fb9966f9Ac10b226817728/AUACoin.sol:AUACoin:allowance(address,address)",0.3564102564102564,2,2,0
"    function XiiPay() public {
        owner = msg.sender;
        balances[owner] = totalDistributed;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
",0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:XiiPay(),"0x4ed0954122ca706170fa38ad92475c7bdac7ff18/XiiPay.sol:XiiPay:approve(address,uint256)",1.0,5,5,1
"    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }
","    function Presale () validSetupOnly() { }
",0x3aaa5474a09804b08120e6e33bfc433367ab238c/Presale.sol:Presale:inState(Presale:State),0x3aaa5474a09804b08120e6e33bfc433367ab238c/Presale.sol:Presale:Presale(),0.5714285714285714,2,2,0
"        function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","        function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }
","0x3cf3da123e542d48d771fa8577e7e69863565d5a/X.sol:X:transfer(address,uint256)",0x3cf3da123e542d48d771fa8577e7e69863565d5a/X.sol:X:burn(uint256),0.8083140877598153,2,2,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
",0x1dab4bbc3e8f0a0fa5e5f67890e715bc9285f359/B24Token.sol:BasicToken:totalSupply(),"0x1dab4bbc3e8f0a0fa5e5f67890e715bc9285f359/B24Token.sol:BasicToken:approve(address,uint256)",0.10136452241715402,2,2,0
"    function approve(address _spender, uint256 _value) returns (bool) {
        allowances[msg.sender][_spender] += _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint _value) returns (bool) {
        if (balances[msg.sender] >= _value) {
            balances[msg.sender] -= _value;
            balances[_to]        += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }
","0x5cbDB911fa92261b7606eEA74f35Ef96ac6d2C70/Crowdfunding.sol:Token:approve(address,uint256)","0x5cbDB911fa92261b7606eEA74f35Ef96ac6d2C70/Crowdfunding.sol:Token:transfer(address,uint256)",0.008611410118406888,2,2,0
"  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x0b75fbcb65d6a022e4c0be96a5e64159bb43e869/LTKN.sol:LTKN:allowance(address,address)","0x0b75fbcb65d6a022e4c0be96a5e64159bb43e869/LTKN.sol:LTKN:transferFrom(address,address,uint256)",0.3171945701357466,2,2,0
"  function mul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x8b88a39383c90000bf8be57b8abfd59a6256b2e2/NAKED.sol:SafeMath:mul(uint256,uint256)","0x8b88a39383c90000bf8be57b8abfd59a6256b2e2/NAKED.sol:SafeMath:div(uint256,uint256)",0.8524590163934426,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf/SmartPayment.sol:TokenERC20:approveAndCall(address,uint256,bytes)","0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf/SmartPayment.sol:TokenERC20:transfer(address,uint256)",0.7145708582834331,2,2,0
"    function distributeAirdrop(address[] addresses, uint256 amount) public returns (bool) {
        require(amount > 0 
                && addresses.length > 0
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        amount = amount.mul(1e8);
        uint256 totalAmount = amount.mul(addresses.length);
        require(balanceOf[msg.sender] >= totalAmount);
        
        for (uint j = 0; j < addresses.length; j++) {
            require(addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amount);
            Transfer(msg.sender, addresses[j], amount);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:distributeAirdrop(address[],uint256)","0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:transferToAddress(address,uint256,bytes)",1.0,5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
","0x7dfc425c0425d69ca577d76c6d53a26a6c2cc0ac/ICODollar.sol:ICODollar:freezeAccount(address,bool)","0x7dfc425c0425d69ca577d76c6d53a26a6c2cc0ac/ICODollar.sol:ICODollar:mintToken(address,uint256)",0.4827586206896552,2,2,0
"  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x0da7ed8789348ac40937cf6ae8ff521eee43816c/EtherDividendCheckpointFactory.sol:BasicToken:balanceOf(address),0x0da7ed8789348ac40937cf6ae8ff521eee43816c/EtherDividendCheckpointFactory.sol:BasicToken:totalSupply(),0.5871794871794872,2,2,0
"  function pause() public onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x0f3ce9be205d4abcf3ec2aea83c35cc16fb8a415/LeCarboneToken.sol:Pausable:pause(),0x0f3ce9be205d4abcf3ec2aea83c35cc16fb8a415/LeCarboneToken.sol:Pausable:whenNotPaused(),0.8157894736842105,2,2,0
"    function signedTransferCheck(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {
        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;
        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);
        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;
        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;
        if (self.nextNonce[tokenOwner] != nonce) return BTTSTokenInterface.CheckResult.InvalidNonce;
        uint total = safeAdd(tokens, fee);
        if (self.balances[tokenOwner] < tokens) return BTTSTokenInterface.CheckResult.InsufficientTokens;
        if (self.balances[tokenOwner] < total) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;
        if (self.balances[to] + tokens < self.balances[to]) return BTTSTokenInterface.CheckResult.OverflowError;
        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;
        return BTTSTokenInterface.CheckResult.Success;
    }
","    function getCheckResultMessage(Data storage /*self*/, BTTSTokenInterface.CheckResult result) public pure returns (string) {
        if (result == BTTSTokenInterface.CheckResult.Success) {
            return ""Success"";
        } else if (result == BTTSTokenInterface.CheckResult.NotTransferable) {
            return ""Tokens not transferable yet"";
        } else if (result == BTTSTokenInterface.CheckResult.AccountLocked) {
            return ""Account locked"";
        } else if (result == BTTSTokenInterface.CheckResult.SignerMismatch) {
            return ""Mismatch in signing account"";
        } else if (result == BTTSTokenInterface.CheckResult.InvalidNonce) {
            return ""Invalid nonce"";
        } else if (result == BTTSTokenInterface.CheckResult.InsufficientApprovedTokens) {
            return ""Insufficient approved tokens"";
        } else if (result == BTTSTokenInterface.CheckResult.InsufficientApprovedTokensForFees) {
            return ""Insufficient approved tokens for fees"";
        } else if (result == BTTSTokenInterface.CheckResult.InsufficientTokens) {
            return ""Insufficient tokens"";
        } else if (result == BTTSTokenInterface.CheckResult.InsufficientTokensForFees) {
            return ""Insufficient tokens for fees"";
        } else if (result == BTTSTokenInterface.CheckResult.OverflowError) {
            return ""Overflow error"";
        } else {
            return ""Unknown error"";
        }
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:signedTransferCheck(BTTSLib:Data,address,address,uint256,uint256,uint256,bytes,address)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:getCheckResultMessage(BTTSLib:Data,BTTSTokenInterface:CheckResult)",1.0,5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }
",0x5b755b2130dab47636222ea33695c62bb54dc85d/GoblinChainToken.sol:GoblinChainToken:balanceOf(address),"0x5b755b2130dab47636222ea33695c62bb54dc85d/GoblinChainToken.sol:GoblinChainToken:transfer(address,uint256)",0.896875,5,5,1
"    modifier onlyTeam() {
        //only do if call is from owner modifier
        require(msg.sender == StrimTeam);
        _;
    }
","    modifier whenNotHalted() {
        // only do when not halted modifier
        require(!halted);
        _;
    }
",0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:onlyTeam(),0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:whenNotHalted(),0.05555555555555555,2,2,0
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
","0x07eefa3789a3298bf62f0427f07bcd1127322424/KellerWilliams.sol:KellerWilliams:transfer(address,uint256)",0x07eefa3789a3298bf62f0427f07bcd1127322424/KellerWilliams.sol:KellerWilliams:withdraw(),0.5428571428571428,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x0b2f8fbc293c35e900d6a8d7fd926e6ad657010e/LDIT.sol:LDIT:transfer(address,uint256)","0x0b2f8fbc293c35e900d6a8d7fd926e6ad657010e/LDIT.sol:LDIT:burnFrom(address,uint256)",0.7829099307159353,2,2,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function LTKN() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
",0x0b75fbcb65d6a022e4c0be96a5e64159bb43e869/LTKN.sol:LTKN:totalSupply(),0x0b75fbcb65d6a022e4c0be96a5e64159bb43e869/LTKN.sol:LTKN:LTKN(),0.0019493177387914235,2,2,0
"    function contains(intSet storage self, int other) returns (bool) {
        return self.memberExists[other];
    }
","    function insert(uint8Set storage self, uint8 other) {
        if (!self.memberExists[other]) {
            self.memberExists[other] = true;
            self.memberIndex[other] = self.members.length;
            self.members.push(other);
        }
    }
","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:contains(Sets:intSet,int256)","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:insert(Sets:uint8Set,uint8)",1.0,5,5,1
"  function MB() public {
    _totalSupply = INITIAL_SUPPLY;
	_creator = 0xf2F91C1C681816eE275ce9b4366D5a906da6eBf5;
	balances[_creator] = INITIAL_SUPPLY;
	bIsFreezeAll = false;
  }
","  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
",0x7ab1fc79f319718690e9c883bac910f8e289ce8f/MB.sol:MB:MB(),0x7ab1fc79f319718690e9c883bac910f8e289ce8f/MB.sol:MB:balanceOf(address),0.0,2,2,0
"	function Artwork (								// Constructor
		bytes32 _SHA256ofArtwork,
		uint256 _editionSize,
		string _title,
		string _fileLink,
		string _customText,
		uint256 _ownerCommission,
		address _owner
	) {
		if (_ownerCommission > 9750 || _ownerCommission <0) {throw;}
		owner = _owner;                            // Owner is set as the address spawning the contract
		SHA256ofArtwork = _SHA256ofArtwork;
		editionSize = _editionSize;
		title = _title;
		fileLink = _fileLink;
		customText = _customText;
		ownerCommission = _ownerCommission;
		activationTime = now;	
	}
","	function changeOwner (address newOwner) onlyBy (owner) {
		owner = newOwner;
		}
","0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:Artwork(bytes32,uint256,string,string,string,uint256,address)",0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:changeOwner(address),1.0,5,5,1
"    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + WAD / 2) / WAD);
    }
","0x0d88ed6e74bbfd96b831231638b66c05571e824f/DSToken.sol:DSMath:hsub(uint128,uint128)","0x0d88ed6e74bbfd96b831231638b66c05571e824f/DSToken.sol:DSMath:wmul(uint128,uint128)",1.0,5,5,1
"  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
","  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }
","0x8a822d790d6a2fc21902c7d9736941ab6a9b0f6d/GoldenCurrencyToken.sol:BurnableToken:_burn(address,uint256)",0x8a822d790d6a2fc21902c7d9736941ab6a9b0f6d/GoldenCurrencyToken.sol:BurnableToken:burn(uint256),0.8289473684210527,2,2,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x03a76034b6b33011acea6eddbb0423b79540eed7/XZBX.sol:SafeMath:add(uint256,uint256)","0x03a76034b6b33011acea6eddbb0423b79540eed7/XZBX.sol:SafeMath:mul(uint256,uint256)",0.9758426966292136,5,5,1
"	function getImageCurrentRegionId(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageCurrentRegionId(_imageId);
	}
","	function getRegionCoordinates(uint256 _regionId) view public returns (uint256, uint256, uint256, uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionCoordinates(_regionId);
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageCurrentRegionId(uint256),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getRegionCoordinates(uint256),0.5,2,2,0
"    function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length);

        uint256 totalAmount = 0;
        
        for (uint j = 0; j < addresses.length; j++) {
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            require(balanceOf[addresses[j]] >= amounts[j]);
            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);
            totalAmount = totalAmount.add(amounts[j]);
            Transfer(addresses[j], msg.sender, amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].add(totalAmount);
        return true;
    }
","    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
        require(targets.length > 0
                && targets.length == unixTimes.length);

        for(uint j = 0; j < targets.length; j++){
            require(unlockUnixTime[targets[j]] < unixTimes[j]);
            unlockUnixTime[targets[j]] = unixTimes[j];
            LockedFunds(targets[j], unixTimes[j]);
        }
    }
","0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:collectTokens(address[],uint256[])","0x3b72b2766c0499910345687ee5b16dc859d4a7c8/HARITECOIN.sol:HARITECOIN:lockupAccounts(address[],uint256[])",1.0,5,5,1
"  function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
    require(_to != address(this));

    super.transfer(_to, _value);

    // solium-disable-next-line security/no-call-value
    require(_to.call.value(msg.value)(_data));
    return true;
  }
","  function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
    require(_spender != address(this));

    super.approve(_spender, _value);

    // solium-disable-next-line security/no-call-value
    require(_spender.call.value(msg.value)(_data));

    return true;
  }
","0x8a976bd6dfec2356629321fb4d0ab82d67d9e3fc/SUNToken.sol:ERC827Token:transferAndCall(address,uint256,bytes)","0x8a976bd6dfec2356629321fb4d0ab82d67d9e3fc/SUNToken.sol:ERC827Token:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"    function strConcat(string _a, string _b) internal returns (string) {
        return strConcat(_a, _b, """", """", """");
    }
","    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:strConcat(string,string)",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:getCodeSize(address),0.4444444444444444,2,2,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x4fdef6d9b1995e7205f5c849cd7b949f5c37e296/PetsCoin.sol:StandardToken:balanceOf(address),"0x4fdef6d9b1995e7205f5c849cd7b949f5c37e296/PetsCoin.sol:StandardToken:transfer(address,uint256)",0.28766430738119314,2,2,0
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
",0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:AndhraToken:balanceOf(address),"0x2fb23f5b0b18e947186c9cc848b86d550c81711c/AndhraToken.sol:AndhraToken:approve(address,uint256)",0.953125,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x2e402fdb7259a4919aca0b06610896bf1f1a72a3/GucciCoin.sol:StandardToken:transferFrom(address,address,uint256)",0x2e402fdb7259a4919aca0b06610896bf1f1a72a3/GucciCoin.sol:StandardToken:balanceOf(address),0.9672830725462304,5,5,1
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[2],uint256)",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setNetworkName(string),0.8,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","0x4afeb9cce471e2cc0e98ebf6d0bbfc0142ddc6d0/LitecoinEclipse.sol:LitecoinEclipse:transferFrom(address,address,uint256)","0x4afeb9cce471e2cc0e98ebf6d0bbfc0142ddc6d0/LitecoinEclipse.sol:LitecoinEclipse:_transfer(address,address,uint256)",0.8445475638051044,4,4,0
"  function safeMul(uint a, uint b) internal pure  returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function safeDiv(uint a, uint b) internal pure returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:SafeMath:safeMul(uint256,uint256)","0x7f7b57131f7a70edcb34c409e942e5adb811d9cf/TokenAdrToken.sol:SafeMath:safeDiv(uint256,uint256)",0.16467780429594273,4,4,0
"  function totalSupply() constant returns (uint256 supply) {
    return tokenCount;
  }
","  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      emit Freeze ();
    }
  }
",0x1f10822c753a1f587923d9916e64738ee7c27419/GPHToken.sol:GPHToken:totalSupply(),0x1f10822c753a1f587923d9916e64738ee7c27419/GPHToken.sol:GPHToken:freezeTransfers(),0.9615384615384616,5,5,1
"    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
","    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), WAD / 2) / WAD;
    }
","0x5cc12100e1337f0d2fc711d8e678778eca20dcad/MintAuthority.sol:DSMath:add(uint256,uint256)","0x5cc12100e1337f0d2fc711d8e678778eca20dcad/MintAuthority.sol:DSMath:wmul(uint256,uint256)",0.11224489795918367,4,4,0
"    function refund() private  {
      uint256 weiValue = this.balance;
      if (weiValue == 0) throw;
      uint256 weiRefunded;
      weiRefunded = safeAdd(weiRefunded, weiValue);
      refund();
      if (!msg.sender.send(weiValue)) throw;
    }
","  function add_to_bounty() payable {
    // Only allow the developer to contribute to the buy execution bounty.
    if (msg.sender != developer_address) throw;
    // Disallow adding to bounty if kill switch is active.
    if (kill_switch) throw;
    // Disallow adding to the bounty if contract has already bought the tokens.
    if (bought_tokens) throw;
    // Update bounty to include received amount.
    bounty += msg.value;
  }
",0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:refund(),0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:add_to_bounty(),1.0,5,5,1
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
","    function withdraw() onlyOwner public {
        uint256 etherBalance = address(this).balance;
        owner.transfer(etherBalance);
    }
","0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c/TrekChain.sol:TrekChain:transfer(address,uint256)",0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c/TrekChain.sol:TrekChain:withdraw(),0.5507246376811594,4,4,0
"    modifier onlyContractOwner() {
        if (contractOwner == msg.sender) {
            _;
        }
    }
","    function destroy() onlyContractOwner {
        suicide(msg.sender);
    }
",0x2ccfc338fe9cf7bbfa6f3d775b88ef85d62d06d7/Profiterole.sol:Owned:onlyContractOwner(),0x2ccfc338fe9cf7bbfa6f3d775b88ef85d62d06d7/Profiterole.sol:Owned:destroy(),0.16666666666666666,4,4,0
"  function add(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }
","    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
    }
","0x1bb2e2e063a58368a592857b0abe8b4a827e5a07/MyToken.sol:SafeMath:add(uint256,uint256)","0x1bb2e2e063a58368a592857b0abe8b4a827e5a07/MyToken.sol:SafeMath:max256(uint256,uint256)",0.3478260869565217,4,4,0
"  function transferFrom(address _from, address _to, uint256 _value)
  returns (bool success) {
    require(_to != address(0));
    if (allowances [_from][msg.sender] < _value) return false;
    if (accounts [_from] < _value) return false; 

    if (_value > 0 && _from != _to) {
	  allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value);
      accounts [_from] = safeSub (accounts [_from], _value);
      accounts [_to] = safeAdd (accounts [_to], _value);
    }
    Transfer(_from, _to, _value);
    return true;
  }
","   function approve (address _spender, uint256 _value) returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    Approval (msg.sender, _spender, _value);
    return true;
  }
","0x3ee016cdcaab16ebf4ec1eda758606f6fd874a57/ETUToken.sol:AbstractToken:transferFrom(address,address,uint256)","0x3ee016cdcaab16ebf4ec1eda758606f6fd874a57/ETUToken.sol:AbstractToken:approve(address,uint256)",0.9642857142857144,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7/YouAreRichToken.sol:YouAreRichToken:allowance(address,address)","0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7/YouAreRichToken.sol:YouAreRichToken:transferFrom(address,address,uint256)",0.6990881458966566,3,3,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x0a2eaaff557d8e59bb829d2c67a7a097c9663b15/OodlebitToken.sol:StandardToken:approve(address,uint256)","0x0a2eaaff557d8e59bb829d2c67a7a097c9663b15/OodlebitToken.sol:StandardToken:transferFrom(address,address,uint256)",0.3666129898013956,2,2,0
"	modifier ethArtOnlyAfterOneYear()
	{
		require(msg.sender != registrar || now > activationTime + 31536000);
		_;
	}
","	function setProof (string _proofLink) onlyBy (owner) {
		if (!proofSet) {
			uint256 remainder;
			proofLink = _proofLink;
			proofSet = true;
			remainder = editionSize % 40;
			ethartAward = (editionSize - remainder) / 40;
			if (remainder > 0 && now % 39 <= remainder) {ethartAward++;}		// Yes - this is gameable - if it is that important to you: go ahead.
			piecesOwned[registrar] = ethartAward;
			piecesOwned[owner] = editionSize - ethartAward;
			}
		else {throw;}
		}
",0x5aad8436ec6320E846084aa4e6E6231387E8950a/Factory.sol:Artwork:ethArtOnlyAfterOneYear(),0x5aad8436ec6320E846084aa4e6E6231387E8950a/Factory.sol:Artwork:setProof(string),1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[])",1.0,5,5,1
"    function name()
        public
        view
        returns (string) {
        return _name;
    }
","   function approve(address _spender, uint256 _value) public returns (bool) {
     allowed[msg.sender][_spender] = _value;
     Approval(msg.sender, _spender, _value);
     return true;
   }
",0x3dc54e46c7dd2bebe0f5503ab1fbd87afba81d25/LiftUpVets.sol:LiftUpVets:name(),"0x3dc54e46c7dd2bebe0f5503ab1fbd87afba81d25/LiftUpVets.sol:LiftUpVets:approve(address,uint256)",0.4074074074074074,2,2,0
"    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {
        virtualReserveBalance = amountInWei;
    }
","    function extractFees(uint amountInWei) onlyAdmin public {
        require (amountInWei <= collectedFees);
        msg.sender.transfer(amountInWei);
    }
",0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:setVirtualReserveBalance(uint256),0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:extractFees(uint256),1.0,5,5,1
"    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
","    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
",0x1af79fb7772ebafebcfd5cc79e67281a814ccb1d/ISBToken.sol:Owned:onlyOwner(),0x1af79fb7772ebafebcfd5cc79e67281a814ccb1d/ISBToken.sol:Owned:acceptOwnership(),0.15315315315315314,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function OxBioToken() public {
      
        symbol = ""OXB"";
        name = ""OxBio"";
        decimals = 18;
        USDETH = 530;                                      // 1 ETH = USD 530 

        _totalSupply = 500000000 * 10**uint(decimals);     // 200M out of 500M 
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
","0x0c259e7c073c81188917c700a179818f18c5d6f8/OxBioToken.sol:OxBioToken:allowance(address,address)",0x0c259e7c073c81188917c700a179818f18c5d6f8/OxBioToken.sol:OxBioToken:OxBioToken(),0.13069908814589665,2,2,0
"    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[5])",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getPrice(string),0.8,2,2,0
"  function decreaseApproval (address _spender, uint _subtractedValue) 
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","0x1f4eff0be2fafbc6fb38820e8de633553c6454cd/SampleCrowdsale.sol:StandardToken:decreaseApproval(address,uint256)","0x1f4eff0be2fafbc6fb38820e8de633553c6454cd/SampleCrowdsale.sol:StandardToken:approve(address,uint256)",0.06287069988137604,2,2,0
"    function _sendRefund() private
    tokenHoldersOnly
    {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }
","    function mintAllBonuses() external
    inState(State.BONUS_MINTING)
    noAnyReentrancy
    {
        assert(!allBonusesAreMinted);
        allBonusesAreMinted = true;

        uint TEAM_AND_PARTNERS_PER_CENT = TEAM_BONUS_PER_CENT + ADVISORS_AND_PARTNERS_PER_CENT;

        uint total_presale_amount_with_bonus = mintPresaleBonuses();
        uint total_collected_amount = total_received_amount + total_presale_amount_with_bonus;
        uint extra_amount = total_collected_amount * TEAM_AND_PARTNERS_PER_CENT / (100 - TEAM_AND_PARTNERS_PER_CENT);
        uint extra_team_amount = extra_amount * TEAM_BONUS_PER_CENT / TEAM_AND_PARTNERS_PER_CENT;
        uint extra_partners_amount = extra_amount * ADVISORS_AND_PARTNERS_PER_CENT / TEAM_AND_PARTNERS_PER_CENT;
/* 
        //beautify total supply: round down to full eth.
        uint total_to_mint = total_collected_amount + extra_amount;
        uint round_remainder = total_to_mint - (total_to_mint / 1 ether * 1 ether);
        extra_team_amount -= round_remainder; //this will reduce total_supply to rounded value
*/
        //mint group bonuses
        _mint(extra_team_amount , TEAM_GROUP_WALLET);
        _mint(extra_partners_amount, ADVISERS_AND_FRIENDS_WALLET);

    }
",0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:_sendRefund(),0x2eCae89ebd1DdE40E39D04f515E1f8E64AB939bd/CrowdsaleMinter.sol:CrowdsaleMinter:mintAllBonuses(),0.16666666666666666,2,2,0
"    function totalSupply() public view returns (uint256 _totalSupply){
    return _totalsupply;
    }
","    function getOwner() public view returns(address){
        return onlyadmin;
    }
",0x3c63d4b0330a1ab969ff0f8b2ba227540a15b0ca/SpanCoin.sol:SpanToken:totalSupply(),0x3c63d4b0330a1ab969ff0f8b2ba227540a15b0ca/SpanCoin.sol:SpanToken:getOwner(),0.0,2,2,0
"    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x2c90a3fcf2cfa89f53530e4a7bb6d565ac4e74a6/RushCoin.sol:ERC20:approve(address,uint256)","0x2c90a3fcf2cfa89f53530e4a7bb6d565ac4e74a6/RushCoin.sol:ERC20:approveAndCall(address,uint256,bytes)",0.8964059196617337,2,2,0
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
",0x1b740cb6210c4ee5f88278ec0e8b9d6c012f9ca1/TouristToken.sol:TouristToken:withdrawForeignTokens(address),0x1b740cb6210c4ee5f88278ec0e8b9d6c012f9ca1/TouristToken.sol:TouristToken:updateTokensPerEth(uint256),0.3606557377049181,2,2,0
"    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function transfer(address to, uint tokens) public ifRunning returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }
","0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:allowance(address,address)","0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:transfer(address,uint256)",0.182370820668693,2,2,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","0x3d1580a49ff158daee0d2d9fe10393255b581e1a/CUC.sol:SafeMath:add(uint256,uint256)","0x3d1580a49ff158daee0d2d9fe10393255b581e1a/CUC.sol:SafeMath:div(uint256,uint256)",0.7325842696629213,2,2,0
"	modifier	onlyOwner	() {							
		require(msg.sender ==		owner	);					
		_;								
	}									
","	function	getPOOL_edit_33	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_33	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:onlyOwner(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_33(),0.0009483167377904221,2,2,0
"    function refundToOwner (uint256 amountOfEth, uint256 CLOUD) onlyOwner {
        uint256 eth = safeMul(amountOfEth, 1 ether);
        if (!msg.sender.send(eth)) {                                        // Send ether to the owner. It's important
            throw;                                                          // To do this last to avoid recursion attacks
        } else {
            Transfer(this, msg.sender, eth);                                // Execute an event reflecting on the change
        }
        if (balances[this] < CLOUD) throw;                                    // Check if it has enough to sell
        balances[msg.sender] = safeAdd(balances[msg.sender], CLOUD);          // Add the amount to buyer's balance
        balances[this] = safeSub(balances[this], CLOUD);                      // Subtract amount from seller's balance
        Transfer(this, msg.sender, CLOUD);                                    // Execute an event reflecting the change
    }
","    function haltDirectTrade() onlyOwner {
        directTradeAllowed = false;
    }
","0x4e64e18f6e6f5d694725c8c02ec8ace180ade2d0/ICloudSecToken.sol:ICloudSecToken:refundToOwner(uint256,uint256)",0x4e64e18f6e6f5d694725c8c02ec8ace180ade2d0/ICloudSecToken.sol:ICloudSecToken:haltDirectTrade(),1.0,5,5,1
" function setTotalTokensForPublicSale(uint _value) onlyOwner{
      require(_value != 0);
      tokensForPublicSale = _value;
  }
","function decreaseSupply(uint value) onlyOwner returns (bool) {
  balances[contractAddress] = safeSub(balances[contractAddress], value);
  totalSupply = safeSub(totalSupply, value);
  Transfer(contractAddress, 0x0, value);
  return true;
}
",0x5c751a3a3375a97463a4b5f000c3f700802e903a/DMToken.sol:DMToken:setTotalTokensForPublicSale(uint256),0x5c751a3a3375a97463a4b5f000c3f700802e903a/DMToken.sol:DMToken:decreaseSupply(uint256),0.0,4,4,0
"  function hasModerator() constant returns(bool) {
      return (moderator != address(0));
  }
","  function removeModeratorship() onlyOwner {
      moderator = address(0);
  }
",0x6e74216fc9ec901c8e0d3fd8acf237e6a2f85413/EVXTestToken.sol:evxModerated:hasModerator(),0x6e74216fc9ec901c8e0d3fd8acf237e6a2f85413/EVXTestToken.sol:evxModerated:removeModeratorship(),1.0,5,5,1
"    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }
","    function getOwners()
        public
        constant
        returns (address[])
    {
        return owners;
    }
",0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:addOwner(address),0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getOwners(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) 
    updateAccount(msg.sender)
    updateAccount(_to)
    voteUpdater(_to, msg.sender)
    returns (bool success) 
    {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x4B7AdB6bd6f2F4f7C8a51b224FCC6583a9A1d587/SISAcrowdsale.sol:StandardToken:transfer(address,uint256)","0x4B7AdB6bd6f2F4f7C8a51b224FCC6583a9A1d587/SISAcrowdsale.sol:StandardToken:allowance(address,address)",0.9090909090909092,4,4,0
"  function retrieveWalletForVanity(string _vanity_url) constant public returns (address) {
    return vanity_address_mapping[_vanity_url];
  }
","  function reserve(string _vanity_url) whenNotPaused public {
    _vanity_url = _toLower(_vanity_url);
    require(checkForValidity(_vanity_url));
    require(vanity_address_mapping[_vanity_url]  == address(0x0));
    require(bytes(address_vanity_mapping[msg.sender]).length == 0);
    vanity_address_mapping[_vanity_url] = msg.sender;
    address_vanity_mapping[msg.sender] = _vanity_url;
    VanityReserved(msg.sender, _vanity_url);
  }
",0x5fd72a8a514697232cce4e0166c48993b060f46c/VanityURL.sol:VanityURL:retrieveWalletForVanity(string),0x5fd72a8a514697232cce4e0166c48993b060f46c/VanityURL.sol:VanityURL:reserve(string),1.0,5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x5e32e8ccba0516f16eb2ea3093cd55be5d7a5e62/BSmartValueCirculateAssets.sol:SafeMath:div(uint256,uint256)","0x5e32e8ccba0516f16eb2ea3093cd55be5d7a5e62/BSmartValueCirculateAssets.sol:SafeMath:mul(uint256,uint256)",0.9870525514089872,5,5,1
"	function	getData_8	()	public	constant	returns	(	string	)	{
		return	inData_8	;						
	}									
","	function	getData_10	()	public	constant	returns	(	string	)	{
		return	inData_10	;						
	}									
",1/1home/auatac/liao_system/contracts/0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_8(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_10(),0.3333333333333333,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getPrice(string),0.8,4,4,0
"    function nextPriceOf (uint256 _itemId) public view returns (uint256 _nextPrice) {
        return calculateNextPrice(priceOf(_itemId));
    }
","  function setOwner (address _owner) onlyOwner() public {
    owner = _owner;
  }
",0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:nextPriceOf(uint256),0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:setOwner(address),0.5,4,4,0
"  function getBalance()
    constant
    public
    returns(uint)
  {
    return we_token.balanceOf(this);
  }
","  modifier onlyOwner
  {
    require(owner == msg.sender);
    _;
  }
",0x4f0499f4da2d75d03fcc2dc2d97ffae976246809/VestingContractWT.sol:VestingContractWT:getBalance(),0x4f0499f4da2d75d03fcc2dc2d97ffae976246809/VestingContractWT.sol:VestingContractWT:onlyOwner(),0.0,4,4,0
"    function mintToken(uint256 tokensToMint) public onlyOwner 
        {
            if(tokensToMint > 0)
            {
                var totalTokenToMint = tokensToMint * (10 ** 18);
                balanceOf[owner] += totalTokenToMint;
                totalSupply += totalTokenToMint;
                Transfer(0, owner, totalTokenToMint);
            }
        }
","  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)
      {
          tokenRecipient spender = tokenRecipient(_spender);
          if (approve(_spender, _value)) {
              spender.receiveApproval(msg.sender, _value, this, _extraData);
              return true;
          }
      }        
",0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:mintToken(uint256),"0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"    function Lyfecoin() public {
        symbol = ""LFC"";
        name = ""Lyfecoin"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e] = _totalSupply;
        emit Transfer(address(0), 0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e, _totalSupply);
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
",0x6b1788ff796a74e16f0e3bd5ba1efd853526f361/Lyfecoin.sol:Lyfecoin:Lyfecoin(),"0x6b1788ff796a74e16f0e3bd5ba1efd853526f361/Lyfecoin.sol:Lyfecoin:transferAnyERC20Token(address,uint256)",0.9852941176470588,5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //?????????? receiveApprovalcall ?? ?????????????????????
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //?????????????????vanilla approve?
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function Coin(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);    // ???
        balances[msg.sender] = totalSupply;                             // ?????????????                      
        name = _tokenName;                                              // token??
        decimals = _decimalUnits;                                       // token???
        symbol = _tokenSymbol;                                          // token??
    }
","0x3cc8680ce5002dde7a41fe140af9575dcbc5920c/Coin.sol:Coin:approveAndCall(address,uint256,bytes)","0x3cc8680ce5002dde7a41fe140af9575dcbc5920c/Coin.sol:Coin:Coin(uint256,string,uint8,string)",0.0016474464579901151,4,4,0
"    function getCollectedAmount() onlyOwner public constant returns (uint256 balance) 
        {
            return amountCollected;
        }        
","    function getConBal() onlyOwner public constant returns  (uint)            // Get  Balance 
    {
        return this.balance;
    }    
",0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:getCollectedAmount(),0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:getConBal(),1.0,5,5,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x6bcc968f5ce2b76fed59ba52eda2d5021d832ff7/NANJCOIN.sol:StandardToken:transfer(address,uint256)","0x6bcc968f5ce2b76fed59ba52eda2d5021d832ff7/NANJCOIN.sol:StandardToken:transferFrom(address,address,uint256)",0.986254295532646,5,5,1
"    function transfer(address _to, uint _value) whenNotPaused public returns (bool success) {
        require(_value > 0
                && cannotSend[msg.sender] == false
                && cannotReceive[_to] == false
                && now > cannotSendUntil[msg.sender]
                && now > cannotReceiveUntil[_to]);

        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }
","    function freezeAccounts(address[] targets, bool _cannotSend, bool _cannotReceive) onlyOwner public {
        require(targets.length > 0);

        for (uint i = 0; i < targets.length; i++) {
            cannotSend[targets[i]] = _cannotSend;
            cannotReceive[targets[i]] = _cannotReceive;
            emit FrozenFunds(targets[i], _cannotSend, _cannotReceive);
        }
    }
","0x5ab793e36070f0fac928ea15826b0c1bc5365119/YUKI.sol:YUKI:transfer(address,uint256)","0x5ab793e36070f0fac928ea15826b0c1bc5365119/YUKI.sol:YUKI:freezeAccounts(address[],bool,bool)",0.5,4,4,0
"    function Noblebit (uint256 _value, uint256 _minReq) public {
        owner = msg.sender;
        value = _value;
        minReq = _minReq;
        balances[msg.sender] = totalDistributed;
    }
","    function getTokens() payable canDistr onlyWhitelist public {
        
        require(value <= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        if (msg.value < minReq){
            toGive = value.sub(value);
        }
        
        distr(investor, toGive);
        
        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:Noblebit(uint256,uint256)",0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:getTokens(),1.0,5,5,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function FHCContract() public {
        symbol = ""FHC"";
        name = ""Future Health"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xb1B5A4e78ec28195863AEB9BFCECCEd0232b6ea3] = _totalSupply; //MEW address here
        Transfer(address(0), 0xb1B5A4e78ec28195863AEB9BFCECCEd0232b6ea3, _totalSupply);//MEW address here
    }
","0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:allowance(address,address)",0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:FHCContract(),0.2857142857142857,4,4,0
"	modifier notAfterTime(uint256 targetTime){
		assert(now<=targetTime);
		_;
	}
","	function setupFundingRate(uint256 _rate) external
		onlyOwner
	{
		rate=_rate;
	}
",0x4a8f44be523580a11cdb20e2c7c470adf44ec9bb/BTMC.sol:BTMC:notAfterTime(uint256),0x4a8f44be523580a11cdb20e2c7c470adf44ec9bb/BTMC.sol:BTMC:setupFundingRate(uint256),0.0,4,4,0
"    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
                
        uint256 totalAmount = 0;
        
        for(uint j = 0; j < addresses.length; j++){
            require(amounts[j] > 0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);
                    
            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);
        
        for (j = 0; j < addresses.length; j++) {
            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);
            Transfer(msg.sender, addresses[j], amounts[j]);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }
","0x7d5404ea3344745f80d039c28efbe44742935593/Arascacoin.sol:Arascacoin:transfer(address,uint256,bytes)","0x7d5404ea3344745f80d039c28efbe44742935593/Arascacoin.sol:Arascacoin:distributeAirdrop(address[],uint256[])",0.5555555555555556,4,4,0
"  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
","0x2cffe1067d38e9d2282d8da6a67d80d4f1b6aef5/EplusCoinToken.sol:SafeMath:safeMul(uint256,uint256)","0x2cffe1067d38e9d2282d8da6a67d80d4f1b6aef5/EplusCoinToken.sol:SafeMath:min256(uint256,uint256)",0.02176220806794055,4,4,0
"	function calculateSetupAllowedUntil(uint256 _regionId) view public returns (uint256) {
		return BdpCalculator.calculateSetupAllowedUntil(contracts, _regionId);
	}
","	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImagePartsCount(_imageId);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:calculateSetupAllowedUntil(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getImagePartsCount(uint256),1.0,5,5,1
"  function transferOwnership(address newOwner) onlyOwner public {
    pendingOwner = newOwner;
  }
","  modifier onlyPendingOwner() {
    require(msg.sender == pendingOwner);
    _;
  }
",0x0a8b758bbc4a5791c5647ca80351e008f1e3bca1/ItemToken.sol:Claimable:transferOwnership(address),0x0a8b758bbc4a5791c5647ca80351e008f1e3bca1/ItemToken.sol:Claimable:onlyPendingOwner(),0.044374009508716325,4,4,0
"    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
",0x7f664f61dc14db9aec51c56426a8875553691c19/TIMEDEX.sol:TIMEDEX:withdrawAltcoinTokens(address),0x7f664f61dc14db9aec51c56426a8875553691c19/TIMEDEX.sol:TIMEDEX:getTokens(),0.3442622950819672,4,4,0
"    function getMyClones() public view returns(uint256){
        return arrayOfClones[msg.sender];
    }
","    function getMyIdeas() public view returns(uint256){
        address _caller = msg.sender;
        return claimedIdeas[_caller].add(getIdeasSinceLastDeploy(_caller));
    }
",0x02e582682aa7b4dcc3f7574c468ef61b29545404/CloneWars.sol:CloneWars:getMyClones(),0x02e582682aa7b4dcc3f7574c468ef61b29545404/CloneWars.sol:CloneWars:getMyIdeas(),1.0,5,5,1
"    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x6e6613235f419f25c01348fc5ca864ddfac97d90/ANYtoken.sol:ANYtoken:transferAnyERC20Token(address,uint256)","0x6e6613235f419f25c01348fc5ca864ddfac97d90/ANYtoken.sol:ANYtoken:allowance(address,address)",0.9581993569131833,5,5,1
"    function transferOwnership(Data storage self, address newOwner) public {
        require(msg.sender == self.owner);
        self.newOwner = newOwner;
    }
","    function signedTransferCheck(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {
        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;
        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);
        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;
        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;
        if (self.nextNonce[tokenOwner] != nonce) return BTTSTokenInterface.CheckResult.InvalidNonce;
        uint total = safeAdd(tokens, fee);
        if (self.balances[tokenOwner] < tokens) return BTTSTokenInterface.CheckResult.InsufficientTokens;
        if (self.balances[tokenOwner] < total) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;
        if (self.balances[to] + tokens < self.balances[to]) return BTTSTokenInterface.CheckResult.OverflowError;
        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;
        return BTTSTokenInterface.CheckResult.Success;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:transferOwnership(BTTSLib:Data,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedTransferCheck(BTTSLib:Data,address,address,uint256,uint256,uint256,bytes,address)",1.0,5,5,1
"  function transferFrom(
      address _from,
      address _to,
      uint256 _amount
  ) returns (bool success) {
      if (balances[_from] >= _amount
          && allowed[_from][msg.sender] >= _amount
          && _amount > 0
          && balances[_to] + _amount > balances[_to]) {
          balances[_from] -= _amount;
          allowed[_from][msg.sender] -= _amount;
          balances[_to] += _amount;
          Transfer(_from, _to, _amount);
          return true;
      } else {
          return false;
      }
  }
","  function totalSupply() constant returns (uint256 totalSupply) {
      totalSupply = _totalSupply;
  }
","0x5eaa84b84773483ed0a2cf3cedee8fd89a11ef21/mkethToken.sol:mkethToken:transferFrom(address,address,uint256)",0x5eaa84b84773483ed0a2cf3cedee8fd89a11ef21/mkethToken.sol:mkethToken:totalSupply(),0.35211267605633795,4,4,0
"    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[4])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[2],uint256)",1.0,5,5,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x1AD89Cda3532Ad4179aCCDa58917bd7Bb632B290/EOTCoin.sol:EOTCoin:balanceOf(address),"0x1AD89Cda3532Ad4179aCCDa58917bd7Bb632B290/EOTCoin.sol:EOTCoin:transfer(address,uint256)",0.28766430738119314,4,4,0
"    function DONC() public {
        symbol = ""DONC"";
        name = ""Double or Nothing Coin"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xbeD003505A5d0952AE44eAFdeeDE3227600E3Af5] = _totalSupply;
        Transfer(address(0), 0xbeD003505A5d0952AE44eAFdeeDE3227600E3Af5, _totalSupply);
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x0d9b54834162aeeb248983d772a647fb38ba9f2a/DONC.sol:DONC:DONC(),"0x0d9b54834162aeeb248983d772a647fb38ba9f2a/DONC.sol:DONC:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
","  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
","0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:SafeMath:min64(uint64,uint64)","0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b/LescoinPreSale.sol:SafeMath:max64(uint64,uint64)",1.0,5,5,1
"    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }
","    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:strConcat(string,string,string,string,string)",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setNetwork(uint8),0.4444444444444444,4,4,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x6f2211b4ac81da3d3e3ffd523867155cc5fcfaca/ChaffeyCoins.sol:StandardToken:approve(address,uint256)","0x6f2211b4ac81da3d3e3ffd523867155cc5fcfaca/ChaffeyCoins.sol:StandardToken:transferFrom(address,address,uint256)",0.3666129898013956,4,4,0
"  function balanceOf (address _owner) public view returns (uint256 _balance) {
    uint256 counter = 0;
    for (uint8 i = 0; i < listedItems.length; i++) {
      if (ownerOf(listedItems[i]) == _owner) {
          counter++;
      }
    }
    return counter;
  }
","  function setOwner (address _owner) onlyOwner() public {
    owner = _owner;
  }
",0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:balanceOf(address),0x7f85141f4c463b194017e849db8973c7961476ce/CellTokens.sol:CellTokens:setOwner(address),0.0,4,4,0
"	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}
","	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}
","0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:setRegionCurrentImageId(uint256,uint256)",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:getRegionPurchasePixelPrice(uint256),1.0,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x6fc2a418d752e4b26dc372ccd766696f9c462e30/HTG.sol:HTG:_transfer(address,address,uint256)","0x6fc2a418d752e4b26dc372ccd766696f9c462e30/HTG.sol:HTG:transfer(address,uint256)",0.8989637305699482,2,2,0
"    function ownerSetStakeStartTime(uint timestamp) onlyOwner {
        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));
        stakeStartTime = timestamp;
    }
","    function getBlockNumber() returns (uint blockNumber) {
        blockNumber = block.number.sub(chainStartBlockNumber);
    }
",0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Aecium:ownerSetStakeStartTime(uint256),0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Aecium:getBlockNumber(),1.0,5,5,1
"    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
","    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
",0x07a58629AAF3e1A0d07D8f43114B76BD5EEe3B91/insChainToken.sol:insChainToken:balanceOf(address),"0x07a58629AAF3e1A0d07D8f43114B76BD5EEe3B91/insChainToken.sol:insChainToken:allowance(address,address)",0.5915065722952477,2,2,0
"  function increaseApproval(address _spender,uint _addedValue)
    public
    whenNotPaused
    returns (bool success)
  {
    return super.increaseApproval(_spender, _addedValue);
  }
","  function approve(address _spender,uint256 _value)
    public
    whenNotPaused
    returns (bool)
  {
    return super.approve(_spender, _value);
  }
","0x5eb87caa0105a63aa87a36c7bd2573bd13e84fae/BQT.sol:PauseBurnableERC827Token:increaseApproval(address,uint256)","0x5eb87caa0105a63aa87a36c7bd2573bd13e84fae/BQT.sol:PauseBurnableERC827Token:approve(address,uint256)",1.0,5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_setNetwork() internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[2])",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_setNetwork(),0.8,2,2,0
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
","    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }
","0x5bd574410f3a2da202babba1609330db02ad64c2/VerifyToken.sol:VerifyToken:approve(address,uint256)",0x5bd574410f3a2da202babba1609330db02ad64c2/VerifyToken.sol:VerifyToken:totalSupply(),0.060317460317460325,2,2,0
"  function balanceOf(address who) constant returns (uint){
    if (deprecated) {
      return StandardToken(upgradedAddress).balanceOf(who);
    } else {
      return super.balanceOf(who);
    }
  }
","  function deprecate(address _upgradedAddress) onlyOwner {
    deprecated = true;
    upgradedAddress = _upgradedAddress;
    Deprecate(_upgradedAddress);
  }
",0x3c4ce67bf86601921557f8a13864a9069d56389f/TetherToken.sol:TetherToken:balanceOf(address),0x3c4ce67bf86601921557f8a13864a9069d56389f/TetherToken.sol:TetherToken:deprecate(address),0.75,2,2,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x7f121d4ec6c2c07eb6bc7989d91d2d4ff654c068/CoinMeet.sol:StandardToken:transfer(address,uint256)",0x7f121d4ec6c2c07eb6bc7989d91d2d4ff654c068/CoinMeet.sol:StandardToken:balanceOf(address),0.9776632302405498,5,5,1
"  function removeManyFromWhitelist(address[] _beneficiaries) external onlyBy(kycAdmin) {
    for (uint256 i = 0; i < _beneficiaries.length; i++) removeFromWhitelist(_beneficiaries[i]);
  }
","  function tokensToWei(uint256 _tokenAmount) public view returns (uint256) {
    require(tokenNAVMicroUSD != uint256(0));
    require(weiPerUSD != uint256(0));
    return _tokenAmount.mul(tokenNAVMicroUSD).mul(weiPerUSD).div(million);
  }
",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:removeManyFromWhitelist(address[]),0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:tokensToWei(uint256),0.5,2,2,0
"    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused
        returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
","    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused
        returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:MentalHealthLifeToken:increaseApproval(address,uint256)","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:MentalHealthLifeToken:decreaseApproval(address,uint256)",1.0,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x0b08b0b558a2ff86860c4bd55f69aefbf4f50e50/HYCCrowdsaleICO.sol:SafeMath:mul(uint256,uint256)","0x0b08b0b558a2ff86860c4bd55f69aefbf4f50e50/HYCCrowdsaleICO.sol:SafeMath:div(uint256,uint256)",0.6934189406099518,2,2,0
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }
",0x7bcbf788c3b5c86298198d2a974db70fa76a0eb2/XEN.sol:XEN:withdrawForeignTokens(address),0x7bcbf788c3b5c86298198d2a974db70fa76a0eb2/XEN.sol:XEN:disableWhitelist(address[]),0.3114754098360656,2,2,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8/COSHATokenHKD.sol:COSHATokenHKD:approveAndCall(address,uint256,bytes)","0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8/COSHATokenHKD.sol:COSHATokenHKD:transfer(address,uint256)",0.7145708582834331,2,2,0
"    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {
        if (balanceOf(msg.sender) < _value) revert();
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
","    function OWN_kill() onlyOwner public { 
		selfdestruct(owner); 
    }
","0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:transferToAddress(address,uint256,bytes)",0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:OWN_kill(),0.0,2,2,0
"    function DSAuth() {
        owner = msg.sender;
        LogSetOwner(msg.sender);
    }
","    function setAuthority(DSAuthority authority_)
        auth
    {
        authority = authority_;
        LogSetAuthority(authority);
    }
",0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSAuth:DSAuth(),0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSAuth:setAuthority(DSAuthority),1.0,5,5,1
"    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].ssub(_value);
        totalSupply = totalSupply.ssub(_value);
        Burn(burner, _value);
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
",0x1dcaef208411119ed3d2527d1a2e724f0e3a07cc/SilkrouteCoin.sol:SilkrouteCoin:burn(uint256),"0x1dcaef208411119ed3d2527d1a2e724f0e3a07cc/SilkrouteCoin.sol:SilkrouteCoin:approve(address,uint256)",0.041666666666666664,2,2,0
"    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","    modifier onlyPayloadSize(uint size) {
        require(msg.data.length >= size + 4);
        _;
    }
","0x7a4033a93885247a4292988a3c0c0e3c1cf55721/Airdroster.sol:Airdroster:allowance(address,address)",0x7a4033a93885247a4292988a3c0c0e3c1cf55721/Airdroster.sol:Airdroster:onlyPayloadSize(uint256),0.04549319727891157,2,2,0
"    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
        if (newOwner != address(0)) {
          owner = newOwner;
        }
    }
","    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
",0x8b6899e4b32729cba03f8f9c8e46628cadd03158/RedTicket.sol:owned:transferOwnership(address),0x8b6899e4b32729cba03f8f9c8e46628cadd03158/RedTicket.sol:owned:onlyOwner(),0.875,2,2,0
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x1fe4e0811a09e3be95f18a6f6aba8c4852e4d19e/AirDropForERC223.sol:SafeMath:div(uint256,uint256)","0x1fe4e0811a09e3be95f18a6f6aba8c4852e4d19e/AirDropForERC223.sol:SafeMath:sub(uint256,uint256)",0.9890410958904108,5,5,1
"    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner]; 
    }
","0x8ac77770de6a3b690e9f3ec368fb64ba3c112cdd/CrowdToken.sol:CrowdToken:mul(uint256,uint256)",0x8ac77770de6a3b690e9f3ec368fb64ba3c112cdd/CrowdToken.sol:CrowdToken:balanceOf(address),0.0006557377049180327,2,2,0
"    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {

        // Only allow transfer once unlocked
        // Once it is unlocked, it is unlocked forever and no one can lock again
        require(unlocked);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
",0x02dbe2f315e059743376abcd22ab4908ea9fb02d/EDOGE.sol:EDOGE:balanceOf(address),"0x02dbe2f315e059743376abcd22ab4908ea9fb02d/EDOGE.sol:EDOGE:transfer(address,uint256,bytes)",0.011122345803842264,2,2,0
"	function	setPI_edit_33	(	string	newPI_edit_33	)	public	onlyOwner	{	
		inPI_edit_33	=	newPI_edit_33	;					
	}									
","	function	PI_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_33(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:PI_EDIT_1(),0.3333333333333333,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[2])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)",1.0,5,5,1
"    function _isContract(address _user) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_user) }
        return size > 0;
    }
","    function getMyEggs() public view returns(uint256){
        return SafeMath.add(claimedEggs[msg.sender],getEggsSinceLastHatch(msg.sender));
    }
",0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:_isContract(address),0x7d7238460fbc191d512fe11b35af8e4d56df12ff/Halo3DShrimpFarmer.sol:Halo3DShrimpFarmer:getMyEggs(),0.25,2,2,0
"    modifier notExecuted(uint transactionId) {
        require(!transactions[transactionId].executed);
        _;
    }
","    function isConfirmed(uint transactionId)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++) {
            if (confirmations[transactionId][owners[i]])
                count += 1;
            if (count == required)
                return true;
        }
    }
",0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notExecuted(uint256),0x5acbe8b82bec243f420214b35ed5b6cad2055f07/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:isConfirmed(uint256),1.0,5,5,1
"    function SnailChain() {
        balanceOf[msg.sender] =  3681391186 * 1000000000000000000;              // Give the creator all initial tokens
        totalSupply =  3681391186 * 1000000000000000000;                        // Update total supply
        name = ""SnailChain"";                                   // Set the name for display purposes
        symbol = ""SNL"";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x7ecbcdef9ae2f5dce8a2e3b5de9ccfb9a11fd699/SnailChain.sol:SnailChain:SnailChain(),"0x7ecbcdef9ae2f5dce8a2e3b5de9ccfb9a11fd699/SnailChain.sol:SnailChain:approveAndCall(address,uint256,bytes)",1.0,5,5,1
"    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }
","    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }
",0x5dcec81f0b08229f866acd3cf814f7e0be3584e0/Presale.sol:Presale:abort(),0x5dcec81f0b08229f866acd3cf814f7e0be3584e0/Presale.sol:Presale:sendRefund(),0.6666666666666666,2,2,0
"    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
","    function setName(string _name) isOwner {
        name = _name;
    }
","0x7c833af22bd7da8ad29541c35230d1c822e23889/EthchangeToken.sol:EthchangeToken:transfer(address,uint256)",0x7c833af22bd7da8ad29541c35230d1c822e23889/EthchangeToken.sol:EthchangeToken:setName(string),0.4827586206896552,2,2,0
"    function balanceOf(address _owner) public constant returns (uint256 balance) 
        {
            return balanceOf[_owner];
        }
","    function setTransferStatus (uint status) public  onlyOwner                 // Set transfer status
    {
        allowTransferToken = status;
    }   
",0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:balanceOf(address),0x3bb831e1ae1b9abacb2e9626994483e0b3759c1c/PGM_Coin.sol:PGM_Coin:setTransferStatus(uint256),0.02325581395348837,2,2,0
"    constructor() public {
        owner = msg.sender;
    }
","    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
",0x3a566d7507f8e594f4d41e9086692b04d5f71722/TokenVesting.sol:Ownable:constructor(),0x3a566d7507f8e594f4d41e9086692b04d5f71722/TokenVesting.sol:Ownable:transferOwnership(address),0.30851063829787234,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string,string)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",1.0,5,5,1
"  function safeAdd (uint256 x, uint256 y)
  constant internal
  returns (uint256 z) {
    assert (x <= MAX_UINT256 - y);
    return x + y;
  }
","  function safeMul (uint256 x, uint256 y)
  constant internal
  returns (uint256 z) {
    if (y == 0) return 0; // Prevent division by zero at the next line
    assert (x <= MAX_UINT256 / y);
    return x * y;
  }
","0x5c790caf8d45cf339362a78fc56ba9e3cf2aa6a0/CGCoinToken.sol:SafeMath:safeAdd(uint256,uint256)","0x5c790caf8d45cf339362a78fc56ba9e3cf2aa6a0/CGCoinToken.sol:SafeMath:safeMul(uint256,uint256)",0.9333333333333332,5,5,1
"    function MOVE(
    ) public {
        totalSupply = 65000000000000000000000000;                     // Update total supply with the decimal amount
        balanceOf[msg.sender] = 65000000000000000000000000;           // Give the creator all initial tokens
        name = ""Movement"";                                   // Set the name for display purposes
        symbol = ""MOVE"";                                        // Set the symbol for display purposes
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
",0x3b2fb396506242938d04302b00dfe4472c3f83c5/MOVE.sol:MOVE:MOVE(),"0x3b2fb396506242938d04302b00dfe4472c3f83c5/MOVE.sol:MOVE:_transfer(address,address,uint256)",1.0,5,5,1
"    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
","    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","0x4e73b59501ecfdb75f5ffafa6d58c75c9fcc6ab0/omsairam18.sol:SafeMath:safeAdd(uint256,uint256)","0x4e73b59501ecfdb75f5ffafa6d58c75c9fcc6ab0/omsairam18.sol:SafeMath:safeSub(uint256,uint256)",0.948,5,5,1
"    function isAddressVerified(address _address) public view returns (bool) {
        return verifiedAddresses[_address];
    }
","    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{
        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);
    }
",0x2f0a1bd676e786f9dd5543697341e717a4af61c7/KycContract.sol:KycContract:isAddressVerified(address),"0x2f0a1bd676e786f9dd5543697341e717a4af61c7/KycContract.sol:KycContract:salvageTokensFromContract(address,address,uint256)",0.3333333333333333,2,2,0
"    function setFundManagementContract(address _contractAddress){
        if (msg.sender != curator) throw;
        fundManagementContract = IFundManagement(_contractAddress);
    }
","    function killContract(){
        if (msg.sender != dev) throw;
        selfdestruct(dev);
    }
",0x4DBADd62F3f0d87265740bc0566D8DaE9E21c000/MacroTokenContract.sol:MacroTokenContract:setFundManagementContract(address),0x4DBADd62F3f0d87265740bc0566D8DaE9E21c000/MacroTokenContract.sol:MacroTokenContract:killContract(),1.0,5,5,1
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  function Ownable() {
    owner = msg.sender;
  }
",0x7f288ff5a8055f5f6103a80dd806cf8415e035c7/CFC.sol:Ownable:transferOwnership(address),0x7f288ff5a8055f5f6103a80dd806cf8415e035c7/CFC.sol:Ownable:Ownable(),0.8385481852315394,2,2,0
"	function setImageData(uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		BdpImage.setImageData(contracts, _imageId, _part, _imageData);
	}
","	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageBlurredAt(_imageId);
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:setImageData(uint256,uint16,uint256[])",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getImageBlurredAt(uint256),1.0,5,5,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x1b58b07b5989a614baace9d58ab123cce91e2436/PowerLinkToken.sol:StandardToken:transfer(address,uint256)","0x1b58b07b5989a614baace9d58ab123cce91e2436/PowerLinkToken.sol:StandardToken:allowance(address,address)",0.2608695652173913,2,2,0
" modifier canTransfer() {
   if(!released) {
      require(msg.sender == crowdsaleAgent);
   }
   _;
 }
"," function approve(address _spender, uint _value) returns (bool success) {
   // To change the approve amount you first have to reduce the addresses`
   //  allowance to zero by calling `approve(_spender, 0)` if it is not
   //  already 0 to mitigate the race condition described here:
   //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   require ((_value == 0) || (allowed[msg.sender][_spender] == 0));

   allowed[msg.sender][_spender] = _value;
   Approval(msg.sender, _spender, _value);
   return true;
 }
",0x2fa32a39fc1c399e0cc7b2935868f5165de7ce97/PayFairToken.sol:PayFairToken:canTransfer(),"0x2fa32a39fc1c399e0cc7b2935868f5165de7ce97/PayFairToken.sol:PayFairToken:approve(address,uint256)",1.0,5,5,1
"	function	setPI_edit_15	(	string	newPI_edit_15	)	public	onlyOwner	{	
		inPI_edit_15	=	newPI_edit_15	;					
	}									
","	function	getPI_edit_24	()	public	constant	returns	(	string	)	{
		return	inPI_edit_24	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_15(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_24(),1.0,5,5,1
"		function	setData_12	(	string	newData_12	)	public	onlyOwner	{	
			inData_12	=	newData_12	;					
		}									
","		function	setData_6	(	string	newData_6	)	public	onlyOwner	{	
			inData_6	=	newData_6	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_12(string),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_6(string),1.0,5,5,1
"    modifier whenPaused() {
        require(paused);
        _;
    }
","    function setUnfreezeTimestamp(uint _unfreezeTimestamp) onlyOwner public {
        require(now < _unfreezeTimestamp);
        unfreezeTimestamp = _unfreezeTimestamp;
    }
",0x5b0751713b2527d7f002c0c4e2a37e1219610a6b/HorseToken.sol:Pausable:whenPaused(),0x5b0751713b2527d7f002c0c4e2a37e1219610a6b/HorseToken.sol:Pausable:setUnfreezeTimestamp(uint256),0.003401360544217687,2,2,0
"    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), WAD / 2) / WAD;
    }
","    function max(uint x, uint y) internal pure returns (uint z) {
        return x >= y ? x : y;
    }
","0x1aa8e830993eac9a0cc050c11df7f745d48bd5e7/DSToken.sol:DSMath:wmul(uint256,uint256)","0x1aa8e830993eac9a0cc050c11df7f745d48bd5e7/DSToken.sol:DSMath:max(uint256,uint256)",1.0,5,5,1
"  function safeSub(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }
","  function safeAdd(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }
","0x0b1724cc9fda0186911ef6a75949e9c0d3f0f2f3/CrowdsaleToken.sol:SafeMathLib:safeSub(uint256,uint256)","0x0b1724cc9fda0186911ef6a75949e9c0d3f0f2f3/CrowdsaleToken.sol:SafeMathLib:safeAdd(uint256,uint256)",0.08695652173913042,2,2,0
"   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
    }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }
","0x4E75BA0F03f62De979169f776951f911942be10A/STLToken.sol:STLToken:increaseApproval(address,uint256)","0x4E75BA0F03f62De979169f776951f911942be10A/STLToken.sol:STLToken:decreaseApproval(address,uint256)",1.0,5,5,1
"    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
","    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","0x1b413506fc42e2f04a4e8c57710f850b234d6653/EpiphanyCoin.sol:TokenERC20:_transfer(address,address,uint256)","0x1b413506fc42e2f04a4e8c57710f850b234d6653/EpiphanyCoin.sol:TokenERC20:approve(address,uint256)",0.8989637305699482,2,2,0
"  function lockBalance(address _userAddress, uint _amount) public isRelay {
    require(_amount > 0);
    require(balances[_userAddress] >= _amount);

    // subtract the tokens from the user's balance
    balances[_userAddress] = balances[_userAddress].sub(_amount);

    // add the tokens to the user's locked balance
    lockedBalances[_userAddress] = lockedBalances[_userAddress].add(_amount);

    LockedBalance(_userAddress, _amount);
  }
","  function unlockBalance(address _userAddress, uint _amount) public isRelay {
    require(_amount > 0);
    require(lockedBalances[_userAddress] >= _amount);

    // subtract the tokens from the user's locked balance
    lockedBalances[_userAddress] = lockedBalances[_userAddress].sub(_amount);

    // add the tokens to the user's  balance
    balances[_userAddress] = balances[_userAddress].add(_amount);

    UnlockedBalance(_userAddress, _amount);
  }
","0x8b5b525e2d4b279c603408726231c39c63f15d0b/Ethbet.sol:Ethbet:lockBalance(address,uint256)","0x8b5b525e2d4b279c603408726231c39c63f15d0b/Ethbet.sol:Ethbet:unlockBalance(address,uint256)",1.0,5,5,1
"    function hasEnded() public constant returns (bool) {
        return block.number >= endBlock;
    }
","    function setEndBlock(uint256 _endBlock) onlyOwner public {
        endBlock = _endBlock;
    }
",0x5beeC0Cf71d30ED317979917896C677f3701A1c6/FaradTokenSwap.sol:FaradTokenSwap:hasEnded(),0x5beeC0Cf71d30ED317979917896C677f3701A1c6/FaradTokenSwap.sol:FaradTokenSwap:setEndBlock(uint256),0.6666666666666666,2,2,0
"    function QTB(string _symbol,string _name,address _owner) {
        symbol=_symbol;
        name=_name;
        owner=_owner;
    }
","    function transferFrom(address src, address dst, uint wad)stoppable returns (bool) {
        assert(_balances[src] >= wad);
        assert(_approvals[src][msg.sender] >= wad);

        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);
        _balances[src] = sub(_balances[src], wad);
        _balances[dst] = add(_balances[dst], wad);

        Transfer(src, dst, wad);

        return true;
    }
","0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:QTB(string,string,address)","0x1e8c423b2e8aae409280c696c5acda62f7e6f23c/QTB.sol:QTB:transferFrom(address,address,uint256)",1.0,5,5,1
"   modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
","   function Ownable() {
    owner = msg.sender;
  }
",0x007a422fd7e5b47dd2cb078f250388b406548cd4/BLTTokenSale.sol:Ownable:onlyOwner(),0x007a422fd7e5b47dd2cb078f250388b406548cd4/BLTTokenSale.sol:Ownable:Ownable(),0.4556661925082978,2,2,0
"	function	setPI_edit_8	(	string	newPI_edit_8	)	public	onlyOwner	{	
		inPI_edit_8	=	newPI_edit_8	;					
	}									
","	function	getPI_edit_30	()	public	constant	returns	(	string	)	{
		return	inPI_edit_30	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_8(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_30(),1.0,5,5,1
"    function ba2cbor(bytes[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:ba2cbor(bytes[]),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[5])",1.0,5,5,1
"  function transferTokensFromContract(address _to, uint256 _amount) private {

    token_balance[traded_token] = token_balance[traded_token].sub(_amount);

    require(Token(traded_token).transfer(_to,_amount));
     
  }
","  function complete_sell_exchange(uint256 _amount_give) private {

    uint256 amount_get_ = get_amount_sell(_amount_give);

    require(amount_get_ < token_balance[base_token]);
    
    uint256 amount_get_minus_fee_ = get_amount_minus_fee(amount_get_);
    
    uint256 admin_fee = amount_get_ - amount_get_minus_fee_;

    transferTokensThroughProxyToContract(msg.sender,this,_amount_give);

    transferETHFromContract(msg.sender,amount_get_minus_fee_);  
    
    transferETHFromContract(admin, admin_fee);     
      
  }
","0x7c3d358e937a8c544a93854ce3f6e80e50d27b66/BancorKillerContract.sol:BancorKillerContract:transferTokensFromContract(address,uint256)",0x7c3d358e937a8c544a93854ce3f6e80e50d27b66/BancorKillerContract.sol:BancorKillerContract:complete_sell_exchange(uint256),0.0,2,2,0
"	modifier when_owns(address _owner, uint _amount) {
		require (accounts[_owner].balance >= _amount);
		_;
	}
","	function mint(address _who, uint _value)
		only_owner
		public
	{
		accounts[_who].balance += _value;
		totalSupply += _value;
		Minted(_who, _value);
	}
","0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:when_owns(address,uint256)","0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:mint(address,uint256)",1.0,5,5,1
"    function signedTransferFrom(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        require(self.transferable);
        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);
        require(spender != address(0) && spender == ecrecoverFromSig(keccak256(signingPrefix, hash), sig));
        require(!self.accountLocked[from]);
        require(self.nextNonce[spender] == nonce);
        self.nextNonce[spender] = nonce + 1;
        self.balances[from] = safeSub(self.balances[from], tokens);
        self.allowed[from][spender] = safeSub(self.allowed[from][spender], tokens);
        self.balances[to] = safeAdd(self.balances[to], tokens);
        Transfer(from, to, tokens);
        self.balances[from] = safeSub(self.balances[from], fee);
        self.allowed[from][spender] = safeSub(self.allowed[from][spender], fee);
        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);
        Transfer(from, feeAccount, fee);
        return true;
    }
","    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:signedTransferFrom(BTTSLib:Data,address,address,address,uint256,uint256,uint256,bytes,address)","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSLib:safeDiv(uint256,uint256)",1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x3e9215646412299fbe35e45427b4e8618929c75a/IBCToken.sol:IBCToken:transferFrom(address,address,uint256)","0x3e9215646412299fbe35e45427b4e8618929c75a/IBCToken.sol:IBCToken:burnFrom(address,uint256)",0.8538283062645011,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
","0x3e9215646412299fbe35e45427b4e8618929c75a/IBCToken.sol:IBCToken:transferFrom(address,address,uint256)","0x3e9215646412299fbe35e45427b4e8618929c75a/IBCToken.sol:IBCToken:burnFrom(address,uint256)",0.8538283062645011,2,2,0
"	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}
","	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}
",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:getRegionCoordinates(uint256),"0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpDataStorage:setRegionCurrentImageId(uint256,uint256)",1.0,5,5,1
"	function sell(uint256 amount) public {
	    logic.sell(this,msg.sender, amount);
	}
","	function transfer(address _to, uint256 _value) public {
	    if (logic.transfer(msg.sender, _to, _value) == true) {
	        emit Transfer(msg.sender, _to, _value);
	    }
	}
",0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a/BitSTDView.sol:BitSTDView:sell(uint256),"0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a/BitSTDView.sol:BitSTDView:transfer(address,uint256)",0.0,4,4,0
"    function enableRefunds() onlyOwner public {
        require(state == State.Active);
        state = State.Refunding;
        RefundsEnabled();
    }
","    function refund(address investor) public {
        require(state == State.Refunding);
        uint256 depositedValue = deposited[investor];
        deposited[investor] = 0;
        investor.transfer(depositedValue);
        Refunded(investor, depositedValue);
    }
",0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:VLBRefundVault:enableRefunds(),0x2cbc6812cff0b1113bf2808ffce6d83b97afd345/VLBRefundVault.sol:VLBRefundVault:refund(address),0.8666666666666667,2,2,0
"    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[],uint256)",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_useCoupon(string),0.6,2,2,0
"    function LIZAToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }
","    function totalSupply()
        public
        view
        returns (uint256) {
        return _totalSupply;
    }
","0x3b7712b395bc5f7f7fb6976ea4827377e77adab6/LIZAToken.sol:LIZAToken:LIZAToken(string,string,uint8,uint256)",0x3b7712b395bc5f7f7fb6976ea4827377e77adab6/LIZAToken.sol:LIZAToken:totalSupply(),0.6428571428571429,2,2,0
"    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[5],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",1.0,5,5,1
"  function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
","  function symbol () public pure returns (string result) {
    return ""PON"";
  }
","0x4cf6666922c8f1af0011282b3825f24003c473d3/PonderGoldToken.sol:PonderGoldToken:transferFrom(address,address,uint256)",0x4cf6666922c8f1af0011282b3825f24003c473d3/PonderGoldToken.sol:PonderGoldToken:symbol(),0.8571428571428571,2,2,0
"    function SexyMore() public {
        symbol = ""SEXX"";
        name = ""SexyMore"";
        decimals = 3;
        totalSupply = 11000000;
        balances[0x7BF52Cb1a7875d3523e30C341Caeb72C5f7b4669] = totalSupply;
        Transfer(address(0), 0x7BF52Cb1a7875d3523e30C341Caeb72C5f7b4669, totalSupply);
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
",0x7bbcb1147050e09040e66f157386f029aec6cd80/SexyMore.sol:SexyMore:SexyMore(),"0x7bbcb1147050e09040e66f157386f029aec6cd80/SexyMore.sol:SexyMore:approve(address,uint256)",0.5,2,2,0
"    function initialize(address _address) internal returns (bool success) {
        if (_airdropTotal <= _airdropSupply && !initialized[_address]) {
            initialized[_address] = true;
            balances[_address] = _airdropAmount;
            _airdropTotal = _airdropTotal.add(_airdropAmount);
        }
        return true;
    }
","    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x5da1ae58900514cbae8b03a05bd2e8e71de7e6a1/AOT.sol:AOT:initialize(address),"0x5da1ae58900514cbae8b03a05bd2e8e71de7e6a1/AOT.sol:AOT:allowance(address,address)",1.0,5,5,1
"  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x7b39940dbac110f1227d37c395675def270afcd7/EOSGoldToken.sol:StandardToken:decreaseApproval(address,uint256)","0x7b39940dbac110f1227d37c395675def270afcd7/EOSGoldToken.sol:StandardToken:allowance(address,address)",0.9501779359430604,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x3cda321291949b3e0f2e8cc2d5ba9cfbfdbaf049/EGCToken.sol:SafeMath:sub(uint256,uint256)","0x3cda321291949b3e0f2e8cc2d5ba9cfbfdbaf049/EGCToken.sol:SafeMath:mul(uint256,uint256)",0.9659477866061292,5,5,1
"  function tokensOf(address _owner) public view returns (uint256[]) {
    return ownedTokens[_owner];
  }
","  function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
",0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:tokensOf(address),0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:takeOwnership(uint256),0.75,2,2,0
"    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
",0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:onlyOwner(),0x3f9c0a5773817ffaa5a1061e1e33c1d9c8888dff/Noblebit.sol:Noblebit:transferOwnership(address),0.15979137031768612,2,2,0
"    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) {
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
","    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);
        require (balanceOf[_from] >= _value);
        require (balanceOf[_to] + _value >= balanceOf[_to]);
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
","0x5B5D0fbBd75d4501E5CDc854c445fb0eABcB0AFc/EmrCrowdfund.sol:EmrCrowdfund:burnFrom(address,uint256)","0x5B5D0fbBd75d4501E5CDc854c445fb0eABcB0AFc/EmrCrowdfund.sol:EmrCrowdfund:_transfer(address,address,uint256)",1.0,5,5,1
"    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78/TASOHATOKEN.sol:TASOHATOKEN:approve(address,uint256)","0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78/TASOHATOKEN.sol:TASOHATOKEN:transferFrom(address,address,uint256)",0.7991543340380549,2,2,0
"  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }
","  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
",0x8af311bcfcb0f7cccb729f1459328667d06b3c57/BSPCP.sol:BasicToken:balanceOf(address),0x8af311bcfcb0f7cccb729f1459328667d06b3c57/BSPCP.sol:BasicToken:totalSupply(),0.5871794871794872,2,2,0
"    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[2],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[3])",1.0,5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function KNUCK(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","0x04f6c927da7bb1e5c7b793f80406020db3771a9a/KNUCK.sol:KNUCK:approveAndCall(address,uint256,bytes)","0x04f6c927da7bb1e5c7b793f80406020db3771a9a/KNUCK.sol:KNUCK:KNUCK(uint256,string,string)",0.4251497005988024,2,2,0
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x4c663810a43df0c6259b8dd286d5064c12c3032f/NamoToken.sol:StandardToken:increaseApproval(address,uint256)","0x4c663810a43df0c6259b8dd286d5064c12c3032f/NamoToken.sol:StandardToken:transferFrom(address,address,uint256)",0.7617283950617284,2,2,0
"	function finalise()
		only_owner
		public
	{
		locked = false;
		owner = 0;
		phaseStart = now;
	}
","	function balanceOf(address _who) constant returns (uint256) {
		return accounts[_who].balance;
	}
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:finalise(),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmberToken:balanceOf(address),1.0,5,5,1
"	function regionsIsPurchased(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionPurchasedAt(_regionId) > 0;
	}
","	function calculateCurrentMarketPixelPrice() view public returns(uint) {
		return BdpCalculator.calculateCurrentMarketPixelPrice(contracts);
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:regionsIsPurchased(uint256),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:calculateCurrentMarketPixelPrice(),0.5,2,2,0
"    function burn(uint256 _value) returns (bool success) {
        if (balances[msg.sender] < _value) return false; 
        balances[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }
","    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balances[_from] < _value) return false;
        if (_value > allowed[_from][msg.sender]) return false;
        balances[_from] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
",0x8b6899e4b32729cba03f8f9c8e46628cadd03158/RedTicket.sol:RedTicket:burn(uint256),"0x8b6899e4b32729cba03f8f9c8e46628cadd03158/RedTicket.sol:RedTicket:burnFrom(address,uint256)",0.2,2,2,0
"    function assert(bool assertion) internal {
        if (!assertion) {
            revert();
        }
    }
","    function min256(uint256 a, uint256 b) internal constant returns (uint256) {
        return a < b ? a : b;
    }
",0x7dce85240d178ae61e91aa82ecdc2048d1ca052f/META.sol:META:assert(bool),"0x7dce85240d178ae61e91aa82ecdc2048d1ca052f/META.sol:META:min256(uint256,uint256)",0.5714285714285714,2,2,0
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x3d1fb9e4fe508d27f9d47c903f3ad3a47de8dcf8/AATokenPrivatesale.sol:Ownable:transferOwnership(address),0x3d1fb9e4fe508d27f9d47c903f3ad3a47de8dcf8/AATokenPrivatesale.sol:Ownable:onlyOwner(),0.9899749373433584,5,5,1
"    function symbol() public view returns (string) {
        return data.symbol;
    }
","    function mintable() public view returns (bool) {
        return data.mintable;
    }
",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:symbol(),0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:mintable(),0.5,2,2,0
"    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_useCoupon(string),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])",1.0,5,5,1
"  function div(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }
","  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:div(uint256,uint256)","0x04e7eefd4f5831409cd7fdd0821bde32d9c800c5/BitcoinGoldFund.sol:SafeMath:mul(uint256,uint256)",0.9583333333333334,5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
",0x1e9df32917117235ba0888edb2602ff3522834ec/MicroBTC.sol:MicroBTC:balanceOf(address),"0x1e9df32917117235ba0888edb2602ff3522834ec/MicroBTC.sol:MicroBTC:transferAnyERC20Token(address,uint256)",0.91875,5,5,1
"    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
",0x5eb3e0ac7d9642c09c2a9092c57d86a42a0577fc/PPY.sol:PPY:burn(uint256),"0x5eb3e0ac7d9642c09c2a9092c57d86a42a0577fc/PPY.sol:PPY:transferFrom(address,address,uint256)",0.8829039812646371,4,4,0
"    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","0x6f80d952ee3ccd5eb1630e3a26f74f0e178f7e91/RicoToken.sol:StandardToken:increaseApproval(address,uint256)","0x6f80d952ee3ccd5eb1630e3a26f74f0e178f7e91/RicoToken.sol:StandardToken:transferFrom(address,address,uint256)",0.7617283950617284,4,4,0
"	function	getPOOL_edit_1	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_1	;						
	}									
","	function	setPOOL_edit_5	(	string	newPOOL_edit_5	)	public	onlyOwner	{	
		inPOOL_edit_5	=	newPOOL_edit_5	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_1(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_5(string),1.0,5,5,1
"    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x4e84e9e5fb0a972628cf4568c403167ef1d40431/Fluzcoin.sol:Fluzcoin:allowance(address,address)",0x4e84e9e5fb0a972628cf4568c403167ef1d40431/Fluzcoin.sol:Fluzcoin:balanceOf(address),0.4974489795918368,4,4,0
"	function	setData_20	(	string	newData_20	)	public	onlyOwner	{	
		inData_20	=	newData_20	;					
	}									
","	function	getData_7	()	public	constant	returns	(	string	)	{
		return	inData_7	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_20(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_7(),1.0,5,5,1
"  function autoDistribute() payable public {
    require(distributeAmount > 0
            && balanceOf(owner) >= distributeAmount
            && frozenAccount[msg.sender] == false
            && now > unlockUnixTime[msg.sender]);
    if (msg.value > 0) owner.transfer(msg.value);
    
    balances[owner] = SafeMath.sub(balances[owner], distributeAmount);
    balances[msg.sender] = SafeMath.add(balances[msg.sender], distributeAmount);
    Transfer(owner, msg.sender, distributeAmount);
  }
","  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
    if (balanceOf(msg.sender) < _value) revert();
    balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value);
    balances[_to] = SafeMath.add(balanceOf(_to), _value);
    Transfer(msg.sender, _to, _value, _data);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x1ffd205d11b2e200fcc8908afd649cff256f16d0/LongLegs.sol:LongLegs:autoDistribute(),"0x1ffd205d11b2e200fcc8908afd649cff256f16d0/LongLegs.sol:LongLegs:transferToAddress(address,uint256,bytes)",1.0,5,5,1
"    function getOwner() external constant returns (address) {
        return owner;
    }
","    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(isBlackListed[_blackListedUser]);
        uint dirtyFunds = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        _totalSupply -= dirtyFunds;
        DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }
",0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:BlackList:getOwner(),0x2bc84136ade4882eb604e4c276c3a61a4e15617e/Clost.sol:BlackList:destroyBlackFunds(address),0.14285714285714285,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[3],uint256)",1.0,5,5,1
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) external {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
",0x3b433c2cfbcc7b78c59243714b1ca7498a2de70c/TrueToken.sol:TrueToken:withdrawForeignTokens(address),"0x3b433c2cfbcc7b78c59243714b1ca7498a2de70c/TrueToken.sol:TrueToken:adminClaimAirdropMultiple(address[],uint256)",0.016393442622950817,4,4,0
"    function balanceOf(address _owner) constant returns(uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns(bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x5a278520af82ecd29ab6ad6f132c7fd6865d6454/SupremeCoin.sol:SupremeCoin:balanceOf(address),"0x5a278520af82ecd29ab6ad6f132c7fd6865d6454/SupremeCoin.sol:SupremeCoin:transfer(address,uint256)",0.10667340748230536,4,4,0
"    function burn(uint num) public {
        require(num * 1e8 > 0);
        require(balances[msg.sender] >= num * 1e8);
        require(totalSupply >= num * 1e8);

        uint pre_balance = balances[msg.sender];

        balances[msg.sender] -= num * 1e8;
        totalSupply -= num * 1e8;
        Burnt(msg.sender, num * 1e8, totalSupply);
        Transfer(msg.sender, 0x0, num * 1e8);

        assert(balances[msg.sender] == pre_balance - num * 1e8);
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        // mitigates the ERC20 short address attack
        if(msg.data.length < (3 * 32) + 4) { throw; }

        if (_value == 0) { return false; }
        
        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;
            
            allowed[_from][msg.sender] -= _value;
            
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
",0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:burn(uint256),"0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:transferFrom(address,address,uint256)",1.0,5,5,1
"    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
","    function SuperNebulaChain(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:SuperNebulaChain:freezeAccount(address,bool)","0x3d113397839fd5107a16444990dba235994dd3b6/SuperNebulaChain.sol:SuperNebulaChain:SuperNebulaChain(uint256,string,string)",0.24630541871921185,2,2,0
"  function getMintDelegates() public view returns (address[]) {
    return mintDelegates;
  }
","  function revokeBurnDelegate(address _burnDelegate) onlyOwner public returns (bool) {
    uint length = burnDelegates.length;
    require(length > 0);

    address lastDelegate = burnDelegates[length-1];
    if(_burnDelegate == lastDelegate) {
      delete burnDelegates[length-1];
      burnDelegates.length--;
    }
    else {
      // Game plan: find the delegate, replace it with the very last item in the array, then delete the last item
      for(uint i=0; i<length; i++) {
        if(burnDelegates[i]==_burnDelegate) {
          burnDelegates[i] = lastDelegate;
          delete burnDelegates[length-1];
          burnDelegates.length--;
          break;
        }
      }
    }

    RevokeBurnDelegate(_burnDelegate);
    return true;
  }
",0x4eea6844a4dc5bf3127decf034b3f4a7211ef2e7/Trident.sol:Trident:getMintDelegates(),0x4eea6844a4dc5bf3127decf034b3f4a7211ef2e7/Trident.sol:Trident:revokeBurnDelegate(address),1.0,5,5,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","0x5b2073762788bee3434a804ebbbf3a801c3df82c/BuddyToken.sol:SafeMath:sub(uint256,uint256)","0x5b2073762788bee3434a804ebbbf3a801c3df82c/BuddyToken.sol:SafeMath:div(uint256,uint256)",0.20488081725312146,2,2,0
"    modifier notConfirmed(uint transactionId, address owner) {
        if (confirmations[transactionId][owner])
            throw;
        _;
    }
","    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }
","0x3fd9aba22521d9ee3202a43bb132816a17973d43/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:notConfirmed(uint256,address)",0x3fd9aba22521d9ee3202a43bb132816a17973d43/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:addOwner(address),1.0,5,5,1
"    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[4],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)",1.0,5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x0de1beed64aa3ca5f563a1ba585861748c352231/BioCoin.sol:BioCoin:balanceOf(address),"0x0de1beed64aa3ca5f563a1ba585861748c352231/BioCoin.sol:BioCoin:approveAndCall(address,uint256,bytes)",0.921875,5,5,1
"    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:transfer(address,uint256,bytes,string)","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:approve(address,uint256)",0.7058823529411765,4,4,0
"    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0));
        return ownedTokensCount[_owner];
    }
","    modifier canTransfer(uint256 _tokenId) {
        require(isApprovedOrOwner(msg.sender, _tokenId));
        _;
    }
",0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:balanceOf(address),0x4fece400c0d3db0937162ab44bab34445626ecfe/ETHero.sol:ERC721BasicToken:canTransfer(uint256),0.75,2,2,0
"  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    uint256 _allowance = allowed[_from][msg.sender];
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x0c9dbc3442f73c92c43bb7805358673839edd631/EtherLinkToken.sol:StandardToken:decreaseApproval(address,uint256)","0x0c9dbc3442f73c92c43bb7805358673839edd631/EtherLinkToken.sol:StandardToken:transferFrom(address,address,uint256)",0.1601423487544484,2,2,0
"    function nextRune(slice self, slice rune) internal returns (slice) {
        rune._ptr = self._ptr;

        if (self._len == 0) {
            rune._len = 0;
            return rune;
        }

        uint len;
        uint b;
        // Load the first byte of the rune into the LSBs of b
        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }
        if (b < 0x80) {
            len = 1;
        } else if(b < 0xE0) {
            len = 2;
        } else if(b < 0xF0) {
            len = 3;
        } else {
            len = 4;
        }

        // Check for truncated codepoints
        if (len > self._len) {
            rune._len = self._len;
            self._ptr += self._len;
            self._len = 0;
            return rune;
        }

        self._ptr += len;
        self._len -= len;
        rune._len = len;
        return rune;
    }
","    function join(slice self, slice[] parts) internal returns (string) {
        if (parts.length == 0)
            return """";

        uint length = self._len * (parts.length - 1);
        for(uint i = 0; i < parts.length; i++)
            length += parts[i]._len;

        var ret = new string(length);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        for(i = 0; i < parts.length; i++) {
            memcpy(retptr, parts[i]._ptr, parts[i]._len);
            retptr += parts[i]._len;
            if (i < parts.length - 1) {
                memcpy(retptr, self._ptr, self._len);
                retptr += self._len;
            }
        }

        return ret;
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:nextRune(strings:slice,strings:slice)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:strings:join(strings:slice,strings:slice[])",1.0,5,5,1
"    function unfreeze() public onlyOwner() {
        freezed = false;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
",0x06d2e67cffd1441d0afee128f60465a1a0a51df9/GVPE_Token.sol:Token:unfreeze(),"0x06d2e67cffd1441d0afee128f60465a1a0a51df9/GVPE_Token.sol:Token:approve(address,uint256)",0.0,2,2,0
"	function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
","	modifier onlyOwner() {
		if (msg.sender != owner) throw;
		_;
	}
",0x6b6e2eaa21b4545ce19b31dcfcb53da54513a6e6/Aircoins.sol:Aircoins:transferOwnership(address),0x6b6e2eaa21b4545ce19b31dcfcb53da54513a6e6/Aircoins.sol:Aircoins:onlyOwner(),0.0679304897314376,2,2,0
"    function query1(string _datasource, string _arg)
    payable
    returns (bytes32 _id) {
        return query1(0, _datasource, _arg, 200000);
    }
","    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return query(_timestamp, _datasource, _arg, _gaslimit);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query1(string,string)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query_withGasLimit(uint256,string,string,uint256)",1.0,5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
","0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:SafeMath:div(uint256,uint256)","0x0c24e3aa0fc411debf74f138674cf2066c2e0ace/FalconFarmer.sol:SafeMath:mul(uint256,uint256)",0.9870525514089872,5,5,1
"    function setTokenPrice (uint newTokenRate) public  onlyOwner               // Set one token price
    {
        icoTokenPrice = newTokenRate;
    }     
","  function burn(uint256 _value) public returns (bool success) 
      {
          require (balanceOf[msg.sender] > _value);                             // Check if the sender has enough
          balanceOf[msg.sender] -= _value;                                      // Subtract from the sender
          totalSupply -= _value;                                                // Updates totalSupply
          Burn(msg.sender, _value);
          return true;
      }
",0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:setTokenPrice(uint256),0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:burn(uint256),1.0,5,5,1
"    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
","    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:getCodeSize(address),0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_cbAddress(),0.6666666666666666,2,2,0
"  function Coin() JcashUpgradeableToken(msg.sender) {

    owner = msg.sender;
    contractAddress = address(this);
    //tokens are kept in contract address rather than owner
    balances[contractAddress] = totalSupply;
  }
","  function buyTokens() public payable returns(uint tokenAmount) {

    uint _tokenAmount;
    uint multiplier = (10 ** decimals);
    uint weiAmount = msg.value;

    require(isCrowdsaleOpen);
    //require(whitelistedAddress[msg.sender]);

    require(weiAmount >= minETH);
    require(weiAmount <= maxETH);

    _tokenAmount =  safeMul(weiAmount,multiplier) / pricePerToken;

    require(_tokenAmount > 0);

    //safe sub will automatically handle overflows
    tokensForPublicSale = safeSub(tokensForPublicSale, _tokenAmount);
    onSaleTokens = safeSub(onSaleTokens, _tokenAmount);
    balances[contractAddress] = safeSub(balances[contractAddress],_tokenAmount);
    //assign tokens
    balances[msg.sender] = safeAdd(balances[msg.sender], _tokenAmount);

    //send money to the owner
    require(owner.send(weiAmount));

    return _tokenAmount;

  }
",0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:Coin:Coin(),0x6ab36640474e10e27ed86fb009a488f68a5f269d/Coin.sol:Coin:buyTokens(),1.0,5,5,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
","    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
","0x7a00f353c4117f28fe50a1c2a43856b73cc60e4d/PO8Token.sol:SafeMath:div(uint256,uint256)","0x7a00f353c4117f28fe50a1c2a43856b73cc60e4d/PO8Token.sol:SafeMath:add(uint256,uint256)",0.9945205479452056,5,5,1
"    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];       
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[1],uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[])",1.0,5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
",0x1beef31946fbbb40b877a72e4ae04a8d1a5cee06/Parachute.sol:Parachute:totalSupply(),"0x1beef31946fbbb40b877a72e4ae04a8d1a5cee06/Parachute.sol:Parachute:transfer(address,uint256)",0.8540145985401459,2,2,0
"  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
",0x2c9023bbc572ff8dc1228c7858a280046ea8c9e5/VideoCoin.sol:BasicToken:totalSupply(),"0x2c9023bbc572ff8dc1228c7858a280046ea8c9e5/VideoCoin.sol:BasicToken:transfer(address,uint256)",0.8421052631578947,2,2,0
"   function Period() constant returns (uint) {
        return period;
    }
","    function Rate() constant returns (uint) {
        return rate;
    }
",0x6c849771d7b1c16ad3a2e63a1350659e63138d45/FolkCoin.sol:Crowdsale:Period(),0x6c849771d7b1c16ad3a2e63a1350659e63138d45/FolkCoin.sol:Crowdsale:Rate(),1.0,5,5,1
"    function unlock() onlyOwner {
        locked = false;
    }
","    function sell(address _to, uint256 _value) onlyOwner returns (bool) {
        if (balances[seller] >= _value && _value > 0) {
            balances[seller] = safeSub(balances[seller], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            Transfer(seller, _to, _value);

            tokensSold = safeAdd(tokensSold, _value);
            totalSales = safeAdd(totalSales, 1);
            Sell(seller, _to, _value);
            return true;
        } else return false;
    }
",0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:BsToken:unlock(),"0x7c457dffffdea37c790e9d96ce93b86b7606ad1e/SnovPresale.sol:BsToken:sell(address,uint256)",0.3333333333333333,2,2,0
"  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }
","  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }
","0x4a65fe2a50882e2411c6d177583f8a00eee2c95a/FRNCoin.sol:ReleasableToken:transferFrom(address,address,uint256)",0x4a65fe2a50882e2411c6d177583f8a00eee2c95a/FRNCoin.sol:ReleasableToken:releaseTokenTransfer(),0.3888888888888889,2,2,0
"	function	getPOOL_edit_12	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_12	;						
	}									
","	function	POOL_EDIT_2		()	public	{				
		owner	= msg.sender;							
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_12(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:POOL_EDIT_2(),0.0,2,2,0
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] -= _value;                           // Subtract from the sender
        balanceOf[_to] += _value;                             // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
        balanceOf[msg.sender] -= _value;                      // Subtract from the sender
        totalSupply -= _value;                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
","0x6e4d1ed3f7b5d7a4998b1116c1ef713e34f38e9a/ButenCoin.sol:ButenCoin:transferFrom(address,address,uint256)",0x6e4d1ed3f7b5d7a4998b1116c1ef713e34f38e9a/ButenCoin.sol:ButenCoin:burn(uint256),0.27884615384615385,2,2,0
"	function tokens_received() internal {
		uint256 previous_balance;
		for (uint8 i = 0; i < snapshots.length; i++) {
			previous_balance = previous_balance.add(snapshots[i].tokens_balance);
		}
		snapshots.push(Snapshot(token.balanceOf(address(this)).sub(previous_balance), const_contract_eth_value));
		rounds++;
	}
","	function set_token_address(address _token) onlyOwner {
		require(_token != 0x0);
		token = ERC20(_token);
	}
",0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:tokens_received(),0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:set_token_address(address),1.0,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x4eea6bdcf9dfca9e5b1daa01c2f6dae3f14ecf9b/TheophanesToken.sol:TheophanesToken:transfer(address,uint256)","0x4eea6bdcf9dfca9e5b1daa01c2f6dae3f14ecf9b/TheophanesToken.sol:TheophanesToken:transferAnyERC20Token(address,uint256)",0.9604743083003952,5,5,1
"    function FTWToken() public {
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = ""FutureWorks"";
        symbol = ""FTW"";
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            
        totalSupply = totalSupply.sub(_value);                      
        Burn(msg.sender, _value);
        return true;
    }
",0x5ab468e962637e4eecd6660f61b5b4a609e66e13/FTWToken.sol:FTWToken:FTWToken(),0x5ab468e962637e4eecd6660f61b5b4a609e66e13/FTWToken.sol:FTWToken:burn(uint256),0.04651162790697674,2,2,0
"    function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {
        require(_rate > 0);
        require(_wallet != address(0));
        require(_token != address(0));

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }
","    function buyTokens(address _beneficiary) public payable {

        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        weiRaised = weiRaised.add(weiAmount);

        _processPurchase(_beneficiary, tokens);
        emit TokenPurchase(
        msg.sender,
        _beneficiary,
        weiAmount,
        tokens
        );

        _updatePurchasingState(_beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(_beneficiary, weiAmount);
    }
","0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:Crowdsale:Crowdsale(uint256,address,ERC20)",0x2e6469e7e77797f8f3258b7cabb5bc5bc4cbc39a/LaraCrowdsale.sol:Crowdsale:buyTokens(address),0.9285714285714286,5,5,1
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x1ce0916e9bbec3958836ffcecf822495bc08596d/NelsonChenTestCoin.sol:NelsonChenTestCoin:approve(address,uint256)","0x1ce0916e9bbec3958836ffcecf822495bc08596d/NelsonChenTestCoin.sol:NelsonChenTestCoin:transfer(address,uint256)",0.3043478260869565,2,2,0
"    constructor() public {
        symbol = ""NKM""; 
        name = ""Nakama"";
        decimals = 18;
        _totalSupply = 10422698937 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
","    function start() public onlyOwner {
        stopped = false;
    }
",0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:constructor(),0x2ccf8d382c486327cd2a817f0c0ac911d65fbbf7/Nakama.sol:Nakama:start(),0.0,2,2,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function MIAMIcoin() public {
        symbol = ""MIA"";
        name = ""MIAMIcoin"";
        decimals = 18;
        _totalSupply = 305000000000000000000000000;
        balances[0x67754afaE8c7E041a2A347B5fb101B0e6000E705] = _totalSupply;
        Transfer(address(0), 0x67754afaE8c7E041a2A347B5fb101B0e6000E705, _totalSupply);
    }
","0x5ee9bf058b4deebf04756ca262c70232494783f0/MIAMIcoin.sol:MIAMIcoin:allowance(address,address)",0x5ee9bf058b4deebf04756ca262c70232494783f0/MIAMIcoin.sol:MIAMIcoin:MIAMIcoin(),0.2826747720364742,2,2,0
"	function transfer(address _to, uint256 _amount) notLocked(msg.sender, _amount) returns (bool success) {
		if (piecesOwned[msg.sender] >= _amount 
			&& _amount > 0
			&& piecesOwned[_to] + _amount > piecesOwned[_to]
			&& _to != 0x0)																// use burn() instead
			{
			piecesOwned[msg.sender] -= _amount;
			piecesOwned[_to] += _amount;
			Transfer(msg.sender, _to, _amount);
			return true;
			}
			else { return false;}
 		 }
","	function cancelSale () onlyBy (lowestAskAddress){
		if(pieceForSale && now > lowestAskTime + 86400) {
			pieceForSale = false;
			lowestAskPrice = 0;
			lowestAskAddress = 0x0;
			newLowestAsk (0, 0x0);
		}
		else {throw;}
	}
","0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:transfer(address,uint256)",0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:cancelSale(),0.1111111111111111,2,2,0
"    modifier ownerOnly {
        assert(msg.sender == owner);
        _;
    }
","    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
",0x1d4105534da120da243281cfc3f26aaf038e2d6f/YOOBAToken.sol:Owned:ownerOnly(),0x1d4105534da120da243281cfc3f26aaf038e2d6f/YOOBAToken.sol:Owned:acceptOwnership(),0.9375,5,5,1
"  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","0x7d90308abe79737191e7e169f768ee4ac57cbe3a/SphinxToken.sol:SafeMath:mul(uint256,uint256)","0x7d90308abe79737191e7e169f768ee4ac57cbe3a/SphinxToken.sol:SafeMath:add(uint256,uint256)",0.8940052128583841,5,5,1
"    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);
    }
","    function acceptOwnership() public {
        data.acceptOwnership();
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedTransferFromCheck(address,address,address,uint256,uint256,uint256,bytes,address)",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:acceptOwnership(),1.0,5,5,1
"    function transfer(address to, uint tokens) public returns (bool success) {
        return data.transfer(to, tokens);
    }
","    function unlockAccount(address tokenOwner) public {
        data.unlockAccount(tokenOwner);
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:transfer(address,uint256)",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:unlockAccount(address),1.0,5,5,1
"    function unpause() onlyOwner whenPaused public {
        paused = false;
        Unpause();
    }
","    modifier whenPaused() {
        require(paused);
        _;
    }
",0x0f90969738c7a3088907c052cb96bd4d184a9fcf/RISENCoin.sol:Pausable:unpause(),0x0f90969738c7a3088907c052cb96bd4d184a9fcf/RISENCoin.sol:Pausable:whenPaused(),0.9849624060150376,5,5,1
"    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
","    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
",0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:withdrawForeignTokens(address),0x4e7d9962b77131138a8bd194b212bdee23013128/CrystiumToken.sol:CrystiumToken:withdraw(),0.3606557377049181,2,2,0
"    function LitecoinEclipse() public {
        
        totalSupply = 1000000;                               // Update total supply with the decimal amount
        balanceOf[msg.sender] = 1000000;                    // Give the creator all initial tokens
        name = ""LitecoinEclipse"";                           // Set the name for display purposes
        symbol = ""LTE"";                                     // Set the symbol for display purposes
        decimals = 0;                                       // Amount of decimals for display purposes

    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
",0x4afeb9cce471e2cc0e98ebf6d0bbfc0142ddc6d0/LitecoinEclipse.sol:LitecoinEclipse:LitecoinEclipse(),"0x4afeb9cce471e2cc0e98ebf6d0bbfc0142ddc6d0/LitecoinEclipse.sol:LitecoinEclipse:approveAndCall(address,uint256,bytes)",0.8888888888888888,2,2,0
"    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:strConcat(string,string,string,string)",0.8,2,2,0
"    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x4DAe902c26EB05E910d6616c1845b259dF6E330f/DWorldCoin.sol:DWorldCoin:transfer(address,uint256)","0x4DAe902c26EB05E910d6616c1845b259dF6E330f/DWorldCoin.sol:DWorldCoin:approveAndCall(address,uint256,bytes)",0.8267898383371824,2,2,0
"    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }
",0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:getTokens(),"0x6f2ff926b18673c6ee59d8426fd4302958dfd694/PuexExchangeToken.sol:PuexExchangeToken:adminClaimAirdrop(address,uint256)",0.9047619047619048,2,2,0
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[4])",1.0,5,5,1
"    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

         if (balances[msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(msg.sender, _to, _amount);
             return true;
         } else {
             return false;
         }
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x3cd7047117dbfd0dcb470514172ace9f394c31e8/DEXToken.sol:DEXToken:transfer(address,uint256)","0x3cd7047117dbfd0dcb470514172ace9f394c31e8/DEXToken.sol:DEXToken:approve(address,uint256)",0.1320754716981132,2,2,0
"    modifier onlyMasterContract() {
        require(msg.sender == masterContractAddress);
        _;
    }
","    function takeOwnership(uint256 _tokenId) public {
        address newOwner = msg.sender;
        address oldOwner = tokenIndexToOwner[_tokenId];

        // Safety check to prevent against an unexpected 0x0 default.
        require(_addressNotNull(newOwner));

        // Making sure transfer is approved
        require(_approved(newOwner, _tokenId));

        _transfer(oldOwner, newOwner, _tokenId);
    }
",0x2dcd224a4c61489ff68717af79cc5553589ae74a/SportStarToken.sol:SportStarToken:onlyMasterContract(),0x2dcd224a4c61489ff68717af79cc5553589ae74a/SportStarToken.sol:SportStarToken:takeOwnership(uint256),0.0,2,2,0
"    function setOwner(address _owner) public {
        require(msg.sender == creator);
        owner = _owner;      
    }
","    function setEndtDate(uint256 _endDate) public {
        require(msg.sender == creator);
        endDate = _endDate;      
    }
",0x1b60fbf8cc8fe4d03da53f311387394baab8ada2/MGTCrowdsale.sol:MGTCrowdsale:setOwner(address),0x1b60fbf8cc8fe4d03da53f311387394baab8ada2/MGTCrowdsale.sol:MGTCrowdsale:setEndtDate(uint256),1.0,5,5,1
"  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) noEmergencyFreeze() public returns (bool success) {
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  modifier onlyOwner {
    require(msg.sender == owner);
     _;
  }
","0x1a9eb0f43ab4d9ffef9908b4d2c4b7f400ce3b3c/BITOToken.sol:BITOToken:transferFrom(address,address,uint256)",0x1a9eb0f43ab4d9ffef9908b4d2c4b7f400ce3b3c/BITOToken.sol:BITOToken:onlyOwner(),0.018867924528301886,4,4,0
"	function set_percent_reduction(uint256 _reduction) onlyOwner payable {
		require(bought_tokens && rounds == 0 && _reduction <= 100);
		percent_reduction = _reduction;
		if (msg.value > 0) {
			owner_supplied_eth = true;
		}
		const_contract_eth_value = const_contract_eth_value.sub((const_contract_eth_value.mul(_reduction)).div(100));
	}
","	function withdraw_my_tokens() {
		for (uint8 i = contributors[msg.sender].rounds; i < rounds; i++) {
			withdraw(msg.sender);
		}
	}
",0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:set_percent_reduction(uint256),0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:withdraw_my_tokens(),1.0,5,5,1
"    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
        // We do our own memory management here. Solidity uses memory offset
        // 0x40 to store the current end of memory. We write past it (as
        // writes are memory extensions), but don't update the offset so
        // Solidity will reuse it. The memory used here is only needed for
        // this context.

        // FIXME: inline assembly can't access return values
        bool ret;
        address addr;

        assembly {
            let size := mload(0x40)
            mstore(size, hash)
            mstore(add(size, 32), v)
            mstore(add(size, 64), r)
            mstore(add(size, 96), s)

            // NOTE: we can reuse the request memory because we deal with
            //       the return code
            ret := call(3000, 1, 0, size, 128, size, 32)
            addr := mload(size)
        }

        return (ret, addr);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[1])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:safer_ecrecover(bytes32,uint8,bytes32,bytes32)",0.8,4,4,0
"  function setDistributedAutonomousExchange(address _address) external onlyBy(owner) {
    distributedAutonomousExchange = _address;
  }
","  function setWeiPerUSD(uint256 _price) external onlyBy(navAdmin) {
    weiPerUSD = _price;
  }
",0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:setDistributedAutonomousExchange(address),0x0b6659a1a55c5038e34e8b0eeb9630c787466858/PentacoreCrowdsale.sol:PentacoreToken:setWeiPerUSD(uint256),1.0,5,5,1
"  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {
      if (depositingTokenFlag) {
        // Transfer was initiated from depositToken(). User token balance will be updated there.
        return true;
      } else {
        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent
        // with direct transfers of ECR20 and ETH.
        revert();
      }
  }
","  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    require((
      (orders[user][hash] || ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", hash), v, r, s) == user) &&
      block.number <= expires &&
      orderFills[user][hash].add(amount) <= amountGet
    ));
    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);
    orderFills[user][hash] = orderFills[user][hash].add(amount);
    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);
  }
","0x2f13fa06c0efd2a5c4cf2175a0467084672e648b/MarketPlace.sol:MarketPlace:tokenFallback(address,uint256,bytes)","0x2f13fa06c0efd2a5c4cf2175a0467084672e648b/MarketPlace.sol:MarketPlace:trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)",1.0,5,5,1
"  function balanceOf(address token, address user) constant returns (uint) {
    return tokens[token][user];
  }
","  function whiteListERC20(address _token) onlyAdmin {
    blackERC20[_token] = false;
  }
","0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:balanceOf(address,address)",0x02cc0390fA44dA7FE516B527d33d8A629c56F6E6/GenevExch.sol:GenevExch:whiteListERC20(address),0.0,4,4,0
"  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
","  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","0x4a8be691e324e6d1bad3f957e2538d7b427a9fca/SampleCrowdsale.sol:StandardToken:approve(address,uint256)","0x4a8be691e324e6d1bad3f957e2538d7b427a9fca/SampleCrowdsale.sol:StandardToken:transferFrom(address,address,uint256)",0.6604938271604939,4,4,0
"    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","0x5ae8cc13f4a20524303d6f92f6fe5574be3f1703/GambangCoin.sol:SafeMath:safeSub(uint256,uint256)","0x5ae8cc13f4a20524303d6f92f6fe5574be3f1703/GambangCoin.sol:SafeMath:safeDiv(uint256,uint256)",0.983402489626556,5,5,1
"	function purchaseTo(address _recipient)
		only_certified(msg.sender)
		payable
		public
	{
		processPurchase(_recipient);
	}
","	function processPurchase(address _recipient)
		only_during_period
		is_valid_buyin
		is_under_cap_with(msg.value)
		private
	{
		// Bounded value, see STANDARD_BUYIN.
		tokens.mint(_recipient, msg.value * STANDARD_BUYIN);
		TREASURY.transfer(msg.value);
		saleRevenue += msg.value;
		totalSold += msg.value * STANDARD_BUYIN;
		Purchased(_recipient, msg.value);
	}
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:purchaseTo(address),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:processPurchase(address),1.0,5,5,1
"    function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) {
      require(addresses.length > 0
              && addresses.length == amounts.length);

      uint256 totalAmount = 0;

      for (uint i = 0; i < addresses.length; i++) {
        require(amounts[i] > 0
                && addresses[i] != 0x0
                && frozenAccount[addresses[i]] == false
                && now > unlockUnixTime[addresses[i]]);

        amounts[i] = SafeMath.mul(amounts[i], 1e8);
        require(balances[addresses[i]] >= amounts[i]);
        balances[addresses[i]] = SafeMath.sub(balances[addresses[i]], amounts[i]);
        totalAmount = SafeMath.add(totalAmount, amounts[i]);
        Transfer(addresses[i], msg.sender, amounts[i]);
      }
        balances[msg.sender] = SafeMath.add(balances[msg.sender], totalAmount);
        return true;
      }
","    function symbol() public view returns (string _symbol) {
        return symbol;
    }
","0x4ef25326f1cd07ea6a03202f8fd1f29115a44bc2/MINATOKU.sol:MINATOKU:collectTokens(address[],uint256[])",0x4ef25326f1cd07ea6a03202f8fd1f29115a44bc2/MINATOKU.sol:MINATOKU:symbol(),1.0,5,5,1
"  function Ownable() {
    owner = msg.sender;
  }
","  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
",0x06dafc2a5fe47fcc9f37b5f91c0c2bd1cf2a9a4c/FlypCrowdsale.sol:Ownable:Ownable(),0x06dafc2a5fe47fcc9f37b5f91c0c2bd1cf2a9a4c/FlypCrowdsale.sol:Ownable:transferOwnership(address),0.6479690522243714,4,4,0
"    function balanceOf(address _owner) view public returns (uint256 balance) {
        return balances[_owner];
    }
","     function UCASH(

        ) public {
        totalSupply = 21*10**9*10**8;                        // Update total supply
        balances[msg.sender] = totalSupply;               // Give the creator all initial tokens
        name = ""UCASH"";                                   // Set the name for display purposes
        decimals = 8;                            // Amount of decimals for display purposes
        symbol = ""UCASH"";                               // Set the symbol for display purposes
    }
",0x0c27eb966fea5f8752bfee51e11db2c301a8cd87/UCASH.sol:UCASH:balanceOf(address),0x0c27eb966fea5f8752bfee51e11db2c301a8cd87/UCASH.sol:UCASH:UCASH(),0.0020222446916076846,4,4,0
"  function setStart(uint _start) public onlyOwner {
    start = _start;
  }
","  modifier isUnderHardCap() {
    require(multisigVault.balance + altDeposits <= hardcap);
    _;
  }
",0x01f0634272eca6c152a3be0eaf385bbdc5a49dc0/OMToken.sol:MainSale:setStart(uint256),0x01f0634272eca6c152a3be0eaf385bbdc5a49dc0/OMToken.sol:MainSale:isUnderHardCap(),0.5,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","    modifier isLock {
        require(!lock);
        _;
    }
","0x4e25ab55f79a9776c3737ef8902fac1c5ca8276e/Angel.sol:Angel:transferFrom(address,address,uint256)",0x4e25ab55f79a9776c3737ef8902fac1c5ca8276e/Angel.sol:Angel:isLock(),0.023201856148491882,4,4,0
"  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  function Ownable() {
    owner = msg.sender;
  }
",0x5c9b946905a68fa6a3f8fddb726f62990fc2cec3/SRTToken.sol:Ownable:transferOwnership(address),0x5c9b946905a68fa6a3f8fddb726f62990fc2cec3/SRTToken.sol:Ownable:Ownable(),0.8385481852315394,4,4,0
"	function	setPOOL_edit_13	(	string	newPOOL_edit_13	)	public	onlyOwner	{	
		inPOOL_edit_13	=	newPOOL_edit_13	;					
	}									
","	function	getPOOL_edit_19	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_19	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_13(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_19(),1.0,5,5,1
"    function buy() public payable {
        buyRecipient(msg.sender);
    }
","    function proposePlatformWithdrawal(address recipient) public onlyOwner {
        require(!platformWithdrawn);

        platformWithdrawalRecipient = recipient;
        platformWithdrawalProposed = true;
    }
",0x4d305c2334c02e44ac592bbea681ba4cc1576de3/RepuX.sol:RepuX:buy(),0x4d305c2334c02e44ac592bbea681ba4cc1576de3/RepuX.sol:RepuX:proposePlatformWithdrawal(address),0.0,4,4,0
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x5c08d6c04260dc28589d4ce878322486dc125b66/QuarkChain.sol:StandardToken:balanceOf(address),"0x5c08d6c04260dc28589d4ce878322486dc125b66/QuarkChain.sol:StandardToken:transfer(address,uint256)",0.28766430738119314,4,4,0
"    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:StandardToken:approve(address,uint256)","0x04fd2dc8979d92bba530fd78be5296adc6ed5d43/HOLODECKS.sol:StandardToken:transfer(address,uint256)",0.3043478260869565,4,4,0
"    function burn(uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        emit Transfer(msg.sender, 0x0, _value);
    }
","    function IstriumToken(address _addressFounder) public {
        owner = msg.sender;
        totalSupply = valueFounder;
        balanceOf[_addressFounder] = valueFounder;
       emit Transfer(0x0, _addressFounder, valueFounder);
    }
",0x08c3b0b55908ee37253ffcfd55bb957aa870bcfd/IstriumICO.sol:IstriumICO:burn(uint256),0x08c3b0b55908ee37253ffcfd55bb957aa870bcfd/IstriumICO.sol:IstriumICO:IstriumToken(address),0.07692307692307693,4,4,0
"  function getTransferPerc() public view returns (uint256) {
    return transferInfo.perc;
  }
","  function setRefillFor(string _paySystem, uint256 _stat, uint256 _perc) public onlyOwner returns (uint256) {
    refillPaySystemInfo[_paySystem].stat = _stat;
    refillPaySystemInfo[_paySystem].perc = _perc;

    RefillCommisionIsChanged(_paySystem, _stat, _perc);
  }
",0x0ab6e894c973932b64974bf9e91e93332e51a98c/EvaCurrency.sol:ComissionList:getTransferPerc(),"0x0ab6e894c973932b64974bf9e91e93332e51a98c/EvaCurrency.sol:ComissionList:setRefillFor(string,uint256,uint256)",1.0,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:approveAndCall(address,uint256,bytes)","0x0fc2564eaff1af8ed099230ca1147a53728805d9/FHCContract.sol:FHCContract:approve(address,uint256)",1.0,5,5,1
"  function balanceOf(address _owner) public view returns (uint256) {
    require(_owner != address(0));
    return ownedTokensCount[_owner];
  }
","  function getApproved(uint256 _tokenId) public view returns (address) {
    return tokenApprovals[_tokenId];
  }
",0x7f737b66921d18b008dc9c3a9b933a3bf559f1bc/InterfaceToken.sol:ERC721BasicToken:balanceOf(address),0x7f737b66921d18b008dc9c3a9b933a3bf559f1bc/InterfaceToken.sol:ERC721BasicToken:getApproved(uint256),0.75,4,4,0
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x05f4a42e251f2d52b8ed15e9fedaacfcef1fad27/ZilliqaToken.sol:StandardToken:transferFrom(address,address,uint256)","0x05f4a42e251f2d52b8ed15e9fedaacfcef1fad27/ZilliqaToken.sol:StandardToken:decreaseApproval(address,uint256)",0.8544474393530997,4,4,0
"    function airdrop(address[] addresses) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(value <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }
",0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:airdrop(address[]),0x2f5e61a4bf0816b7d2bf12c5265f0ac87dfe08e3/allFamily.sol:allFamily:enableWhitelist(address[]),0.95,5,5,1
"    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);

        if (isContract(controller)) {
            require(TokenController(controller).onTransfer(msg.sender, _to, _value));
        }

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        // Alerts the token controller of the transfer

        Transfer(msg.sender, _to, _value);
        return true;
    }
",0x06f0b31fa75d6a4f689fa0f4225f1811ae4a7e7d/TokenSaleAfterSplit.sol:ControlledToken:balanceOf(address),"0x06f0b31fa75d6a4f689fa0f4225f1811ae4a7e7d/TokenSaleAfterSplit.sol:ControlledToken:transfer(address,uint256)",0.0010111223458038423,4,4,0
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","0x00d53126139c547c7bd4f4285fc3756c2f081ab1/Hybrid.sol:StandardToken:transfer(address,uint256)","0x00d53126139c547c7bd4f4285fc3756c2f081ab1/Hybrid.sol:StandardToken:transferFrom(address,address,uint256)",0.986254295532646,5,5,1
"    modifier saleIsOn() {
        require(now > start && now < start + period * 1 days);
        _;
    }
","    modifier overSoftcap() {
        require(balanceTotal >= softcap);
        _;
    }
",0x02c06fb43f418e142666e4a80526d23cd2eae367/NooToken.sol:NooCrowdsale:saleIsOn(),0x02c06fb43f418e142666e4a80526d23cd2eae367/NooToken.sol:NooCrowdsale:overSoftcap(),0.05263157894736842,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function ba2cbor(bytes[] arr) internal returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:ba2cbor(bytes[]),0.8,4,4,0
"	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public onlyOwner {
		BdpPriceStorage(BdpContracts.getBdpPriceStorage(contracts)).setForwardUpdateFeesTo(_forwardUpdateFeesTo);
	}
","	function regionsIsPurchased(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionPurchasedAt(_regionId) > 0;
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:setForwardUpdateFeesTo(address),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:regionsIsPurchased(uint256),1.0,5,5,1
"    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[1],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[],uint256)",1.0,5,5,1
"    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
        if ((_nbytes == 0)||(_nbytes > 32)) throw;
        bytes memory nbytes = new bytes(1);
        nbytes[0] = byte(_nbytes);
        bytes memory unonce = new bytes(32);
        bytes memory sessionKeyHash = new bytes(32);
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
        assembly {
            mstore(unonce, 0x20)
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
            mstore(sessionKeyHash, 0x20)
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
        }
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash]; 
        bytes32 queryId = oraclize_query(_delay, ""random"", args, _customGasLimit);
        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));
        return queryId;
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_newRandomDSQuery(uint256,uint256,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)",1.0,5,5,1
"    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getPrice(string),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)",1.0,5,5,1
"    function FTBTokenERC20() public {
        
        totalSupply = initSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
",0x0fa9198bb9ca66260fa9a182f27ebbaab55430ff/FTBTokenERC20.sol:FTBTokenERC20:FTBTokenERC20(),"0x0fa9198bb9ca66260fa9a182f27ebbaab55430ff/FTBTokenERC20.sol:FTBTokenERC20:transfer(address,uint256)",1.0,5,5,1
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
","0x05fa56daf3c7496854bf685e7f3f435f87589e58/MyAdvancedToken.sol:TokenERC20:approveAndCall(address,uint256,bytes)","0x05fa56daf3c7496854bf685e7f3f435f87589e58/MyAdvancedToken.sol:TokenERC20:transferFrom(address,address,uint256)",0.7345309381237525,4,4,0
"    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
","    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
",0x8a011b5dfbee4a35d414c748aaf634e7429c4cf2/DataGo.sol:Owned:acceptOwnership(),0x8a011b5dfbee4a35d414c748aaf634e7429c4cf2/DataGo.sol:Owned:transferOwnership(address),0.935103244837758,5,5,1
"    function isLocked() public view returns (bool) {
        return locked;
    }
","    function transferFrom(address _from, address _to, uint _value) public only_when_unlocked returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
",0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:isLocked(),"0x5fc5e27d5f22e609d80fd4b5df02740f73c57fe4/KATXToken.sol:ManagedToken:transferFrom(address,address,uint256)",1.0,5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function IPToken() public {
        symbol = ""3H40"";
        name = ""IP Token"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xE5843CF1F504f980134652b54d895948E0FAC464] = _totalSupply;
        Transfer(address(0), 0xE5843CF1F504f980134652b54d895948E0FAC464, _totalSupply);
    }
","0x5e4f41b38e1a9520dd351c98e8ce2b8cbfe09532/IPToken.sol:IPToken:approveAndCall(address,uint256,bytes)",0x5e4f41b38e1a9520dd351c98e8ce2b8cbfe09532/IPToken.sol:IPToken:IPToken(),0.19528619528619529,4,4,0
"    function EarnEnoughMoney() public {
        owner = msg.sender;
        value = 2000e8;
        distr(owner, totalDistributed);
    }
","    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
",0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:EarnEnoughMoney(),"0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d/EarnEnoughMoney.sol:EarnEnoughMoney:transferFrom(address,address,uint256)",1.0,5,5,1
"  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }
","  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
","0x7afe338917a3c905571ffb0b7016ecc2ca3972a8/WavestreamPresale.sol:Crowdsale:_processPurchase(address,uint256)",0x7afe338917a3c905571ffb0b7016ecc2ca3972a8/WavestreamPresale.sol:Crowdsale:_forwardFunds(),0.972972972972973,5,5,1
"	modifier only_prepurchaser { require (msg.sender == PREPURCHASER); _; }
","	modifier when_allocatable_liquid(uint amount) { require (liquidAllocatable >= amount); _; }
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:only_prepurchaser(),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:when_allocatable_liquid(uint256),0.020408163265306117,4,4,0
"    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }
","    function delBot(address _address) onlyOwner public {
        bots[_address] = false;
        BotRemoved(_address);
    }
",0x2f09a5ea600a54a61bb9937478219f58f58c2174/LongevityCrowdsale.sol:LongevityCrowdsale:forwardFunds(),0x2f09a5ea600a54a61bb9937478219f58f58c2174/LongevityCrowdsale.sol:LongevityCrowdsale:delBot(address),0.0,4,4,0
"    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
","    function MYSTERYCLASSICCOIN() {
        balances[msg.sender] = 5000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 5000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = ""THE MYSTERY CLASSIC COIN"";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 8;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = ""TMCC"";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 0;                                      // Set the price of your token for the ICO (CHANGE THIS)
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    }
","0x3ea5da7112072c96af10d0fd8c61a64403ee71de/MYSTERYCLASSICCOIN.sol:MYSTERYCLASSICCOIN:approveAndCall(address,uint256,bytes)",0x3ea5da7112072c96af10d0fd8c61a64403ee71de/MYSTERYCLASSICCOIN.sol:MYSTERYCLASSICCOIN:MYSTERYCLASSICCOIN(),0.13838550247116968,4,4,0
"    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[2])",1.0,5,5,1
"	function partial_refund_my_ether() {
		partial_refund(msg.sender);
	}
","	function set_whitelist_enabled(bool _boolean) onlyOwner {
		whitelist_enabled = _boolean;
	}
",0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:partial_refund_my_ether(),0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:set_whitelist_enabled(bool),0.5,4,4,0
"    function CandyDropOpen(bool _CandyDropIsOpen) public onlyOwner{
        CandyDropIsOpen = _CandyDropIsOpen;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;          // Set allowance         
        Approval(msg.sender, _spender, _value);             // Raise Approval event         
        return true;
    }
",0x7b5271c23e0da39d17e04304c5ce651ed6074e8c/DASABI_IO_Contract.sol:DASABI_IO_Contract:CandyDropOpen(bool),"0x7b5271c23e0da39d17e04304c5ce651ed6074e8c/DASABI_IO_Contract.sol:DASABI_IO_Contract:approve(address,uint256)",1.0,5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x6b0186208160a253adc782e5cb5ab9376e0ed205/Rupee.sol:StandardToken:transferFrom(address,address,uint256)","0x6b0186208160a253adc782e5cb5ab9376e0ed205/Rupee.sol:StandardToken:allowance(address,address)",0.978021978021978,5,5,1
"	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i <= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}
","	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:imageUploadComplete(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpImageStorage:getImageDataLength(uint256,uint16)",1.0,5,5,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
","0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:CRDTToken:approve(address,uint256)","0x5cec1e8bc59baa4d1e6a6e6bb80ccad0450427ec/CRDTToken.sol:CRDTToken:transferAnyERC20Token(address,uint256)",0.9238095238095241,5,5,1
"    modifier onlyAdmin {
        if(!(msg.sender == admin1)) {
            revert();
        }
        _;
    }
","    function hasKey(address key) private constant returns (bool){
        for(uint256 i=0;i<balancesKeys.length;i++){
            address value = balancesKeys[i];
            if(value == key){
                return true;
            }
        }
        return false;
    }
",0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:onlyAdmin(),0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:hasKey(address),1.0,5,5,1
"    function externalPurchase(address beneficiary, uint amount) external onlySellers {
        makePurchase(beneficiary, amount);
    }
","    function setAsSeller(address seller, bool isSeller) external onlyOwner {
        sellers[seller] = isSeller;
    }
","0x0f466a0b3900f786f2d71134730b26a4bd7e3bbb/TempusIco.sol:TempusIco:externalPurchase(address,uint256)","0x0f466a0b3900f786f2d71134730b26a4bd7e3bbb/TempusIco.sol:TempusIco:setAsSeller(address,bool)",1.0,5,5,1
"  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
","  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  }
",0x3D3af44cf092a49280e316f09c8f20ecf97BC933/Ucoin.sol:MintableToken:finishMinting(),"0x3D3af44cf092a49280e316f09c8f20ecf97BC933/Ucoin.sol:MintableToken:mint(address,uint256)",0.7704081632653061,4,4,0
"    function setAgriChainData(address _AgriChainData)  onlyBy(creator) onlyIfNotSealed()
    {
         AgriChainData = _AgriChainData;
         EventChangedAddress(this,'AgriChainData',_AgriChainData);
    }
","    function setProduct(string _Product)  onlyBy(creator) onlyIfNotSealed()
    {
          Product = _Product;
          EventChangedString(this,'Product',_Product);
        
    }
",0x0bd78821368ca2d679e2d3a792b194465b3d0c28/AgriChainMasterContract.sol:AgriChainProductionContract:setAgriChainData(address),0x0bd78821368ca2d679e2d3a792b194465b3d0c28/AgriChainMasterContract.sol:AgriChainProductionContract:setProduct(string),1.0,5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) whenTransferAllowed public  returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;
        assert(balances[_to] >= _value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) whenTransferAllowed public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        assert(balances[_to] >= _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
","0x5a5b5018f1423bdaeb281144412f763a379806c6/TestCrypteriumToken.sol:TestCrypteriumToken:transferFrom(address,address,uint256)","0x5a5b5018f1423bdaeb281144412f763a379806c6/TestCrypteriumToken.sol:TestCrypteriumToken:transfer(address,uint256)",0.024113475177304958,4,4,0
"    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
","    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[3],uint256)",1.0,5,5,1
"  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
",0x0bcaa1c8da60b9f9711191ebf192c879870b322a/SkillChainPrivateSale.sol:BasicToken:balanceOf(address),"0x0bcaa1c8da60b9f9711191ebf192c879870b322a/SkillChainPrivateSale.sol:BasicToken:transfer(address,uint256)",0.2269969666329626,4,4,0
"    function DomenoToken() public {
        symbol = ""FEE"";
        name = ""Domeno Network"";
        decimals = 0;
        _totalSupply = 1000000000000;
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
",0x4d74acfb21f3be9d98263fc0b721840be958ef9d/DomenoToken.sol:DomenoToken:DomenoToken(),"0x4d74acfb21f3be9d98263fc0b721840be958ef9d/DomenoToken.sol:DomenoToken:transfer(address,uint256)",0.5,4,4,0
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","0x0ad627402c27a36b6de1d833a18f3923c6687f73/Veradium.sol:SafeMath:add(uint256,uint256)","0x0ad627402c27a36b6de1d833a18f3923c6687f73/Veradium.sol:SafeMath:div(uint256,uint256)",0.7325842696629213,4,4,0
"    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:parseAddr(string),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)",1.0,5,5,1
"    function transferOwnershipImmediately(address _newOwner) public {
        data.transferOwnershipImmediately(_newOwner);
    }
","    function totalSupply() public view returns (uint) {
        return data.totalSupply - data.balances[address(0)];
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:transferOwnershipImmediately(address),0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:totalSupply(),1.0,5,5,1
"	function	getPI_edit_1	()	public	constant	returns	(	string	)	{
		return	inPI_edit_1	;						
	}									
","	function	setPI_edit_33	(	string	newPI_edit_33	)	public	onlyOwner	{	
		inPI_edit_33	=	newPI_edit_33	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_1(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_33(string),1.0,5,5,1
"	function mintToken(address target, uint256 mintedAmount) onlyOwner {
		balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
","    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
","0x3ba5a8d30a598c58558f11d8347f76dd6f1d05f6/ipshoots.sol:ipshoots:mintToken(address,uint256)","0x3ba5a8d30a598c58558f11d8347f76dd6f1d05f6/ipshoots.sol:ipshoots:transfer(address,uint256)",0.13445378151260504,4,4,0
"    function killContract () payable external
    {
        if (msg.sender==owner || msg.value >=howManyEtherInWeiToKillContract)
        {
            selfdestruct(owner);
        }
    }
","    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }
",0x1cf6949F4B661018B3195f3FF98effe12f587263/AtlantToken.sol:AtlantToken:killContract(),0x1cf6949F4B661018B3195f3FF98effe12f587263/AtlantToken.sol:AtlantToken:totalSupply(),1.0,5,5,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
",0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9/DailyDraw.sol:Ethernational:totalSupply(),"0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9/DailyDraw.sol:Ethernational:transferAnyERC20Token(address,uint256)",0.9744525547445256,5,5,1
"    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
","    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;
        
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);
        
        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);
        
        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = 1; //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);
        
        if (sigok == false) return false;
        
        
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";
        
        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);
        
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);
        
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);
        
        return sigok;
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:getCodeSize(address),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)",0.6666666666666666,4,4,0
"	function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply
        Freeze(msg.sender, _value);
        return true;
    }
","    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
",0x1b9c8bdab3799c68682aac68089af32d1e7dcdd0/BNB.sol:BNB:freeze(uint256),"0x1b9c8bdab3799c68682aac68089af32d1e7dcdd0/BNB.sol:BNB:transfer(address,uint256)",0.8888888888888888,4,4,0
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x1b016ac4de0996b1f59eab9c54a083af496c811d/ScandinavianEKrona.sol:ScandinavianEKrona:allowance(address,address)",0x1b016ac4de0996b1f59eab9c54a083af496c811d/ScandinavianEKrona.sol:ScandinavianEKrona:balanceOf(address),0.9696048632218844,5,5,1
"    function EXToken() Token(INITIAL_SUPPLY, NAME, DECIMALS, SYMBOL, STANDARD) {
        balanceOf[msg.sender] = totalSupply;
        buyPrice = 100000000;
        sellPrice = 100000000;
    }
","    function freezeAccount(address _target, bool freeze) onlyOwner {
        frozenAccount[_target] = freeze;
        FrozenFunds(_target, freeze);
    }
",0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:EXToken:EXToken(),"0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:EXToken:freezeAccount(address,bool)",1.0,5,5,1
"    function ZaiZaiCoin() public {
        symbol = ""ZZCT"";
        name = ""ZaiZaiCoin"";
        decimals = 4;
        _totalSupply = 1000000000000;
        balances[0xBca7818F07891c99b2BFe62349CcF396851f54Aa] = _totalSupply;
        Transfer(address(0), 0xBca7818F07891c99b2BFe62349CcF396851f54Aa, _totalSupply);
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
",0x6e43a5e4b8341b88c98843556c56b7feac8ac536/ZaiZaiCoin.sol:ZaiZaiCoin:ZaiZaiCoin(),"0x6e43a5e4b8341b88c98843556c56b7feac8ac536/ZaiZaiCoin.sol:ZaiZaiCoin:transferFrom(address,address,uint256)",1.0,5,5,1
"    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {
        return allowance[_owner][_spender];
    }
","    function appendTokenHolders(address tokenHolder) private {

        if (balanceOf[tokenHolder] == 0) {
          
            accountIndex[accountCount] = tokenHolder;
            accountCount++;
        }

    }
","0x0c9c66ea38475f9d5710676020c49364ba154ce0/Kash.sol:Kash:allowance(address,address)",0x0c9c66ea38475f9d5710676020c49364ba154ce0/Kash.sol:Kash:appendTokenHolders(address),0.0006583278472679394,4,4,0
"  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
    if (balanceOf(msg.sender) < _value) revert();
    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
    balances[_to] = safeAdd(balanceOf(_to), _value);
    emit Transfer(msg.sender, _to, _value, _data);
    return true;
  }
","  function releaseTokenTransfer() public onlyCrowdsaleAgent {
    released = true;
  }
","0x02E24Acc7098E7BedF6e1D863D8034F692ad2E22/OilToken.sol:ERC223Token:transferToAddress(address,uint256,bytes)",0x02E24Acc7098E7BedF6e1D863D8034F692ad2E22/OilToken.sol:ERC223Token:releaseTokenTransfer(),0.0,4,4,0
"  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x0bd490948a81b5f8135d4c062eb475e43f39f022/BBR.sol:SafeMath:sub(uint256,uint256)","0x0bd490948a81b5f8135d4c062eb475e43f39f022/BBR.sol:SafeMath:mul(uint256,uint256)",0.7849035187287173,4,4,0
"    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {
        require(_to != address(0));

        var _allowance = allowed[_from][msg.sender];
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        if(transferIns[_from].length > 0) delete transferIns[_from];
        uint64 _now = uint64(now);
        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));
        transferIns[_to].push(transferInStruct(uint128(_value),_now));
        return true;
    }
","	function mintToken(address target, uint256 mintedAmount) onlyOwner {
		balances[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
","0x3a302f4332c3dd4e5f9e04df745a68cdbde8c8be/vangatoken.sol:vangatoken:transferFrom(address,address,uint256)","0x3a302f4332c3dd4e5f9e04df745a68cdbde8c8be/vangatoken.sol:vangatoken:mintToken(address,uint256)",0.0,4,4,0
"  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}
","    function withdrawCoinToOwner(uint256 _value) external
		onlyOwner
	{
		processFunding(msg.sender,_value,1);
	}
","0x4c64ec047fd2d83b7cab6189f71d718ac63bd2f0/HLWCOIN.sol:HLWCOIN:approve(address,uint256)",0x4c64ec047fd2d83b7cab6189f71d718ac63bd2f0/HLWCOIN.sol:HLWCOIN:withdrawCoinToOwner(uint256),0.0005359056806002144,4,4,0
"    function AUD_Omnidollar() public {
        symbol = ""AUDO"";
        name = ""AUD_Omnidollar"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000;
        balances[0x6d8d30e6c418E322Fb20b9F01115858cDF1e979E] = _totalSupply;
        Transfer(address(0), 0x6d8d30e6c418E322Fb20b9F01115858cDF1e979E, _totalSupply);
    }
","    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
",0x2c2bebd6fcce005eb394f9810c5e6f273f54fefc/AUD_Omnidollar.sol:AUD_Omnidollar:AUD_Omnidollar(),"0x2c2bebd6fcce005eb394f9810c5e6f273f54fefc/AUD_Omnidollar.sol:AUD_Omnidollar:transferAnyERC20Token(address,uint256)",0.9918699186991872,5,5,1
