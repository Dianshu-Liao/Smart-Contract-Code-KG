function1 code,function2 code,function1 FEN,function2 FEN,label1,label2,label
"    function unlock() public only_owner returns (bool)  {
        locked = false;
        return !locked;
    }
","    function approve(address _spender, uint _value) public returns (bool) {
        return super.approve(_spender, _value);
    }
",0x3e250a4f78410c29cfc39463a81f14a226690eb4/DRPSToken.sol:ManagedToken:unlock(),"0x3e250a4f78410c29cfc39463a81f14a226690eb4/DRPSToken.sol:ManagedToken:approve(address,uint256)",5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
","    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }
","0x1a86b24ca84aa7049a974bb6db83f0bd80c60713/DCoin.sol:TokenERC20:burnFrom(address,uint256)",0x1a86b24ca84aa7049a974bb6db83f0bd80c60713/DCoin.sol:TokenERC20:burn(uint256),4,4,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
	uint256 c = a + b;
	assert(c >= a);
	return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
	assert(b <= a);
	return a - b;
  }
","0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:SafeMath:add(uint256,uint256)","0x3a018b8245b6d9b0abc2808eb4be03a17e0fecf8/Cryptoya.sol:SafeMath:sub(uint256,uint256)",4,4,1
"		function	getData_13	()	public	constant	returns	(	string	)	{
			return	inData_13	;						
		}									
","		function	getData_31	()	public	constant	returns	(	string	)	{
			return	inData_31	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_13(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_31(),5,5,1
"	function	getPOOL_edit_1	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_1	;						
	}									
","	function	setPOOL_edit_34	(	string	newPOOL_edit_34	)	public	onlyOwner	{	
		inPOOL_edit_34	=	newPOOL_edit_34	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_1(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_34(string),5,5,1
"	function	getPI_edit_28	()	public	constant	returns	(	string	)	{
		return	inPI_edit_28	;						
	}									
","	function	setPI_edit_9	(	string	newPI_edit_9	)	public	onlyOwner	{	
		inPI_edit_9	=	newPI_edit_9	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_28(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_9(string),4,4,0
"	function purchaseTo(address _recipient)
		only_certified(msg.sender)
		payable
		public
	{
		processPurchase(_recipient);
	}
","	modifier only_certified(address who) { require (CERTIFIER.certified(who)); _; }
",0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:purchaseTo(address),0x7a3ffe753a209cc8281d68356270e6848f098f71/AmbrosusSale.sol:AmbrosusSale:only_certified(address),5,5,1
"  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }
","  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
","0x3dd2ecaa49df3306c1332d2b858dfe8268314a5c/DigiassetzToken.sol:BasicToken:transfer(address,uint256)",0x3dd2ecaa49df3306c1332d2b858dfe8268314a5c/DigiassetzToken.sol:BasicToken:balanceOf(address),4,4,1
"	function	getPOOL_edit_8	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_8	;						
	}									
","	function	getPOOL_edit_15	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_15	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_8(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_15(),4,4,0
"	function	PI_EDIT_1		()	public	{				
		owner	= msg.sender;							
	}									
","	function	getPI_edit_33	()	public	constant	returns	(	string	)	{
		return	inPI_edit_33	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:PI_EDIT_1(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_33(),5,5,1
"    function Coinnec() {
        balances[msg.sender] = 100000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 1000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = ""Coinnec"";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = ""NEC"";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000;                                      // Set the price of your token for the ICO (CHANGE THIS)
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
",0x5f8ce34daf79f32930af4b16433f325f03104961/Coinnec.sol:Coinnec:Coinnec(),"0x5f8ce34daf79f32930af4b16433f325f03104961/Coinnec.sol:Coinnec:approveAndCall(address,uint256,bytes)",4,4,0
"    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
        require(targets.length > 0 && targets.length == unixTimes.length);
                
        for(uint j = 0; j < targets.length; j++){
            require(unlockUnixTime[targets[j]] < unixTimes[j]);
            unlockUnixTime[targets[j]] = unixTimes[j];
            LockedFunds(targets[j], unixTimes[j]);
        }
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","0x8b3d0703b30a6c2eb8b88a479648391186e4cc8f/FIGHTMONEY.sol:FIGHTMONEY:lockupAccounts(address[],uint256[])",0x8b3d0703b30a6c2eb8b88a479648391186e4cc8f/FIGHTMONEY.sol:FIGHTMONEY:totalSupply(),4,5,1
"    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x0FF1dbACDb27e47A43520c05885Dd8bBe165333A/CryptoSportsToken.sol:SafeMath:safeSub(uint256,uint256)","0x0FF1dbACDb27e47A43520c05885Dd8bBe165333A/CryptoSportsToken.sol:SafeMath:safeMul(uint256,uint256)",4,4,1
"    function buy() payable returns (uint amount) {
        require(couldTrade);
        amount = msg.value * RATE / buyPrice;
        require(balanceOf[this] >= amount);
        require(balanceOf[msg.sender] + amount >= amount);
        balanceOf[this] -= amount;
        balanceOf[msg.sender] += amount;
        Transfer(this, msg.sender, amount);
        return amount;
    }
","    function stopTrade() onlyOwner returns (bool success) {
        couldTrade = false;
        uint256 _remain = balanceOf[this];
        require(balanceOf[msg.sender] + _remain >= _remain);
        balanceOf[msg.sender] += _remain;
        balanceOf[this] -= _remain;
        Transfer(this, msg.sender, _remain);
        return true;
    }
",0x0f3065a387d9f596f40efb0a3df5ceb735d82fd2/EXToken.sol:EXToken:buy(),0x0f3065a387d9f596f40efb0a3df5ceb735d82fd2/EXToken.sol:EXToken:stopTrade(),5,5,1
"  function tokenFallback(address _from, uint _value, bytes _data) {
		if (ERC20(msg.sender) == token) {
			tokens_received();
		}
	}
","	function set_percent_reduction(uint256 _reduction) onlyOwner payable {
		require(bought_tokens && rounds == 0 && _reduction <= 100);
		percent_reduction = _reduction;
		if (msg.value > 0) {
			owner_supplied_eth = true;
		}
		const_contract_eth_value = const_contract_eth_value.sub((const_contract_eth_value.mul(_reduction)).div(100));
	}
","0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:tokenFallback(address,uint256,bytes)",0x1d968ef5f8b3d53fbe2980590e94c8901a8421a1/Contract.sol:Contract:set_percent_reduction(uint256),4,4,1
"    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[5],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[1],uint256)",4,4,1
"	function	getPOOL_edit_9	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_9	;						
	}									
","	function	getPOOL_edit_25	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_25	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_9(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_25(),5,5,0
"    function payOutDividend() onlyOwner returns (bool success) { 
        createRecord(); 
        uint256 volume = totalSupply; 
        for (uint i = 0; i < (tokenHolders.length.sub(1)); i++) {
            address payee = getTokenHolder(i); 
            uint256 stake = volume.div(dividendPayment.div(multiplier));    
            uint256 dividendPayout = balanceOf(payee).div(stake).mul(multiplier); 
            balance[payee] = balance[payee].add(dividendPayout);
            totalSupply = totalSupply.add(dividendPayout); 
            Transfer(0, payee, dividendPayout);
        }
        return true; 
    }
","    function startSale(uint256 saleStart, uint256 saleStop) onlyOwner returns (bool success) {
        require(saleStop > now);     
        startTime = saleStart; 
        stopTime = saleStop; 
        crowdsaleClosed = false; 
        return true; 
    }
",0x6cBc1A135d3C9a835d523aaE9E4723B9b776fC49/StakePoolICO.sol:StakePoolICO:payOutDividend(),"0x6cBc1A135d3C9a835d523aaE9E4723B9b776fC49/StakePoolICO.sol:StakePoolICO:startSale(uint256,uint256)",5,5,1
"    function setProofType(byte _proofType)
    external
    {
        addr_proofType[msg.sender] = _proofType;
    }
","    function setGasPrice(uint newgasprice)
    external
    {
        onlyadmin();
        gasprice = newgasprice;
    }
",0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:setProofType(bytes1),0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:setGasPrice(uint256),4,4,1
"    function getReserveBalances() public view returns (uint256, uint256) {
        return (tokenContract.balanceOf(this), address(this).balance+virtualReserveBalance);
    }
","    function getSalePrice(uint256 tokensToSell) public view returns(uint) {
        uint256 saleReturn = formulaContract.calculateSaleReturn(
            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),
            address(this).balance + virtualReserveBalance,
            weight,
            tokensToSell 
        ); 
        saleReturn = (saleReturn - ((saleReturn * fee) / 1000000));
        if (saleReturn > address(this).balance) {
            return address(this).balance;
        }
        return saleReturn;
    }
",0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:getReserveBalances(),0x4aa9a9d81c6d01a1da68e769472077b3db5ebd9e/ExchangerV3.sol:ExchangerV3:getSalePrice(uint256),5,5,1
"    function ethBalance() 
    public 
    view 
    returns (uint256)
    {
        return address(this).balance;
    }
","    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) 
    public 
    onlyOwner() 
    returns (bool success) 
    {
        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);
    }
",0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:ethBalance(),"0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:transferAnyERC20Token(address,address,uint256)",5,5,1
"    function SNK(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol) 
        public {
        totalSupply = initialSupply * 10 ** uint256(decimals); 
        balanceOf[msg.sender] = totalSupply;           
        name = tokenName;                           
        symbol = tokenSymbol; }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true; } }
","0x2bb9492e3391235efcdbdd70cf58bbb6b7a35ce8/SNK.sol:SNK:SNK(uint256,string,string)","0x2bb9492e3391235efcdbdd70cf58bbb6b7a35ce8/SNK.sol:SNK:approveAndCall(address,uint256,bytes)",2,1,0
"	function	getPOOL_edit_22	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_22	;						
	}									
","	function	getPOOL_edit_12	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_12	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_22(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_12(),4,4,1
"    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {
        z = x / y;
    }
","    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = x / y;
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:div(uint256,uint256)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:hdiv(uint128,uint128)",5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)",4,4,1
"	modifier storageAccessControl() {
		require(
			(! setupComplete && (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupComplete && !paused && (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}
","	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}
",0x2abe025a3514dbb4c5dac0fcf3a8f595d72bf352/BdpPriceStorage.sol:BdpBase:storageAccessControl(),0x2abe025a3514dbb4c5dac0fcf3a8f595d72bf352/BdpPriceStorage.sol:BdpBase:setManager(address),5,5,1
"  function burnToken(TokenStorage storage self, uint256 _amount) returns (bool) {
      uint256 _newBalance;
      bool err;

      (err, _newBalance) = self.balances[msg.sender].minus(_amount);
      require(!err);

      self.balances[msg.sender] = _newBalance;
      self.totalSupply = self.totalSupply - _amount;
      Burn(msg.sender, _amount);
      Transfer(msg.sender, 0x0, _amount);
      return true;
  }
","  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {
    return self.balances[_owner];
  }
","0x1f9623333f8e779439e62229f2e8010b7fa97042/TokenLib.sol:TokenLib:burnToken(TokenLib:TokenStorage,uint256)","0x1f9623333f8e779439e62229f2e8010b7fa97042/TokenLib.sol:TokenLib:balanceOf(TokenLib:TokenStorage,address)",5,5,1
"    function setDistributeAmount(uint256 _unitAmount) onlyOwner public {
        distributeAmount = _unitAmount;
    }
","    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
        require(targets.length > 0
                && targets.length == unixTimes.length);
                
        for(uint j = 0; j < targets.length; j++){
            require(unlockUnixTime[targets[j]] < unixTimes[j]);
            unlockUnixTime[targets[j]] = unixTimes[j];
            LockedFunds(targets[j], unixTimes[j]);
        }
    }
",0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:setDistributeAmount(uint256),"0x1c1d65c424a7c316f3134532e80adc4de142fd50/Visualrocktoken.sol:Visualrocktoken:lockupAccounts(address[],uint256[])",4,5,1
"    function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){
        bool match_ = true;

        for (var i=0; i<prefix.length; i++){
            if (content[i] != prefix[i]) match_ = false;
        }

        return match_;
    }
","    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:matchBytes32Prefix(bytes32,bytes)",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_useCoupon(string),5,5,1
"    modifier whenNotPaused() {
        require(!paused);
        _;
    }
","    modifier whenPaused() {
        require(paused);
        _;
    }
",0x1afafc35b364595f06e89a0429c5762452eb7ffd/CXTCContract.sol:Pausable:whenNotPaused(),0x1afafc35b364595f06e89a0429c5762452eb7ffd/CXTCContract.sol:Pausable:whenPaused(),4,4,1
"    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6/SLUTZToken.sol:SLUTZToken:totalSupply(),"0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6/SLUTZToken.sol:SLUTZToken:approveAndCall(address,uint256,bytes)",4,4,1
"	function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
		allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
		return true;
	}
","	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
		return allowed[_owner][_spender];
	}
","0x3bb3354f82654dd609300e92c92cf2c7c1bf3171/Tokens.sol:Tokens:increaseApproval(address,uint256)","0x3bb3354f82654dd609300e92c92cf2c7c1bf3171/Tokens.sol:Tokens:allowance(address,address)",3,1,1
"    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
","    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:__callback(bytes32,string)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_cbAddress(),4,4,1
"    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        Airdrop(_participant, _amount, balances[_participant]);
        Transfer(address(0), _participant, _amount);
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
","0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:doAirdrop(address,uint256)","0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9/Test1.sol:Test1:getTokenBalance(address,address)",4,4,1
"    function totalSupply() public view returns (uint) {
        return data.totalSupply - data.balances[address(0)];
    }
","    function acceptOwnership() public {
        data.acceptOwnership();
    }
",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:totalSupply(),0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:acceptOwnership(),5,5,1
"    function abi() constant returns (string)
    { return '[{""constant"":true,""inputs"":[],""name"":""name"",""outputs"":[{""name"":"""",""type"":""string""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_spender"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""approve"",""outputs"":[{""name"":"""",""type"":""bool""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_owner"",""type"":""address""}],""name"":""setOwner"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""totalSupply"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_from"",""type"":""address""},{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transferFrom"",""outputs"":[{""name"":"""",""type"":""bool""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""decimals"",""outputs"":[{""name"":"""",""type"":""uint8""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""hammer"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_owner"",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""destroy"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""symbol"",""outputs"":[{""name"":"""",""type"":""string""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer"",""outputs"":[{""name"":"""",""type"":""bool""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_hammer"",""type"":""address""}],""name"":""setHammer"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_owner"",""type"":""address""},{""name"":""_spender"",""type"":""address""}],""name"":""allowance"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_spender"",""type"":""address""}],""name"":""unapprove"",""outputs"":[],""payable"":false,""type"":""function""},{""inputs"":[{""name"":""_name"",""type"":""string""},{""name"":""_symbol"",""type"":""string""},{""name"":""_decimals"",""type"":""uint8""},{""name"":""_count"",""type"":""uint256""}],""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""_from"",""type"":""address""},{""indexed"":true,""name"":""_to"",""type"":""address""},{""indexed"":false,""name"":""_value"",""type"":""uint256""}],""name"":""Transfer"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""_owner"",""type"":""address""},{""indexed"":true,""name"":""_spender"",""type"":""address""},{""indexed"":false,""name"":""_value"",""type"":""uint256""}],""name"":""Approval"",""type"":""event""}]'; }
","    function version() constant returns (string)
    { return ""v0.6.0 (1b4435b8)""; }
",0x6C0Fc347aa0C1bFC3037f06ED09FFd8f5de07259/BuilderToken.sol:CreatorToken:abi(),0x6C0Fc347aa0C1bFC3037f06ED09FFd8f5de07259/BuilderToken.sol:CreatorToken:version(),4,4,0
"    function toSlice(string self) internal returns (slice) {
        uint ptr;
        assembly {
            ptr := add(self, 0x20)
        }
        return slice(bytes(self).length, ptr);
    }
","    function memcpy(uint dest, uint src, uint len) private {
        // Copy word-length chunks while possible
        for(; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(destpart, srcpart))
        }
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:toSlice(string),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:strings:memcpy(uint256,uint256,uint256)",5,5,1
"	function getRegionBlockUpdatedAt(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionBlockUpdatedAt(_regionId);
	}
","	function regionExists(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUpdatedAt(_regionId) > 0;
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getRegionBlockUpdatedAt(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:regionExists(uint256),5,5,1
"	function	setData_18	(	string	newData_18	)	public	onlyOwner	{	
		inData_18	=	newData_18	;					
	}									
","	function	getData_27	()	public	constant	returns	(	string	)	{
		return	inData_27	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_18(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_27(),5,5,1
"    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }
","    function strConcat(string _a, string _b, string _c) internal returns (string) {
        return strConcat(_a, _b, _c, """", """");
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_getPrice(string,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:strConcat(string,string,string)",5,5,1
"		function	setData_26	(	string	newData_26	)	public	onlyOwner	{	
			inData_26	=	newData_26	;					
		}									
","		function	setData_9	(	string	newData_9	)	public	onlyOwner	{	
			inData_9	=	newData_9	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_26(string),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_9(string),5,5,1
"    function initialTransfer(address _to, uint256 _amount, uint256 _decimalPlace) private { 
        balances[_to] = _amount.mul(_decimalPlace);
        Transfer(address(0), _to, balances[_to]);
    }
","    function KEDToken() public {
        uint256 decimalPlace = 10 ** uint(decimals);
        
        totalSupply_ = SUPPLY_AMOUNT * decimalPlace;
        
        initialTransfer(COMPANY_ADDRESS, COMPANY_AMOUNT, decimalPlace);
        initialTransfer(REWARDS_ADDRESS, REWARDS_AMOUNT, decimalPlace);
        initialTransfer(ADVISORS_ADDRESS, ADVISORS_AMOUNT, decimalPlace);
        initialTransfer(TEAM_ADDRESS, TEAM_AMOUNT, decimalPlace);
        initialTransfer(PRE_ICO_ADDRESS, PRE_ICO_AMOUNT, decimalPlace);
        initialTransfer(ICO_ADDRESS, ICO_AMOUNT, decimalPlace);
    }
","0x2b46e2670396f8604334d1a3173a714a5a16ba87/KEDToken.sol:KEDToken:initialTransfer(address,uint256,uint256)",0x2b46e2670396f8604334d1a3173a714a5a16ba87/KEDToken.sol:KEDToken:KEDToken(),5,5,1
"    function ownerBurnToken(uint _value) onlyOwner {
        require(_value > 0);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        delete transferIns[msg.sender];
        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));

        totalSupply = totalSupply.sub(_value);
        totalInitialSupply = totalInitialSupply.sub(_value);
        maxTotalSupply = maxTotalSupply.sub(_value*10);

        Burn(msg.sender, _value);
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
",0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Aecium:ownerBurnToken(uint256),0x7cdd19121009b3e1500e653d2a8084eb85d7a424/Aecium.sol:Aecium:balanceOf(address),4,4,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x3a1fb5c013cdb7dbccff9cfcad1973d23beec941/GoldDollar.sol:StandardToken:transferFrom(address,address,uint256)","0x3a1fb5c013cdb7dbccff9cfcad1973d23beec941/GoldDollar.sol:StandardToken:allowance(address,address)",3,2,1
"    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[5])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])",5,5,1
"    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","0x5ae8cc13f4a20524303d6f92f6fe5574be3f1703/GambangCoin.sol:GambangCoin:transferFrom(address,address,uint256)","0x5ae8cc13f4a20524303d6f92f6fe5574be3f1703/GambangCoin.sol:GambangCoin:approve(address,uint256)",4,4,1
"    function setEndsAt(uint time) onlyOwner {
        require(!finalized);
        require(time >= now);
        endsAt = time;
        EndsAtChanged(endsAt);
    }
","    function setRate(uint value) onlyOwner {
        require(!finalized);
        require(value > 0);
        RateChanged(TokenPerETH, value);
        TokenPerETH = value;
    }
",0x3dcff2492b076b2a78eac9979f50a413121fc70b/RajTestICO.sol:RajTestICO:setEndsAt(uint256),0x3dcff2492b076b2a78eac9979f50a413121fc70b/RajTestICO.sol:RajTestICO:setRate(uint256),4,4,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x7ef8873220958ea400d505a9c92d6ae24f34d55e/ARCDCrowdsale.sol:SafeMath:div(uint256,uint256)","0x7ef8873220958ea400d505a9c92d6ae24f34d55e/ARCDCrowdsale.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), RAY / 2) / RAY;
    }
","    function wdiv(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, WAD), y / 2) / y;
    }
","0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:DSMath:rmul(uint256,uint256)","0x7be8c35aa12d9edf62a6ccb2b423a8fbfbbd67c5/CARSToken.sol:DSMath:wdiv(uint256,uint256)",5,5,1
"    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
        // We do our own memory management here. Solidity uses memory offset
        // 0x40 to store the current end of memory. We write past it (as
        // writes are memory extensions), but don't update the offset so
        // Solidity will reuse it. The memory used here is only needed for
        // this context.

        // FIXME: inline assembly can't access return values
        bool ret;
        address addr;

        assembly {
            let size := mload(0x40)
            mstore(size, hash)
            mstore(add(size, 32), v)
            mstore(add(size, 64), r)
            mstore(add(size, 96), s)

            // NOTE: we can reuse the request memory because we deal with
            //       the return code
            ret := call(3000, 1, 0, size, 128, size, 32)
            addr := mload(size)
        }

        return (ret, addr);
    }
","    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:safer_ecrecover(bytes32,uint8,bytes32,bytes32)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)",5,5,1
"	function	retrait_3				()	public	{		
		require(	msg.sender == User_3			);				
		require(	Securities_3.transfer(User_1, Standard_3)			);				
		require(	ID == ID_control			);				
		require(	Cmd == Cmd_control			);				
		require(	Depositary_function == Depositary_function_control			);				
	}									
","	function	retrait_4				()	public	{		
		require(	msg.sender == User_4			);				
		require(	Securities_4.transfer(User_1, Standard_4)			);				
		require(	ID == ID_control			);				
		require(	Cmd == Cmd_control			);				
		require(	Depositary_function == Depositary_function_control			);				
	}									
",0x7b8b8e4f1accdce519569d3244f5dd51e569fa5a/DTCC_ILOW_7.sol:DTCC_ILOW_7:retrait_3(),0x7b8b8e4f1accdce519569d3244f5dd51e569fa5a/DTCC_ILOW_7.sol:DTCC_ILOW_7:retrait_4(),5,5,1
"    function lockInternalAccount(address _target, bool _lock, uint256 _releaseTime) onlyOwner public {
        require(_target != address(0));

        internalLockAccount[_target] = _lock;
        releaseLockAccount[_target] = _releaseTime;

    }
","    function internalSellTokenFromAdmin(address _to, uint256 _value, bool _lock, uint256 _releaseTime) onlyOwner public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[owner]);

        balances[owner] = balances[owner].sub(_value);
        balances[_to] = balances[_to].add(_value);
        soldSupply = soldSupply.add(_value);
        sellSupply = sellSupply.add(_value);

        Transfer(owner, _to, _value);
        
        lockInternalAccount(_to, _lock, _releaseTime);

        return true;
    }
","0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:lockInternalAccount(address,bool,uint256)","0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:internalSellTokenFromAdmin(address,uint256,bool,uint256)",5,5,1
"     constructor() public {
        owner = msg.sender;
		//?????????????
        balances[owner] = totalDistributed;
    }
","    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
",0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:constructor(),"0x1cbbb66df9cbee093a42d878530aa9309a401c6a/TDC.sol:TDC:getTokenBalance(address,address)",5,5,1
"    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
","    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x0ecdc69ca6e2e7e12bb344a67b04ff471b6089e7/KillerWhale.sol:SafeMath:sub(uint256,uint256)","0x0ecdc69ca6e2e7e12bb344a67b04ff471b6089e7/KillerWhale.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function oraclize_setNetworkName(string _network_name) internal {
        oraclize_network_name = _network_name;
    }
","    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_setNetworkName(string),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[1])",4,4,1
"    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }
","    function airdrop(address[] addresses) onlyOwner canDistr public {
        
        require(addresses.length <= 255);
        require(value <= totalRemaining);
        
        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }
	
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:distributeAmounts(address[],uint256[])",0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c/BEN.sol:BEN:airdrop(address[]),5,5,1
"    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x2b83d02bc05d224025c1244889e708a2dd0bad47/GLXToken.sol:GLXToken:balanceOf(address),"0x2b83d02bc05d224025c1244889e708a2dd0bad47/GLXToken.sol:GLXToken:allowance(address,address)",4,4,1
"    function randomDS_getSessionPubKeyHash() constant returns (bytes32) {
        uint i = uint(sha3(reqc[msg.sender]))%randomDS_sessionPubKeysHash.length;
        return randomDS_sessionPubKeysHash[i];
    }
","    function cbAddress()
    constant
    returns (address _cbAddress) {
        if (cbAddresses[tx.origin] != 0)
            _cbAddress = tx.origin;
    }
",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:randomDS_getSessionPubKeyHash(),0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:cbAddress(),5,5,1
"    modifier noEth() {
        if (msg.value < 0) {
            throw;
        }
        _;
    }
","    function expectedDividends(address user) constant returns (uint Dividends){
        return balances[dividendAddress] / globalShares * vips[user];
    }
",0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:GlobalCoin:noEth(),0x3f44b083973d5cDdAE571d61921d8e8f0248df43/GlobalCoin.sol:GlobalCoin:expectedDividends(address),5,5,1
"    function add(uint256 a, uint256 b) internal constant returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function sub(uint256 a, uint256 b) internal constant returns(uint256) {
        assert(b <= a);
        return a - b;
    }
","0x3F8eB9E89976021CFD80D8c729203D5e3f723491/ETHBita.sol:SafeMath:add(uint256,uint256)","0x3F8eB9E89976021CFD80D8c729203D5e3f723491/ETHBita.sol:SafeMath:sub(uint256,uint256)",4,4,1
"	function	getPI_edit_30	()	public	constant	returns	(	string	)	{
		return	inPI_edit_30	;						
	}									
","	function	getPI_edit_28	()	public	constant	returns	(	string	)	{
		return	inPI_edit_28	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_30(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_28(),5,5,0
"    function makePurchase(address beneficiary, uint amount) private {
        require(beneficiary != 0x0);
        require(isActive());
        uint minimumTokens = 20000;
        if(tokensSold < hardCap.sub(minimumTokens)) {
            require(amount >= minimumTokens);
        }
        require(amount.add(tokensSold) <= hardCap);
        tokensSold = tokensSold.add(amount);
        token.mint(beneficiary, amount);
    }
","    function setPaused(bool isPaused) external onlyOwner {
        paused = isPaused;
    }
","0x3cb7a642b1966c94c425c0a903f4c0e033e9b7e9/TempusPreIco.sol:TempusPreIco:makePurchase(address,uint256)",0x3cb7a642b1966c94c425c0a903f4c0e033e9b7e9/TempusPreIco.sol:TempusPreIco:setPaused(bool),4,4,1
"    function getPrice(string _datasource, uint _gaslimit, address _addr)
    private
    returns (uint _dsprice)
    {
        uint gasprice_ = addr_gasPrice[_addr];
        if (
                (offchainPayment[_addr])
            ||(
                (_gaslimit <= 200000)&&
                (reqc[_addr] == 0)&&
                (gasprice_ <= gasprice)&&
                (tx.origin != cbAddress())
            )
        ) return 0;

        if (gasprice_ == 0) gasprice_ = gasprice;
        _dsprice = price[sha3(_datasource, addr_proofType[_addr])];
        _dsprice += _gaslimit*gasprice_;
        return _dsprice;
    }
","    function query(uint _timestamp, string _datasource, string _arg)
    payable
    external
    returns (bytes32 _id)
    {
        return query1(_timestamp, _datasource, _arg, 200000);
    }
","0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:getPrice(string,uint256,address)","0x3dbdc81a6edc94c720b0b88fb65dbd7e395fdcf6/Oraclize.sol:Oraclize:query(uint256,string,string)",5,5,1
"    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = x / y;
    }
","    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:hdiv(uint128,uint128)","0x7d116f0d7e566017daabbc7a9d7a669e0376b6a8/DSToken.sol:DSMath:hsub(uint128,uint128)",5,5,1
"    function endsWith(slice self, slice needle) internal returns (bool) {
        if (self._len < needle._len) {
            return false;
        }

        var selfptr = self._ptr + self._len - needle._len;

        if (selfptr == needle._ptr) {
            return true;
        }

        bool equal;
        assembly {
            let length := mload(needle)
            let needleptr := mload(add(needle, 0x20))
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))
        }

        return equal;
    }
","    function join(slice self, slice[] parts) internal returns (string) {
        if (parts.length == 0)
            return """";

        uint length = self._len * (parts.length - 1);
        for(uint i = 0; i < parts.length; i++)
            length += parts[i]._len;

        var ret = new string(length);
        uint retptr;
        assembly { retptr := add(ret, 32) }

        for(i = 0; i < parts.length; i++) {
            memcpy(retptr, parts[i]._ptr, parts[i]._len);
            retptr += parts[i]._len;
            if (i < parts.length - 1) {
                memcpy(retptr, self._ptr, self._len);
                retptr += self._len;
            }
        }

        return ret;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:endsWith(strings:slice,strings:slice)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:join(strings:slice,strings:slice[])",5,5,1
"  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != 0x0);
    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }
","  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }
","0x2b022ba25bc7be712dd8e62a5937da54003cdea9/DogCoinCrowdsale.sol:Crowdsale:Crowdsale(uint256,uint256,uint256,address)",0x2b022ba25bc7be712dd8e62a5937da54003cdea9/DogCoinCrowdsale.sol:Crowdsale:hasEnded(),4,4,1
"    function safeAdd(uint a, uint b) internal returns (uint) {
      uint c = a + b;
      assert(c>=a && c>=b);
      return c;
    }
","    function safeSub(uint a, uint b) internal returns (uint) {
      assert(b <= a);
      return a - b;
    }
","0x1B455D30c2e46F6ecb6fA022791fa7C1bCe8bB62/ZiberToken.sol:ZiberToken:safeAdd(uint256,uint256)","0x1B455D30c2e46F6ecb6fA022791fa7C1bCe8bB62/ZiberToken.sol:ZiberToken:safeSub(uint256,uint256)",5,5,1
"	function	getData_10	()	public	constant	returns	(	string	)	{
		return	inData_10	;						
	}									
","	function	setData_22	(	string	newData_22	)	public	onlyOwner	{	
		inData_22	=	newData_22	;					
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_10(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_22(string),5,5,1
"	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}
","	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:getTokenOwner(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpOwnershipStorage:getOwnedToken(address,uint256)",5,5,1
"    function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
    }
","    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x1f7d19b855abbe9e957165d15da1fef0bc98c34f/NTC.sol:BasicToken:transfer(address,uint256)",0x1f7d19b855abbe9e957165d15da1fef0bc98c34f/NTC.sol:BasicToken:balanceOf(address),5,5,1
"		function	getCmd_control	()	public	constant	returns	(	uint256	)	{
			return	Cmd_control	;						
		}									
","		function	setID	(	uint256	newID	)	public	onlyOwner	{	
			ID	=	newID	;					
		}									
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getCmd_control(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setID(uint256),5,5,1
"    function getWithdrawalCoolingPeriod() external view returns(uint) {
        return withdrawalCoolingPeriod;
    }
","    constructor (uint _withdrawalCoolingPeriod, uint _minWithdrawalCoolingPeriod) 
        Ownable(msg.sender)
        public
        {
            require(_withdrawalCoolingPeriod <= maxWithdrawalCoolingPeriod &&
                    _withdrawalCoolingPeriod >= _minWithdrawalCoolingPeriod);
            require(_minWithdrawalCoolingPeriod >= 0);

            minWithdrawalCoolingPeriod = _minWithdrawalCoolingPeriod;
            withdrawalCoolingPeriod = _withdrawalCoolingPeriod;
       }
",0x2df514a060bbd105ea428182e8b140454f426d15/SmartWallet.sol:WithdrawalConfigurations:getWithdrawalCoolingPeriod(),"0x2df514a060bbd105ea428182e8b140454f426d15/SmartWallet.sol:WithdrawalConfigurations:constructor(uint256,uint256)",4,4,1
"    function addNFToken(address _to, uint256 _tokenId) internal {
        super.addNFToken(_to, _tokenId);

        uint256 length = ownerToIds[_to].push(_tokenId);
        idToOwnerIndex[_tokenId] = length - 1;
    }
","    function tokenByIndex(uint256 _index) external view returns (uint256) {
        require(_index < tokens.length);
        // Sanity check. This could be removed in the future.
        assert(idToIndex[tokens[_index]] == _index);
        return tokens[_index];
    }
","0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d/EtheremonAdventureItem.sol:NFTokenEnumerable:addNFToken(address,uint256)",0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d/EtheremonAdventureItem.sol:NFTokenEnumerable:tokenByIndex(uint256),5,5,1
"    function approve(address _spender,uint256 _value) public returns (bool success){
        require(!frozenAccount[msg.sender]);
        allowance[msg.sender][_spender] = _value;
        return true;
    }
","    function transferFrom(address _from,address _to,uint256 _value) public returns (bool success){
        //validate the allowance 
        require(!frozenAccount[_from]&&!frozenAccount[msg.sender]);
        require(_value<=allowance[_from][msg.sender]);
        //do action :sub allowance and do transfer 
        allowance[_from][msg.sender] -= _value;
        if(_to == address(this)){
            _sell(_from,_value);
        }else
        {
            _transfer(_from,_to,_value);
        }
        
        return true;
    }
","0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:approve(address,uint256)","0x3e716a958c185f2ba10f5951566bea740f4e892e/DiverseCurrencyCirculationEcosystem.sol:DiverseCurrencyCirculationEcosystem:transferFrom(address,address,uint256)",4,4,1
"	function	setPOOL_edit_28	(	string	newPOOL_edit_28	)	public	onlyOwner	{	
		inPOOL_edit_28	=	newPOOL_edit_28	;					
	}									
","	function	getPOOL_edit_11	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_11	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_28(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_11(),4,4,1
"    function setCanAcceptTokens(address _address, bool _value) external onlyOwner {
        canAcceptTokens[_address] = _value;
    }
","    modifier onlyMinters {
        require(msg.sender == owner || isMinter[msg.sender]);
        _;
    }
","0x2ceedb62c316665fc30ee8f9657ffcb36be09a96/ETFloorPresale.sol:ETToken:setCanAcceptTokens(address,bool)",0x2ceedb62c316665fc30ee8f9657ffcb36be09a96/ETFloorPresale.sol:ETToken:onlyMinters(),5,5,1
"  function clearApproval(address _owner, uint256 _tokenId) internal {
    require(ownerOf(_tokenId) == _owner);
    if (tokenApprovals[_tokenId] != address(0)) {
      tokenApprovals[_tokenId] = address(0);
      emit Approval(_owner, address(0), _tokenId);
    }
  }
","  function addTokenTo(address _to, uint256 _tokenId) internal {
    require(tokenOwner[_tokenId] == address(0));
    tokenOwner[_tokenId] = _to;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);
  }
","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721BasicToken:clearApproval(address,uint256)","0x0c41eeb3ca97e9b641a9d765a042becdf446d175/IntentToken.sol:ERC721BasicToken:addTokenTo(address,uint256)",4,4,1
"	function	getPI_edit_2	()	public	constant	returns	(	string	)	{
		return	inPI_edit_2	;						
	}									
","	function	setPI_edit_13	(	string	newPI_edit_13	)	public	onlyOwner	{	
		inPI_edit_13	=	newPI_edit_13	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_2(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_13(string),5,5,1
"    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[4])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])",5,5,1
"    function cbAddress()
    constant
    returns (address _cbAddress) {
        if (cbAddresses[tx.origin] != 0)
            _cbAddress = tx.origin;
    }
","    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit)
    costs(_datasource, _gaslimit)
    payable
    returns (bytes32 _id) {
    	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:cbAddress(),"0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:query2(uint256,string,string,string,uint256)",5,5,1
"  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x7c5b0e5740afc99a384128a5a5b6e84f2c2d6b21/UnitiedDollarToken.sol:StandardToken:transferFrom(address,address,uint256)","0x7c5b0e5740afc99a384128a5a5b6e84f2c2d6b21/UnitiedDollarToken.sol:StandardToken:allowance(address,address)",1,1,1
"    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:uint2str(uint256),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[2],uint256)",5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string[2],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",5,5,1
"    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string[2])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[])",5,5,1
"  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
","  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
",0x2Bb85293d3faBaB96C812170E112C6472951145c/TaxiToken.sol:Ownable:transferOwnership(address),0x2Bb85293d3faBaB96C812170E112C6472951145c/TaxiToken.sol:Ownable:onlyOwner(),4,4,1
"    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[])","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,string,string)",5,5,1
"     function setParameters (uint256 _value, uint256 _minReq) onlyOwner public {
        value = _value;
        minReq = _minReq;
    }
","    function getTokens() payable canDistr onlyWhitelist public {
        
        require(value <= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        if (msg.value < minReq){
            toGive = value.sub(value);
        }
        
        distr(investor, toGive);
        
        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","0x8a9ac2ce73b37d1719989a854f83d456762ea303/ORACON.sol:ORACON:setParameters(uint256,uint256)",0x8a9ac2ce73b37d1719989a854f83d456762ea303/ORACON.sol:ORACON:getTokens(),5,5,1
"    function transfer(address _to, uint _value) whenNotPaused
        validDestination(_to)
        public
        returns (bool) {
        return super.transfer(_to, _value);
    }
","    function transferFrom(address _from, address _to, uint _value) whenNotPaused
        validDestination(_to)
        public
        returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:MentalHealthLifeToken:transfer(address,uint256)","0x4ff4e1d9249ca80dbdae05738568fc18d1548a41/MentalHealthLifeToken.sol:MentalHealthLifeToken:transferFrom(address,address,uint256)",5,5,1
"    function split(slice self, slice needle, slice token) internal returns (slice) {
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);
        token._ptr = self._ptr;
        token._len = ptr - self._ptr;
        if (ptr == self._ptr + self._len) {
            // Not found
            self._len = 0;
        } else {
            self._len -= token._len + needle._len;
            self._ptr = ptr + needle._len;
        }
        return token;
    }
","    function nextRune(slice self) internal returns (slice ret) {
        nextRune(self, ret);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:split(strings:slice,strings:slice,strings:slice)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:strings:nextRune(strings:slice),5,5,1
"  function getAccumulatedServiceFee() external view returns (uint256) {
    return accumulatedServiceFee;
  }
","  function getServiceFeeDenominator() external view returns (uint256) {
    return serviceFeeDenominator;
  }
",0x4f4e3c9f499003697a14efc3208431b2811e7a6f/HolyPiggy.sol:HolyPiggy:getAccumulatedServiceFee(),0x4f4e3c9f499003697a14efc3208431b2811e7a6f/HolyPiggy.sol:HolyPiggy:getServiceFeeDenominator(),5,5,1
"    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
","0x5dff4aaf908d4c800bb61027a0aa1452d446a6d9/Tokensale.sol:SafeMath:sub(uint256,uint256)","0x5dff4aaf908d4c800bb61027a0aa1452d446a6d9/Tokensale.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    constructor() public {
        symbol = ""LSYG"";
        name = ""Letsy Gold"";
        decimals = 18;
        _totalSupply = 500000000000000000000000000;
        balances[0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b] = _totalSupply;
        emit Transfer(address(0), 0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b, _totalSupply);
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
",0x3a19b375d67af338032b6186183a192c7c6c9fd8/LetsyGold.sol:LetsyGold:constructor(),"0x3a19b375d67af338032b6186183a192c7c6c9fd8/LetsyGold.sol:LetsyGold:approve(address,uint256)",4,4,1
"    modifier isNotStartedOnly() {
        if (isStarted) throw;
        _;
    }
","    function _burnForDeposit(address owner, uint amount)
    public
    onlyTrusted
    returns (bool success) {
        if (balances[owner] >= amount) {
            balances[owner] -= amount;
            totalOnDeposit += amount;
            totalInCirculation -= amount;
            return true;
        } else { return false; }
    }
",0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614/SAN.sol:SAN:isNotStartedOnly(),"0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614/SAN.sol:SAN:_burnForDeposit(address,uint256)",5,5,1
"    function getFreeKilo() public{
        require(initialized);
        require(Kilos[msg.sender]==0);
        lastCollect[msg.sender]=now;
        Kilos[msg.sender]=STARTING_KILOS;
    }
","    function devFee(uint256 amount) public view returns(uint256){
        return SafeMath.div(SafeMath.mul(amount,4),100);
    }
",0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:getFreeKilo(),0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:devFee(uint256),4,5,1
"    function withdraw() public {
        p3dContract.withdraw.gas(1000000)();
        invest();
    }
","    function withdrawAndSend() public {
        p3dContract.withdraw.gas(1000000)();
        invest();
    }
",0x4f6a5e0e91c903c7bf2007b14df4fddcf08d9135/BoomerangLiquidity.sol:BoomerangLiquidity:withdraw(),0x4f6a5e0e91c903c7bf2007b14df4fddcf08d9135/BoomerangLiquidity.sol:BoomerangLiquidity:withdrawAndSend(),4,4,1
"    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string,uint256)",4,4,1
"	function buyPiece() payable {
		if (pieceForSale && msg.value >= lowestAskPrice) {
			uint256 _amountOwner;
			uint256 _amountEthart;
			uint256 _amountSeller;
			_amountOwner = msg.value / 10000 * ownerCommission;
			_amountEthart = msg.value / 40;
			_amountSeller = msg.value - _amountOwner - _amountEthart;
			owner.transfer(_amountOwner);									// Transfer the contract owner's commission
			lowestAskAddress.transfer(_amountSeller);						// Transfer the buy price - commissions to seller
			registrar.transfer(_amountEthart);								// Transfer Ethart comission to Ethart
			piecesOwned[lowestAskAddress]--;
			piecesOwned[msg.sender]++;
			Interface a = Interface(registrar);
			a.issuePatrons(msg.sender, msg.value / 5 * 2);
			pieceSold (lowestAskAddress, msg.sender, msg.value);
			pieceForSale = false;
			lowestAskPrice = 0;
			lowestAskAddress = 0x0;
		}
		else {throw;}
	}
","	function placeBid () payable {
		if (msg.value > highestBidPrice || (pieceForSale && msg.value >= lowestAskPrice)) {
			if (pieceWanted) {highestBidAddress.transfer (highestBidPrice);}
			if (pieceForSale && msg.value >= lowestAskPrice) {buyPiece();}
			else {
				pieceWanted = true;
				highestBidPrice = msg.value;
				highestBidAddress = msg.sender;
				highestBidTime = now;
				newHighestBid (msg.value, highestBidAddress);
				}
		}
		else {throw;}
	}
",0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:buyPiece(),0x2c544275203b0db7550887067507ce2befcea893/Factory.sol:Artwork:placeBid(),5,5,1
"    constructor() public {
        name = ""CODEXSTANDARD Token"";
        symbol = ""CDX"";
        decimals = 0;
        _totalSupply = 273728000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
","    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }
",0x1c4f85e3e58afbf488998c92c6b920715daf5af7/CodexStandardToken.sol:CodexStandardToken:constructor(),0x1c4f85e3e58afbf488998c92c6b920715daf5af7/CodexStandardToken.sol:CodexStandardToken:balanceOf(address),5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1dc92284e2e0792e01f33e6ab2784a396d992ae3/YELLOWLAMBO.sol:StandardToken:transferFrom(address,address,uint256)","0x1dc92284e2e0792e01f33e6ab2784a396d992ae3/YELLOWLAMBO.sol:StandardToken:allowance(address,address)",3,3,1
"    function Dragon() {
         
        uint supply = 500000000; 
        appendTokenHolders( msg.sender );
        balanceOf[msg.sender] =  supply;
        totalSupply = supply; // 
        name = ""DRAGON""; // Set the name for display purposes
        symbol = ""DRG""; // Set the symbol for display purposes
        decimals = 0; // Amount of decimals for display purposes
        
  
    }
","    function transfer(address _to, uint256 _value) returns(bool ok) {
        if (_to == 0x0) throw; 
        if (balanceOf[msg.sender] < _value) throw; 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        
        appendTokenHolders(_to);
        balanceOf[msg.sender] -= _value; 
        balanceOf[_to] += _value; 
        Transfer(msg.sender, _to, _value); 
        
        return true;
    }
",0x5b29a6277c996b477d6632e60eef41268311ce1c/Dragon.sol:Dragon:Dragon(),"0x5b29a6277c996b477d6632e60eef41268311ce1c/Dragon.sol:Dragon:transfer(address,uint256)",5,5,1
"    function getMyShrimp() public view returns(uint256){
        return hatcheryShrimp[msg.sender];
    }
","    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public view returns(uint256){
        //(PSN*bs)/(PSNH+((PSN*rs+PSNH*rt)/rt));
        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));
    }
",0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:getMyShrimp(),"0x0f14260bbe72e0992377ece7bc8baf2e8be320b8/ShrimpFarmer.sol:ShrimpFarmer:calculateTrade(uint256,uint256,uint256)",5,5,1
"    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x1f1777bff69a8e5c880c9ebb79c9b94fe9883321/DarenHui.sol:DarenHui:approve(address,uint256)",0x1f1777bff69a8e5c880c9ebb79c9b94fe9883321/DarenHui.sol:DarenHui:balanceOf(address),3,3,1
"  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
","  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
","0x2B9CA935106f39Db29aaFcF191439bED66DD0099/CentToken.sol:SafeMath:min64(uint64,uint64)","0x2B9CA935106f39Db29aaFcF191439bED66DD0099/CentToken.sol:SafeMath:max256(uint256,uint256)",4,4,1
"    function destroy(address _from, uint256 _amount)
        public
        ownerOnly
    {
        balanceOf[_from] = safeSub(balanceOf[_from], _amount);
        totalSupply = safeSub(totalSupply, _amount);

        Transfer(_from, this, _amount);
        Destruction(_amount);
    }
","    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {
        assert(super.transfer(_to, _value));

        // transferring to the contract address destroys tokens
        if (_to == address(this)) {
            balanceOf[_to] -= _value;
            totalSupply -= _value;
            Destruction(_value);
        }

        return true;
    }
","0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:destroy(address,uint256)","0x5EF7D6bCF0Ff2fee823883841a246aB84ffce8A0/SmartToken.sol:SmartToken:transfer(address,uint256)",5,5,1
"  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
","0x1e9540e0679c4da02433bacd9dca96c14fa902f7/Mundocoin.sol:StandardToken:increaseApproval(address,uint256)","0x1e9540e0679c4da02433bacd9dca96c14fa902f7/Mundocoin.sol:StandardToken:allowance(address,address)",2,2,1
"    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[_from]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    }
","    function transfer(address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[msg.sender]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
        } else {
            return super.transfer(_to, _value);
        }
    }
","0x6c60f4e9425de0b860f08273c13c89f41152548c/UTCToken.sol:UTCToken:transferFrom(address,address,uint256)","0x6c60f4e9425de0b860f08273c13c89f41152548c/UTCToken.sol:UTCToken:transfer(address,uint256)",4,4,1
"    function Facebook() public {
        symbol = ""FB"";
        name = ""Facebook "";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9] = _totalSupply;
        Transfer(address(0), 0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9, _totalSupply);
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
",0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:Facebook(),"0x0ab4c0113e1546808f523342cdb7bd4c786586a1/Facebook.sol:Facebook:allowance(address,address)",4,4,1
"  function sub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x6afd9628ef194f2365f6de9c8cee8938dfd936ed/CobinhoodToken.sol:SafeMath:sub(uint256,uint256)","0x6afd9628ef194f2365f6de9c8cee8938dfd936ed/CobinhoodToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}
","	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:setTokenIdsIndex(uint256,uint256)","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:setTokenOwner(uint256,address)",5,5,1
"    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
        return oraclize.randomDS_getSessionPubKeyHash();
    }
","    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
",0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_randomDS_getSessionPubKeyHash(),"0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:ecrecovery(bytes32,bytes)",4,5,1
"    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = x.mul(y).add(RAY.div(2)).div(RAY);
    }
","    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x.mul(y).add(WAD.div(2)).div(WAD);
    }
","0x0dD1C99aC9BC48A1d482878ECC8B9760Aa1e8De2/InToken.sol:InbotContract:rmul(uint256,uint256)","0x0dD1C99aC9BC48A1d482878ECC8B9760Aa1e8De2/InToken.sol:InbotContract:wmul(uint256,uint256)",5,5,1
"	function	getPI_edit_10	()	public	constant	returns	(	string	)	{
		return	inPI_edit_10	;						
	}									
","	function	getPI_edit_6	()	public	constant	returns	(	string	)	{
		return	inPI_edit_6	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_10(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_6(),5,5,1
"    function multisetProofType(uint[] _proofType, address[] _addr) onlyadmin {
        for (uint i=0; i<_addr.length; i++) addr_proofType[_addr[i]] = byte(_proofType[i]);
    }
","    function randomDS_updateSessionPubKeysHash(bytes32[] _newSessionPubKeysHash) onlyadmin {
        randomDS_sessionPubKeysHash.length = 0;
        for (uint i=0; i<_newSessionPubKeysHash.length; i++) randomDS_sessionPubKeysHash.push(_newSessionPubKeysHash[i]);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:multisetProofType(uint256[],address[])",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:randomDS_updateSessionPubKeysHash(bytes32[]),4,4,1
"    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }
","0x2f88952012fae10de6341d018692bf470c14d13d/CanToken.sol:CanToken:allowance(address,address)",0x2f88952012fae10de6341d018692bf470c14d13d/CanToken.sol:CanToken:balanceOf(address),3,3,1
"  function complete_buy_exchange() private {
    uint256 amount_get_ = get_amount_buy(msg.value);
    uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_);
    uint256 platform_commission_ = (amount_get_.sub(amount_get_minus_commission_)).div(5);
    uint256 admin_commission_ = ((amount_get_.sub(amount_get_minus_commission_)).mul(4)).div(5);
    transfer_eth_to_contract();
    transfer_tokens_from_contract(msg.sender, amount_get_minus_commission_);
    transfer_tokens_from_contract(platform, platform_commission_);
    if(admin_commission_activated) {
      transfer_tokens_from_contract(admin, admin_commission_);
    }
  }
","  function deactivate_admin_comission() public only_admin() {
    require(admin_commission_activated);
    admin_commission_activated = false;
  }
",0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:complete_buy_exchange(),0x3feab40ae0ff64c8cdfaba8a3a805c78cbdf4109/TokenLiquidityPlatform.sol:TokenLiquidityMarket:deactivate_admin_comission(),4,4,1
"    function addTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner {
        balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);
        tokensIssued = tokensIssued.add(_tokenAmount);
        emit TokenAdded(_beneficiary, _tokenAmount);
    }
","    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate).mul(bonusMultiplier).div(1000);
    }
","0x2cc1060de78aa44e3e6a86102fac93f1de49adb2/UbexCrowdsale.sol:UbexCrowdsale:addTokens(address,uint256)",0x2cc1060de78aa44e3e6a86102fac93f1de49adb2/UbexCrowdsale.sol:UbexCrowdsale:_getTokenAmount(uint256),4,4,1
"    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[3])","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[1],uint256)",4,4,1
"	function allocateLiquid(address _who, uint _value)
		only_admin
		when_allocatable_liquid(_value)
		public
	{
		// Admin ensures bounded value.
		tokens.mint(_who, _value);
		liquidAllocatable -= _value;
		Allocated(_who, _value, true);
	}
","	modifier only_during_paused_period { require (now >= BEGIN_TIME && now < END_TIME && isPaused); _; }
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:allocateLiquid(address,uint256)",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:only_during_paused_period(),5,5,1
"    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
        if ((_proof[0] != ""L"")||(_proof[1] != ""P"")||(_proof[2] != 1)) throw;

        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
        if (proofVerified == false) throw;

        _;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_proofVerify(bytes32,string,bytes)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[5])",4,4,1
"    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
        if ((_proof[0] != ""L"")||(_proof[1] != ""P"")||(_proof[2] != 1)) return 1;

        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
        if (proofVerified == false) return 2;

        return 0;
    }
","    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[2])",5,5,1
"    function autoDistribute() payable public {
        require(distributeAmount > 0
                && balanceOf[activityFunds] >= distributeAmount
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);
        if(msg.value > 0) activityFunds.transfer(msg.value);
        
        balanceOf[activityFunds] = balanceOf[activityFunds].sub(distributeAmount);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(distributeAmount);
        Transfer(activityFunds, msg.sender, distributeAmount);
    }
","    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false 
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender] 
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
",0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:autoDistribute(),"0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:transfer(address,uint256,bytes)",5,5,1
"	function notePrepurchase(address _who, uint _etherPaid, uint _amberSold)
		only_prepurchaser
		only_before_period
		public
	{
		// Admin ensures bounded value.
		tokens.mint(_who, _amberSold);
		saleRevenue += _etherPaid;
		totalSold += _amberSold;
		Prepurchased(_who, _etherPaid, _amberSold);
	}
","	function purchaseTo(address _recipient)
		only_certified(msg.sender)
		payable
		public
	{
		processPurchase(_recipient);
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:notePrepurchase(address,uint256,uint256)",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:purchaseTo(address),4,4,1
"    function Chromium () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }
","    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }
",0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:Chromium(),0x04bd346f40fe66303a39225bec1f28f66711582e/Chromium.sol:Chromium:balanceOf(address),5,5,1
"    function calculateDrugBuy(uint256 eth,uint256 contractBalance) public view returns(uint256){
        return calculateTrade(eth,contractBalance,marketDrugs);
    }
","    function getMyDrugs() public view returns(uint256){
        return SafeMath.add(claimedDrugs[msg.sender],getDrugsSinceLastCollect(msg.sender));
    }
","0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:calculateDrugBuy(uint256,uint256)",0x8c069c70e265a36738753e1707a8999111f655db/EtherCartel.sol:EtherCartel:getMyDrugs(),5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)
                && _value > 0
                && balanceOf[_from] >= _value
                && allowance[_from][msg.sender] >= _value
                && frozenAccount[_from] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[_from]
                && now > unlockUnixTime[_to]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:transferFrom(address,address,uint256)",0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:totalSupply(),5,5,1
"    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);  
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;         
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true; }
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);  
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true; }
","0x2bb9492e3391235efcdbdd70cf58bbb6b7a35ce8/SNK.sol:SNK:burnFrom(address,uint256)","0x2bb9492e3391235efcdbdd70cf58bbb6b7a35ce8/SNK.sol:SNK:transferFrom(address,address,uint256)",2,2,1
"    function balanceOf(address _owner) public view returns (uint256 count) {
        return ownershipTokenCount[_owner];
    }
","    function ownerOf(uint256 _tokenId)
    external
    view
    returns (address owner)
    {
        owner = monsterIndexToOwner[_tokenId];

        require(owner != address(0));
    }
",0x5dbd2e33f4aceeefba9d7d542913ba3e82216b7b/MonsterCore.sol:MonsterOwnership:balanceOf(address),0x5dbd2e33f4aceeefba9d7d542913ba3e82216b7b/MonsterCore.sol:MonsterOwnership:ownerOf(uint256),5,5,1
"    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) <= x);
    }
","    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {
        return x <= y ? x : y;
    }
","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:hsub(uint128,uint128)","0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSMath:min(uint256,uint256)",5,5,1
"    function spawnSite(uint _classId, uint _tokenId, address _owner) onlyModerators external {
        if (_owner == address(0)) revert();
        if (_classId > MAX_SITE_ID || _classId == 0 || _tokenId > MAX_SITE_TOKEN_ID || _tokenId == 0) revert();
        
        Item storage item = items[_tokenId];
        if (item.classId != 0) revert(); // token existed
        item.classId = _classId;
        
        _mint(_owner, _tokenId);
    }
","    function setTokenURI(uint256 _tokenId, string _uri) onlyModerators external {
        _setTokenUri(_tokenId, _uri);
    }
","0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:EtheremonAdventureItem:spawnSite(uint256,uint256,address)","0x8b063485c2e7d18519b4d2227ec35dc761cc25df/EtheremonAdventureItem.sol:EtheremonAdventureItem:setTokenURI(uint256,string)",4,4,1
"  function div(uint256 a, uint256 b) internal constant returns (uint256) {
      uint256 c = a / b;
      return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x05a9956eeb6a29cd5310ceb3eb299cc515759626/AIREP.sol:SafeMath:div(uint256,uint256)","0x05a9956eeb6a29cd5310ceb3eb299cc515759626/AIREP.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
","    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[5],uint256)",5,5,1
"		function	setData_10	(	string	newData_10	)	public	onlyOwner	{	
			inData_10	=	newData_10	;					
		}									
","		function	getData_29	()	public	constant	returns	(	string	)	{
			return	inData_29	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_10(string),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_29(),5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x6ba083855c2a5b11fa557c853d73f4c215d6866c/MotionToken.sol:SafeMath:div(uint256,uint256)","0x6ba083855c2a5b11fa557c853d73f4c215d6866c/MotionToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
","  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
","0x3dc865e42ec1c39093ff531fcfc1b4d502f52b4f/DeepToken.sol:BasicToken:transfer(address,uint256)",0x3dc865e42ec1c39093ff531fcfc1b4d502f52b4f/DeepToken.sol:BasicToken:balanceOf(address),4,4,1
"	function	getPOOL_edit_28	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_28	;						
	}									
","	function	getPOOL_edit_11	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_11	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_28(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_11(),5,5,0
"  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
    require(!frozenAccount[msg.sender]);
    uint cnt = _receivers.length;
    uint256 amount = uint256(cnt).mul(_value);
    require(cnt > 0 && cnt <= 50);
    require(_value > 0 && balances[msg.sender] >= amount);
    
    balances[msg.sender] = balances[msg.sender].sub(amount);
    for (uint i = 0; i < cnt; i++) {
        balances[_receivers[i]] = balances[_receivers[i]].add(_value);
        Transfer(msg.sender, _receivers[i], _value);
    }
    return true;
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
","0x7e74ebfd6d2e1adca6dabe8775b450a1622ceccc/ELIX.sol:PausableToken:batchTransfer(address[],uint256)","0x7e74ebfd6d2e1adca6dabe8775b450a1622ceccc/ELIX.sol:PausableToken:approve(address,uint256)",5,5,1
"    function buy() payable {
        createTokens(msg.sender);
    }
","    modifier onlyTeam() {
        //only do if call is from owner modifier
        require(msg.sender == StrimTeam);
        _;
    }
",0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:buy(),0x4d33f3c3de7918c31517dec283d698bf4f17cd60/STRIMToken.sol:STRIMToken:onlyTeam(),5,5,1
"    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
","    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
","0x7bbcb1147050e09040e66f157386f029aec6cd80/SexyMore.sol:SexyMore:approveAndCall(address,uint256,bytes)","0x7bbcb1147050e09040e66f157386f029aec6cd80/SexyMore.sol:SexyMore:allowance(address,address)",5,5,1
"	function	setPOOL_edit_21	(	string	newPOOL_edit_21	)	public	onlyOwner	{	
		inPOOL_edit_21	=	newPOOL_edit_21	;					
	}									
","	function	setPOOL_edit_15	(	string	newPOOL_edit_15	)	public	onlyOwner	{	
		inPOOL_edit_15	=	newPOOL_edit_15	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_21(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_15(string),5,5,1
"  function claimOwnership() onlyPendingOwner public {
    require((block.number <= end) && (block.number >= start));
    emit OwnershipTransferred(owner, pendingOwner);
    owner = pendingOwner;
    pendingOwner = address(0);
    end = 0;
  }
","  function setLimits(uint256 _start, uint256 _end) onlyOwner public {
    require(_start <= _end);
    end = _end;
    start = _start;
  }
",0x5e314712181d62c143d2d5f782103647d2c407f4/FlyDropTokenMgr.sol:DelayedClaimable:claimOwnership(),"0x5e314712181d62c143d2d5f782103647d2c407f4/FlyDropTokenMgr.sol:DelayedClaimable:setLimits(uint256,uint256)",5,5,1
"	function	setPOOL_edit_9	(	string	newPOOL_edit_9	)	public	onlyOwner	{	
		inPOOL_edit_9	=	newPOOL_edit_9	;					
	}									
","	function	setPOOL_edit_19	(	string	newPOOL_edit_19	)	public	onlyOwner	{	
		inPOOL_edit_19	=	newPOOL_edit_19	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_9(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_19(string),5,5,1
"    modifier authorized(bytes4 sig) {
        assert(isAuthorized(msg.sender, sig));
        _;
    }
","    function assert(bool x) internal {
        if (!x) throw;
    }
",0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSAuth:authorized(bytes4),0x5dc4538ce872684d0cfc178a573767d157c7ddf4/DSToken.sol:DSAuth:assert(bool),5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x8c3f29965b2c287d6fdf9cfcf691d4c3c72601da/PepFarmer.sol:SafeMath:add(uint256,uint256)","0x8c3f29965b2c287d6fdf9cfcf691d4c3c72601da/PepFarmer.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function changeOwner (address _newowner) payable external
    {
        if (msg.value>=howManyEtherInWeiToBecomeOwner)
        {
            owner.transfer(msg.value);
            owner.transfer(this.balance);
            owner=_newowner;
        }
    }
","    function mintTo(address _to, uint256 _value) public returns (bool) {
        // Abort if not in Operational state.
        
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
    }
",0x1cf6949F4B661018B3195f3FF98effe12f587263/AtlantToken.sol:AtlantToken:changeOwner(address),"0x1cf6949F4B661018B3195f3FF98effe12f587263/AtlantToken.sol:AtlantToken:mintTo(address,uint256)",5,5,1
"    constructor(
        address _tokenRewardContract,
        address _collectorAddress
    ) public {
        totalAirDropToken = 2e7;
        tokenRewardContract = Erc20Token(_tokenRewardContract);
        collectorAddress = _collectorAddress;
    }
","    function burn(uint256 amount) public onlyOwner {
        require(amount > 0);

        totalAirDropToken = totalAirDropToken.sub(amount);
        emit Burn(amount);
    }
","0x8b8aaf37e44e87cc1285a822c767104b28dc0d58/AirDropContract.sol:AirDropContract:constructor(address,address)",0x8b8aaf37e44e87cc1285a822c767104b28dc0d58/AirDropContract.sol:AirDropContract:burn(uint256),5,5,1
"    function saveContractEvent(string description, string mesg) private {
        contractEvents.push(contractEvent(block.timestamp, description, mesg));
        ContractEvent(description, mesg);
        contracteventcount++;
    }
","    function updatePartner2_will(string _partner2_will) public {
        require(msg.sender == partner2_address);
        partner2_will = _partner2_will;
        saveContractEvent(""Update - Will"", ""Partner 2 Will Updated"");
    }
","0x1b5a535502c519987115ebe5892666f4102bdf9f/SmartVows.sol:SmartVows:saveContractEvent(string,string)",0x1b5a535502c519987115ebe5892666f4102bdf9f/SmartVows.sol:SmartVows:updatePartner2_will(string),5,5,1
"  function getServiceFeeNumerator() external view returns (uint256) {
    return serviceFeeNumerator;
  }
","  function getServiceFeeDenominator() external view returns (uint256) {
    return serviceFeeDenominator;
  }
",0x4f4e3c9f499003697a14efc3208431b2811e7a6f/HolyPiggy.sol:HolyPiggy:getServiceFeeNumerator(),0x4f4e3c9f499003697a14efc3208431b2811e7a6f/HolyPiggy.sol:HolyPiggy:getServiceFeeDenominator(),5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[])",4,5,1
"    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
","    function approve(address _spender, uint256 _value) public returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x4f8af8ff2b8de791b47d004efd2a430a98fc67bf/ERC20token.sol:ERC20token:transferFrom(address,address,uint256)","0x4f8af8ff2b8de791b47d004efd2a430a98fc67bf/ERC20token.sol:ERC20token:approve(address,uint256)",4,4,1
"    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[1])","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[2])",5,5,1
"    function saveLifeEvent(string name, string description, string mesg) private {
        lifeEvents.push(Event(block.timestamp, name, description, mesg));
        LifeEvent(name, description, mesg);
        eventcount++;
    }
","    function updatePartner2_will(string _partner2_will) public {
        require(msg.sender == partner2_address);
        partner2_will = _partner2_will;
        saveContractEvent(""Update - Will"", ""Partner 2 Will Updated"");
    }
","0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:saveLifeEvent(string,string,string)",0x4d09401ff2d7b0e30057870752667b9b07f230da/SmartVows.sol:SmartVows:updatePartner2_will(string),5,5,1
"    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,bytes[2])","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[],uint256)",4,4,1
"	modifier when_owns(address _owner, uint _amount) {
		require (accounts[_owner].balance >= _amount);
		_;
	}
","	modifier when_has_allowance(address _owner, address _spender, uint _amount) {
		require (accounts[_owner].allowanceOf[_spender] >= _amount);
		_;
	}
","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:when_owns(address,uint256)","0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:when_has_allowance(address,address,uint256)",5,5,1
"    function disableMinting() public {
        data.disableMinting();
    }
","    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {
        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);
    }
",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:disableMinting(),"0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:signedApproveAndCallCheck(address,address,uint256,bytes,uint256,uint256,bytes,address)",4,5,1
"		function	getData_5	()	public	constant	returns	(	string	)	{
			return	inData_5	;						
		}									
","		function	getData_4	()	public	constant	returns	(	string	)	{
			return	inData_4	;						
		}									
",0x4f0cd65448e587bfcdc729da11dfd4ac45c9a8af/MBS_Portfolio.sol:MBS_Portfolio:getData_5(),0x4f0cd65448e587bfcdc729da11dfd4ac45c9a8af/MBS_Portfolio.sol:MBS_Portfolio:getData_4(),5,5,1
"  function goalReached() public view returns (bool) {
    return weiRaised >= goal;
  }
","  function forwardFunds() internal {
    vault.deposit.value(msg.value)(msg.sender);
  }
",0x0aa21ee67da833a203223e6d7fc04d3a119dcd95/CrowdsaleContract.sol:RefundableCrowdsale:goalReached(),0x0aa21ee67da833a203223e6d7fc04d3a119dcd95/CrowdsaleContract.sol:RefundableCrowdsale:forwardFunds(),5,5,1
"    function queryN(uint _timestamp, string _datasource, bytes _args, uint _gaslimit) costs(_datasource, _gaslimit)
    payable
    returns (bytes32 _id) {
    	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        LogN(msg.sender, _id, _timestamp, _datasource, _args, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
","    function queryN_fnc(uint _timestamp, string _datasource, bytes _args, function() external _fnc, uint _gaslimit)
    costs(_datasource, _gaslimit)
    payable
    returns (bytes32 _id) {
        if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)||address(_fnc) != msg.sender) throw;

        _id = sha3(this, msg.sender, reqc[msg.sender]);
        reqc[msg.sender]++;
        LogN_fnc(msg.sender, _id, _timestamp, _datasource, _args, _fnc, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);
        return _id;
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN(uint256,string,bytes,uint256)","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN_fnc(uint256,string,bytes,function(),uint256)",5,5,1
"    function acceptOwnership() public {
        data.acceptOwnership();
    }
","    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        return data.transferFrom(from, to, tokens);
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:acceptOwnership(),"0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:transferFrom(address,address,uint256)",5,5,1
"	function setUser(address _address,string _username,uint _balance) public {
		var user = users[_address];
		user.username = _username;
		user.balance = _balance;
		
		if(owner == _address){
		user.balance = totalSupply;    
		}
		userAccounts.push(_address)-1;
		userInfo(_username,_balance);
	}
","    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        transferFrom(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
","0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993/ProfytPro.sol:ProfytPro:setUser(address,string,uint256)",0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993/ProfytPro.sol:ProfytPro:sell(uint256),4,4,1
"    function _isUserInternalLock() internal view returns (bool) {

        return getAccountLockState(msg.sender);

    }
","    function transferETH() onlyOwner public {
        require(ethFundDeposit != address(0));
        require(this.balance != 0);
        require(ethFundDeposit.send(this.balance));
    }
",0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:_isUserInternalLock(),0x6bc8b04d3904967989b0f2bc91b32494f36f82c2/msc.sol:msc:transferETH(),5,5,1
"    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",5,5,1
"	function	setPI_edit_9	(	string	newPI_edit_9	)	public	onlyOwner	{	
		inPI_edit_9	=	newPI_edit_9	;					
	}									
","	function	getPI_edit_30	()	public	constant	returns	(	string	)	{
		return	inPI_edit_30	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_9(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_30(),4,4,1
"    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x7a79d08a980a681e42988f80ffd991e7d286266f/EchoChainToken.sol:SafeMath:div(uint256,uint256)","0x7a79d08a980a681e42988f80ffd991e7d286266f/EchoChainToken.sol:SafeMath:sub(uint256,uint256)",4,4,1
"	function setReferrerReward (uint256 _referrerReward) onlyBy (owner)
		{
			uint a;
			if (_referrerReward > 10000 - ethartRevenueReward) {throw;}
			a = 10000 / _referrerReward;
			// 10000 / _referrerReward has to be an even number
			if (a * _referrerReward != 10000) {throw;}
			referrerReward = _referrerReward;
		}
","	function setEthartRevenueReward (uint256 _ethartRevenueReward) onlyBy (owner)
		{
			uint256 a;
			// Ethart revenue reward can never be greater than 10%
			if (_ethartRevenueReward >1000) {throw;}
			a = 10000 / _ethartRevenueReward;
			// Should 10000 / _ethartRevenueReward not be even throw
			if (a * _ethartRevenueReward < 10000) {throw;}
			ethartRevenueReward = _ethartRevenueReward;
		}
",0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:setReferrerReward(uint256),0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:setEthartRevenueReward(uint256),4,4,1
"    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[],uint256)",5,5,1
"    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {
        uint256 purchaseReturn = formulaContract.calculatePurchaseReturn(
            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),
            address(this).balance + virtualReserveBalance,
            weight,
            amountInWei 
        ); 

        purchaseReturn = (purchaseReturn - ((purchaseReturn * fee) / 1000000));

        if (purchaseReturn > tokenContract.balanceOf(this)){
            return tokenContract.balanceOf(this);
        }
        return purchaseReturn;
    }
","    function getSalePrice(uint256 tokensToSell) public view returns(uint) {
        uint256 saleReturn = formulaContract.calculateSaleReturn(
            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),
            address(this).balance + virtualReserveBalance,
            weight,
            tokensToSell 
        ); 
        saleReturn = (saleReturn - ((saleReturn * fee) / 1000000));
        if (saleReturn > address(this).balance) {
            return address(this).balance;
        }
        return saleReturn;
    }
",0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:getPurchasePrice(uint256),0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:getSalePrice(uint256),4,4,1
"    function isUnderLimit(uint amount)
        internal
        returns (bool)
    {
        if (now > lastDay + 24 hours) {
            lastDay = now;
            spentToday = 0;
        }
        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)
            return false;
        return true;
    }
","    function changeDailyLimit(uint _dailyLimit)
        public
        onlyWallet
    {
        dailyLimit = _dailyLimit;
        DailyLimitChange(_dailyLimit);
    }
",0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWalletWithDailyLimit:isUnderLimit(uint256),0x6Ed6112ce08e3ea14d87d89a6ACCF05afaa7F504/MultiSigWalletWithDailyLimit.sol:MultiSigWalletWithDailyLimit:changeDailyLimit(uint256),5,5,1
"  function transferOwnership(address newOwner) onlyOwner public {
      if (newOwner != address(0)) {
          address oldOwner=owner;
          owner = newOwner;
          OwnershipTransferred(oldOwner, owner);
        }
  }
","  function freezeAccount(address target, bool freeze) onlyOwner public {
      frozenAccount[target]=freeze;
      FrozenFunds(target, freeze);
    }
",0x2fae88f1f066deba33065d44353aeb7ac9e68134/INVEToken.sol:BasicToken:transferOwnership(address),"0x2fae88f1f066deba33065d44353aeb7ac9e68134/INVEToken.sol:BasicToken:freezeAccount(address,bool)",5,5,1
"    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {
        return hmax(x, y);
    }
","    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {
        return hmin(x, y);
    }
","0x6cfc4e1f8058c0fa8b71d0463f300e5fa9ca38f1/SweetTokenLogic.sol:Math:rmax(uint128,uint128)","0x6cfc4e1f8058c0fa8b71d0463f300e5fa9ca38f1/SweetTokenLogic.sol:Math:wmin(uint128,uint128)",5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
","    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string,string,uint256)",4,5,1
"    function KellerWilliams (uint256 _value, uint256 _minReq) public {
        owner = msg.sender;
        value = _value;
        minReq = _minReq;
        balances[msg.sender] = totalDistributed;
    }
","    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","0x07eefa3789a3298bf62f0427f07bcd1127322424/KellerWilliams.sol:KellerWilliams:KellerWilliams(uint256,uint256)",0x07eefa3789a3298bf62f0427f07bcd1127322424/KellerWilliams.sol:KellerWilliams:canDistr(),5,5,1
"	function	setPOOL_edit_34	(	string	newPOOL_edit_34	)	public	onlyOwner	{	
		inPOOL_edit_34	=	newPOOL_edit_34	;					
	}									
","	function	setPOOL_edit_16	(	string	newPOOL_edit_16	)	public	onlyOwner	{	
		inPOOL_edit_16	=	newPOOL_edit_16	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_34(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_16(string),5,5,1
"	function	getPOOL_edit_21	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_21	;						
	}									
","	function	setPOOL_edit_20	(	string	newPOOL_edit_20	)	public	onlyOwner	{	
		inPOOL_edit_20	=	newPOOL_edit_20	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_21(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_20(string),5,5,1
"    function setUncirculatedSupplyCount(uint newValue) onlyAdmin public {
        require (newValue > 0);
        uncirculatedSupplyCount = uint256(newValue);
    }
","    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {
        uint256 purchaseReturn = formulaContract.calculatePurchaseReturn(
            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),
            address(this).balance + virtualReserveBalance,
            weight,
            amountInWei 
        ); 

        purchaseReturn = (purchaseReturn - ((purchaseReturn * fee) / 1000000));

        if (purchaseReturn > tokenContract.balanceOf(this)){
            return tokenContract.balanceOf(this);
        }
        return purchaseReturn;
    }
",0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:setUncirculatedSupplyCount(uint256),0x0d71555233b7f913a5d9ae4ccd802145966d9bbf/ExchangerV3.sol:ExchangerV3:getPurchasePrice(uint256),5,5,1
"    modifier delegated {
        uint size = msg.data.length;
        bytes32 mData = _malloc(size);

        assembly {
            calldatacopy(mData, 0x0, size)
        }

        bytes32 mResult = _delegatecall(mData, size);
        _;
        assembly {
            return(mResult, 0x20)
        }
    }
","    function _malloc(uint size) 
        private 
        returns(bytes32 mData) 
    {
        assembly {
            mData := mload(0x40)
            mstore(0x40, add(mData, size))
        }
    }
",0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:delegated(),0x00b3ea4b9e28d2914f376cb0463c0f473c2e6179/MultiSigStub.sol:MultiSigStub:_malloc(uint256),5,5,1
"    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 18000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = ""ECTCOIN"";                                   // Set the name for display purposes
        symbol = ""ECT"";                               // Set the symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x5Be7d692a8aDC3dff8296f5f316a736b02DceF24/ECTCOIN.sol:ECTCOIN:TokenERC20(uint256,string,string)","0x5Be7d692a8aDC3dff8296f5f316a736b02DceF24/ECTCOIN.sol:ECTCOIN:approveAndCall(address,uint256,bytes)",4,4,1
"  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }
","  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
",0x4b5c88a857e35fa37328569fd4c3473bf7903300/ZontoToken.sol:BurnableToken:burn(uint256),"0x4b5c88a857e35fa37328569fd4c3473bf7903300/ZontoToken.sol:BurnableToken:_burn(address,uint256)",3,3,1
"  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","0x0fe54467e8c773be601aa6123bb27d641b0b8f7f/BatchTransferWallet.sol:SafeMath:sub(uint256,uint256)","0x0fe54467e8c773be601aa6123bb27d641b0b8f7f/BatchTransferWallet.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
","    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
","0x7d79ce7f73b03d2a0d057b779f9165bb1f0e5281/FLC.sol:StandardToken:transfer(address,uint256)","0x7d79ce7f73b03d2a0d057b779f9165bb1f0e5281/FLC.sol:StandardToken:approve(address,uint256)",4,4,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
","0x0f5c40cb9e4f3b1dab6c03fe5bb63a6d7106d4ec/Configurator.sol:StandardToken:increaseApproval(address,uint256)","0x0f5c40cb9e4f3b1dab6c03fe5bb63a6d7106d4ec/Configurator.sol:StandardToken:allowance(address,address)",3,2,1
"  function setWidthrawFor(string _paySystem,uint256 _stat, uint256 _perc) public onlyOwner returns (uint256) {
    widthrawPaySystemInfo[_paySystem].stat = _stat;
    widthrawPaySystemInfo[_paySystem].perc = _perc;

    WidthrawCommisionIsChanged(_paySystem, _stat, _perc);
  }
","  function setRefillFor(string _paySystem, uint256 _stat, uint256 _perc) public onlyOwner returns (uint256) {
    refillPaySystemInfo[_paySystem].stat = _stat;
    refillPaySystemInfo[_paySystem].perc = _perc;

    RefillCommisionIsChanged(_paySystem, _stat, _perc);
  }
","0x6d60Df5E12fcFFB5C675F7DcF810e329d7D5A760/EvaCurrency.sol:ComissionList:setWidthrawFor(string,uint256,uint256)","0x6d60Df5E12fcFFB5C675F7DcF810e329d7D5A760/EvaCurrency.sol:ComissionList:setRefillFor(string,uint256,uint256)",4,4,1
"    function setABI(bytes32 node, uint256 contentType, bytes data) only_owner(node) {
        // Content types must be powers of 2
        if(((contentType - 1) & contentType) != 0) throw;
        
        records[node].abis[contentType] = data;
        ABIChanged(node, contentType);
    }
","    function setContent(bytes32 node, bytes32 hash) only_owner(node) {
        records[node].content = hash;
        ContentChanged(node, hash);
    }
","0x1da022710df5002339274aadee8d58218e9d6ab5/PublicResolver.sol:PublicResolver:setABI(bytes32,uint256,bytes)","0x1da022710df5002339274aadee8d58218e9d6ab5/PublicResolver.sol:PublicResolver:setContent(bytes32,bytes32)",5,5,1
"    function Armour () {
        totalSupply = 10000000000;
        symbol = 'ARM';
        owner = 0xF015a6bf5eCB0ED05a1a827B091Fcba8AC4Dd774;
        balances[owner] = totalSupply;
        decimals = 2;
    }
","    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
        var _allowance = allowed[_from][msg.sender];
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
",0x0ba7154f77c5f1b23630d95ca465eae7e8a8f79a/Armour.sol:Armour:Armour(),"0x0ba7154f77c5f1b23630d95ca465eae7e8a8f79a/Armour.sol:Armour:transferFrom(address,address,uint256)",5,5,1
"	function	getPOOL_edit_19	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_19	;						
	}									
","	function	setPOOL_edit_34	(	string	newPOOL_edit_34	)	public	onlyOwner	{	
		inPOOL_edit_34	=	newPOOL_edit_34	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_19(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_34(string),4,4,1
"		function	setarg_3_input	(	uint256	newarg_3_input	)	public	onlyOwner	{	
			arg_3_input	=	newarg_3_input	;					
		}									
","		function	instruct_2				()	public	{		
			require(	msg.sender == User_2			);				
			require(	Securities_2.transfer(User_2, Standard_2)			);				
			require(	arg_1 == arg_1_input			);				
			require(	arg_2 == arg_2_input			);				
			require(	arg_3 == arg_3_input			);				
		}									
",0x1bb7ec9723493d8649caf261b4e7ed187646069a/BOT_ELEMENT_3.sol:BOT_ELEMENT_3:setarg_3_input(uint256),0x1bb7ec9723493d8649caf261b4e7ed187646069a/BOT_ELEMENT_3.sol:BOT_ELEMENT_3:instruct_2(),5,5,1
"  modifier onlyNotSame(address _from, address _to) {
    if(_from == _to) revert();
    _;
  }
","  function MTRCToken(address _owner, string _name, string _symbol, uint _totalSupply, uint _decimals) public UpgradeableToken(_owner) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _totalSupply * 10 ** uint(decimals);

    // Allocate initial balance to the owner
    balances[_owner] = totalSupply;

    // save the owner
    owner = _owner;
  }
","0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:MTRCToken:onlyNotSame(address,address)","0x1e49ff77c355a3e38d6651ce8404af0e48c5395f/MTRCToken.sol:MTRCToken:MTRCToken(address,string,string,uint256,uint256)",4,4,1
"	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}
","	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpContracts:getBdpImageStorage(address[16]),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpContracts:getBdpControllerHelper(address[16]),4,4,1
"	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}
","	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:pushOwnedToken(address,uint256)",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:getOwnedArea(address),5,5,1
"	function	getPI_edit_6	()	public	constant	returns	(	string	)	{
		return	inPI_edit_6	;						
	}									
","	function	getPI_edit_12	()	public	constant	returns	(	string	)	{
		return	inPI_edit_12	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_6(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_12(),5,5,0
"    constructor() public {
        symbol = ""BBT"";
        name = ""BiBox"";
        decimals = 18;
        _totalSupply = 1000000000 * 10 ** uint256(decimals);
        _airdropAmount = 35000 * 10 ** uint256(decimals);
        _airdropSupply =  300000000 * 10 ** uint256(decimals);
        _totalRemaining = _airdropSupply;
        balances[owner] = _totalSupply.sub(_airdropSupply);

        emit Transfer(address(0), owner, _totalSupply);
    }
","    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
",0x4b2cc07661c7b69a4707277647727aa8898ffbde/BBT.sol:BBT:constructor(),"0x4b2cc07661c7b69a4707277647727aa8898ffbde/BBT.sol:BBT:approve(address,uint256)",5,5,1
"    function putBtoWithStc(
        uint    amount,
        uint    expiration,
        bytes32 nonce,
        uint    price,
        uint    size,
        uint    strike,
        uint    validUntil,
        bytes32 r,
        bytes32 s,
        uint8   v
    ) public hasFee(amount) {
        bytes32 h = keccak256(Action.SellPutToClose, expiration, nonce, price, size, strike, validUntil, this);
        address maker = _getMaker(h, v, r, s);

        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);
        _buyPutToOpen(amount, expiration, price, strike, msg.sender);
        _sellPutToClose(amount, expiration, price, strike, maker);
    }
","    function callBtcWithStc(
        uint    amount,
        uint    expiration,
        bytes32 nonce,
        uint    price,
        uint    size,
        uint    strike,
        uint    validUntil,
        bytes32 r,
        bytes32 s,
        uint8   v
    ) public hasFee(amount) {
        bytes32 h = keccak256(Action.SellCallToClose, expiration, nonce, price, size, strike, validUntil, this);
        address maker = _getMaker(h, v, r, s);

        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);
        _buyCallToClose(amount, expiration, price, strike, msg.sender);
        _sellCallToClose(amount, expiration, price, strike, maker);
    }
","0x03cc979c46b030c4abd7d4063cd075cb38cd0919/Exchange.sol:Exchange:putBtoWithStc(uint256,uint256,bytes32,uint256,uint256,uint256,uint256,bytes32,bytes32,uint8)","0x03cc979c46b030c4abd7d4063cd075cb38cd0919/Exchange.sol:Exchange:callBtcWithStc(uint256,uint256,bytes32,uint256,uint256,uint256,uint256,bytes32,bytes32,uint8)",5,5,1
"  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }
","  modifier canMint() {
    if(mintingFinished) throw;
    _;
  }
","0x3F5276444dcEaeFbf2bA53BE2E1A3e8709bfe84d/MintedTokenCappedCrowdsaleExt.sol:MintableTokenExt:mint(address,uint256)",0x3F5276444dcEaeFbf2bA53BE2E1A3e8709bfe84d/MintedTokenCappedCrowdsaleExt.sol:MintableTokenExt:canMint(),4,4,1
"    function setICORatio(uint _newPrice)  {
        if (msg.sender != owner) { throw; }
        ICORatio = _newPrice;
    }
","    function enablePurchasing() {
        if (msg.sender != owner) { throw; }

        purchasingAllowed = true;
    }
",0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:setICORatio(uint256),0x4b15b2d301dd81e05fc404e16bdd138b29dcdefd/Virgo_ZodiacToken.sol:Virgo_ZodiacToken:enablePurchasing(),4,4,1
"    function remove(int8Set storage self, int8 other) {
        if (self.memberExists[other])  {
            self.memberExists[other] = false;
            uint index = self.memberIndex[other];
            // change index of last value to index of other 
            self.memberIndex[self.members[self.members.length - 1]] = index;
            // copy last value over other and decrement length
            self.members[index] = self.members[self.members.length - 1];
            self.members.length--;
        }
    }
","    function insert(uint8Set storage self, uint8 other) {
        if (!self.memberExists[other]) {
            self.memberExists[other] = true;
            self.memberIndex[other] = self.members.length;
            self.members.push(other);
        }
    }
","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:remove(Sets:int8Set,int8)","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:insert(Sets:uint8Set,uint8)",5,5,1
"	function	getData_10	()	public	constant	returns	(	string	)	{	
		return	inData_10	;							
	}										
","	function	getData_7	()	public	constant	returns	(	string	)	{	
		return	inData_7	;							
	}										
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_10(),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_7(),5,5,1
"    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
","0x7fee3ef2b3007ee4998df0c4f3eb493b5d168641/GCCExchangeCore.sol:SafeMath:add(uint256,uint256)","0x7fee3ef2b3007ee4998df0c4f3eb493b5d168641/GCCExchangeCore.sol:SafeMath:mul(uint256,uint256)",4,4,1
"    function burn(uint num) public {
        require(num * 1e8 > 0);
        require(balances[msg.sender] >= num * 1e8);
        require(totalSupply >= num * 1e8);

        uint pre_balance = balances[msg.sender];

        balances[msg.sender] -= num * 1e8;
        totalSupply -= num * 1e8;
        Burnt(msg.sender, num * 1e8, totalSupply);
        Transfer(msg.sender, 0x0, num * 1e8);

        assert(balances[msg.sender] == pre_balance - num * 1e8);
    }
","    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }
",0x0b4ce72a70e87bee66e0f43e9c861366e9d7de19/Pisces_ZodiacToken.sol:Pisces_ZodiacToken:burn(uint256),0x0b4ce72a70e87bee66e0f43e9c861366e9d7de19/Pisces_ZodiacToken.sol:Pisces_ZodiacToken:balanceOf(address),5,5,1
"	function	setPOOL_edit_3	(	string	newPOOL_edit_3	)	public	onlyOwner	{	
		inPOOL_edit_3	=	newPOOL_edit_3	;					
	}									
","	function	setPOOL_edit_32	(	string	newPOOL_edit_32	)	public	onlyOwner	{	
		inPOOL_edit_32	=	newPOOL_edit_32	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_3(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_32(string),5,5,1
"  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    if (now < unlockTimeStamp && !_lockByPass[_from]) return false;
    return super.transferFrom(_from, _to, _value);
  }
","  function setUnlockTimeStamp(uint _unlockTimeStamp) onlyOwner {
    unlockTimeStamp = _unlockTimeStamp;
  }
","0x2F1B8C9d0A21b747D8ca370f93cb09D3DaF222EF/ERipple.sol:ERipple:transferFrom(address,address,uint256)",0x2F1B8C9d0A21b747D8ca370f93cb09D3DaF222EF/ERipple.sol:ERipple:setUnlockTimeStamp(uint256),4,4,1
"	function	setPI_edit_18	(	string	newPI_edit_18	)	public	onlyOwner	{	
		inPI_edit_18	=	newPI_edit_18	;					
	}									
","	function	getPI_edit_28	()	public	constant	returns	(	string	)	{
		return	inPI_edit_28	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_18(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_28(),5,5,1
"	function	getPI_edit_19	()	public	constant	returns	(	string	)	{
		return	inPI_edit_19	;						
	}									
","	function	getPI_edit_23	()	public	constant	returns	(	string	)	{
		return	inPI_edit_23	;						
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_19(),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:getPI_edit_23(),5,5,0
"  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {
    emergencyFreeze = _freeze;
    emit EmerygencyFreezed(_freeze);
    return true;
  }
","  modifier onlyOwner {
    require(msg.sender == owner);
     _;
  }
",0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:emergencyFreezeAllAccounts(bool),0x7ea4afa739baea185b5c2c77f5676b69a7bae2a3/WeisToken.sol:WeisToken:onlyOwner(),4,4,1
"    function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) internal returns (uint256) {
        return div(mul(number, numerator), denominator);
    }
","    function sub(uint256 a, uint256 b) constant internal returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x3df0c635946fde2785528fd32803ea1bd59c9d80/ByteQuid.sol:SafeMath:mulByFraction(uint256,uint256,uint256)","0x3df0c635946fde2785528fd32803ea1bd59c9d80/ByteQuid.sol:SafeMath:sub(uint256,uint256)",5,5,1
"	function specialPurchase()
		only_before_period
		is_under_cap_with(msg.value)
		payable
		public
	{
		uint256 bought = buyinReturn(msg.sender) * msg.value;
		require (bought > 0);   // be kind and don't punish the idiots.

		// Bounded value, see STANDARD_BUYIN.
		tokens.mint(msg.sender, bought);
		TREASURY.transfer(msg.value);
		saleRevenue += msg.value;
		totalSold += bought;
		SpecialPurchased(msg.sender, msg.value, bought);
   }
","	function buyinReturn(address _who)
		constant
		public
		returns (uint)
	{
		// Chinese exchanges.
		if (
			_who == CHINESE_EXCHANGE_1 || _who == CHINESE_EXCHANGE_2 ||
			_who == CHINESE_EXCHANGE_3 || _who == CHINESE_EXCHANGE_4
		)
			return CHINESE_EXCHANGE_BUYIN;

		// BTCSuisse tier 1
		if (_who == BTC_SUISSE_TIER_1)
			return STANDARD_BUYIN;
		// BTCSuisse tier 2
		if (_who == BTC_SUISSE_TIER_2)
			return TIER_2_BUYIN;
		// BTCSuisse tier 3
		if (_who == BTC_SUISSE_TIER_3)
			return TIER_3_BUYIN;
		// BTCSuisse tier 4
		if (_who == BTC_SUISSE_TIER_4)
			return TIER_4_BUYIN;

		return 0;
	}
",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:specialPurchase(),0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmbrosusSale:buyinReturn(address),5,5,1
"	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}
","	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:getOwnedTokensIndex(uint256),"0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpOwnershipStorage:decrementOwnedArea(address,uint256)",4,4,1
"  modifier preventRestricted {
    require((msg.sender != restrictedAcct) || (now >= restrictUntil));
    _;
  }
","  function totalSupply() public constant returns (uint supply) { supply = tokenSupply; }
",0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:preventRestricted(),0x06b9737a7a625478fe5a65bf4bff4390ff6ace96/BurnableToken.sol:BurnableToken:totalSupply(),4,4,1
"    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }
","    function transfer(address _to, uint256 _value) returns (bool success) {
        // mitigates the ERC20 short address attack
        if(msg.data.length < (2 * 32) + 4) { throw; }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
",0x1b5ed05690a6b04533f09185afe03ff2371835c2/RainbowUnicoin.sol:RainbowUnicoin:getStats(),"0x1b5ed05690a6b04533f09185afe03ff2371835c2/RainbowUnicoin.sol:RainbowUnicoin:transfer(address,uint256)",4,4,1
"    function enableTransfers(Data storage self) public {
        require(msg.sender == self.owner);
        require(!self.transferable);
        self.transferable = true;
        TransfersEnabled();
    }
","    function acceptOwnership(Data storage self) public {
        require(msg.sender == self.newOwner);
        OwnershipTransferred(self.owner, self.newOwner);
        self.owner = self.newOwner;
        self.newOwner = address(0);
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:enableTransfers(BTTSLib:Data),0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:acceptOwnership(BTTSLib:Data),5,5,1
"    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        require(_owner != address(0));
        require(_operator != address(0));
        return ownerToOperators[_owner][_operator];
    }
","    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(_approved != tokenOwner);

        idToApprovals[_tokenId] = _approved;
        emit Approval(tokenOwner, _approved, _tokenId);
    }
","0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:isApprovedForAll(address,address)","0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:approve(address,uint256)",4,4,1
"    function buyTokens(address beneficiary, uint weiAmount) internal whenNotPaused {
        require(contributions[beneficiary].add(weiAmount) < currentCap());
        require(whiteListed.whiteList(beneficiary));
        require((weiAmount > MIN_CONTRIBUTION) || (weiAmount == SALE_CAP.sub(MIN_CONTRIBUTION)));

        weiRaised = weiRaised.add(weiAmount);
        uint tokens = weiAmount.mul(getRateAndCheckCap());

        if (contributions[beneficiary] == 0) {
            numContributors++;
        }

        tokensRaised = tokensRaised.add(tokens);

        contributions[beneficiary] = contributions[beneficiary].add(weiAmount);
        token.mint(beneficiary, tokens);
        emit TokenPurchase(beneficiary, weiAmount, tokens);
        forwardFunds();
    }
","    function currentCap() public view returns (uint) {
        for (uint i = 0; i < capz.length; i++) {
            if (now < SALE_START + capz[i].time * 1 hours)
                return (capz[i].amount * 1 ether);
        }
        return capDefault;
    }
","0x4e29ff51029e9fbb5e4ce3f8ae3a6b10e0e7dfdb/REDTTokenSale.sol:REDTTokenSale:buyTokens(address,uint256)",0x4e29ff51029e9fbb5e4ce3f8ae3a6b10e0e7dfdb/REDTTokenSale.sol:REDTTokenSale:currentCap(),5,5,1
"		function	retrait_4				()	public	{		
			require(	msg.sender == User_4			);				
			require(	Securities_4.transfer(User_4, Standard_4)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
","		function	retrait_5				()	public	{		
			require(	msg.sender == User_1			);				
			require(	Securities_5.transfer(User_5, Standard_5)			);				
			require(	ID == ID_control			);				
			require(	Cmd == Cmd_control			);				
			require(	Depositary_function == Depositary_function_control			);				
		}									
",0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:retrait_4(),0x4a1d68b25520ddd24b19ace3f021533b55283346/CCH_Seaport_1.sol:CCH_Seaport_1:retrait_5(),4,5,0
"    function btcId() public constant returns (uint8) {
        return uint8(Currency.BTC);
    }
","    function tokensByEurTx(string _txId) public constant returns (uint256) {
        return _tokensByTx(Currency.EUR, _txId);
    }
",0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:btcId(),0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:tokensByEurTx(string),5,5,1
" function prc(uint256 c) constant external returns(uint256) {
  uint256 p = prcs[c];
  return p > 0 ? p : STARTING_PRICE;
 }
"," function buy(uint256 c, string url) external payable {
  uint256 p = prcs[c];
  if(p == 0) p = STARTING_PRICE;
  require (msg.value >= p);
  address pO = onrs[c];
  uint256 nP = p << 1;
  prcs[c] = nP;
  onrs[c] = msg.sender;
  urls[c] = url;
  tyms[c] = now;
  Upd(c, url, msg.sender, nP, now);
  if(pO != address(0)) {
   pO.transfer((3 * p) / 5);
  }
  cO.transfer(this.balance);
 }
",0x7dd0c46b6f4c4260c165659ad4475a3720c942d3/Emoz.sol:Emoz:prc(uint256),"0x7dd0c46b6f4c4260c165659ad4475a3720c942d3/Emoz.sol:Emoz:buy(uint256,string)",5,5,1
"    function withdraw(address _multisigAddress) public onlyOwner {    
        require(_multisigAddress != 0x0);
        multisigAddress = _multisigAddress;
        multisigAddress.transfer(this.balance);
    }  
","    function burnTokens(uint256 _amount)public onlyOwner {
        require (balances[msg.sender] > _amount);               // Throw if you do not have enough balance
        totalRemainSupply += _amount;                           // Deduct totalSupply
        balances[msg.sender] -= _amount;                             // Destroy coins on senders wallet
        burnToken(msg.sender, _amount);                              // Raise Burn event
    }
",0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:withdraw(address),0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:burnTokens(uint256),5,5,1
"    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
",0x5f2539a5dc504493ba9ae1207803c08634cbb091/SCH.sol:SCH:finishDistribution(),0x5f2539a5dc504493ba9ae1207803c08634cbb091/SCH.sol:SCH:onlyOwner(),2,1,1
"	function	setPOOL_edit_30	(	string	newPOOL_edit_30	)	public	onlyOwner	{	
		inPOOL_edit_30	=	newPOOL_edit_30	;					
	}									
","	function	getPOOL_edit_33	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_33	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_30(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_33(),5,5,1
"    function hasPlayerWagered(address player)
    public 
    view 
    returns (bool)
    {
        if(wagers[player] > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
        
    }
","    constructor(address whaleAddress, uint256 wagerLimit) 
    onlyRealPeople()
    public 
    {
        openToPublic = false;
        owner = msg.sender;
        whale = whaleAddress;
        totalDonated = 0;
        betLimit = wagerLimit;
        
    }
",0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:hasPlayerWagered(address),"0x7d09edb07d23acb532a82be3da5c17d9d85806b4/PoCGame.sol:PoCGame:constructor(address,uint256)",5,5,1
"    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false 
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender] 
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","    function name() public view returns (string _name) {
        return name;
    }
","0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:transfer(address,uint256,bytes,string)",0x3c294199c9d2e3f25a59bfc2db3568b220bb63c7/Zeinun.sol:Zeinun:name(),4,5,1
"    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,bytes[5],uint256)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(uint256,string,bytes[1])",5,5,1
"    function approve(Data storage self, address spender, uint tokens) public returns (bool success) {
        require(!self.accountLocked[msg.sender]);
        self.allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }
","    function signedApprove(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {
        require(self.transferable);
        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);
        require(tokenOwner != address(0) && tokenOwner == ecrecoverFromSig(keccak256(signingPrefix, hash), sig));
        require(!self.accountLocked[tokenOwner]);
        require(self.nextNonce[tokenOwner] == nonce);
        self.nextNonce[tokenOwner] = nonce + 1;
        self.allowed[tokenOwner][spender] = tokens;
        Approval(tokenOwner, spender, tokens);
        self.balances[tokenOwner] = safeSub(self.balances[tokenOwner], fee);
        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);
        Transfer(tokenOwner, feeAccount, fee);
        return true;
    }
","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:approve(BTTSLib:Data,address,uint256)","0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSLib:signedApprove(BTTSLib:Data,address,address,uint256,uint256,uint256,bytes,address)",5,5,1
"  function setOracle(address _oracle) public  onlyOwner {
    require(_oracle != address(0));
    oracle = _oracle;
  }
","  modifier saleIsOn() {
    bool withinPeriod = now >= startTime && now <= endTime;
    require(withinPeriod);
    _;
  }
",0x1ac821a5ab398d62011b008acf5598308ee4d4ad/PreICO.sol:PreICO:setOracle(address),0x1ac821a5ab398d62011b008acf5598308ee4d4ad/PreICO.sol:PreICO:saleIsOn(),5,5,1
"	function	setPOOL_edit_24	(	string	newPOOL_edit_24	)	public	onlyOwner	{	
		inPOOL_edit_24	=	newPOOL_edit_24	;					
	}									
","	function	getPOOL_edit_6	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_6	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_24(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_6(),4,4,1
"  function finishMinting() public returns (bool) {
    require(!mintingFinished);
    require(msg.sender == owner || msg.sender == saleAgent);
    mintingFinished = true;
    MintFinished();
    return true;
  }
","  function transfer(address _to, uint256 _value) public notLocked returns (bool) {
    return super.transfer(_to, _value);
  }
",0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:KITToken:finishMinting(),"0x6e08a8b4da2a13c655af2dd74f7bdb979efe141b/ICO.sol:KITToken:transfer(address,uint256)",4,4,1
"	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}
","	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}
",0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:getTokenApproval(uint256),0x6fa3217293bb88ec6accecc368881c33df1248f5/BdpOwnershipStorage.sol:BdpOwnershipStorage:getOwnedArea(address),5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }
","  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
","0x2Bb85293d3faBaB96C812170E112C6472951145c/TaxiToken.sol:PausableToken:increaseApproval(address,uint256)","0x2Bb85293d3faBaB96C812170E112C6472951145c/TaxiToken.sol:PausableToken:approve(address,uint256)",5,5,1
"	function	setPOOL_edit_1	(	string	newPOOL_edit_1	)	public	onlyOwner	{	
		inPOOL_edit_1	=	newPOOL_edit_1	;					
	}									
","	function	getPOOL_edit_5	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_5	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_1(string),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_5(),5,5,1
"    function distributeAirdrop(address[] addresses, uint256 amount) onlyOwner public {
        // Only allow undrop while token is locked
        // After token is unlocked, this method becomes permanently disabled
        require(!unlocked);

        uint256 normalizedAmount = amount * 10**8;
		
        // Only proceed if there are enough tokens to be distributed to all addresses
        // Never allow balance of owner to become negative
		
        require(balances[owner] >= safeMul(addresses.length, normalizedAmount));
        for (uint i = 0; i < addresses.length; i++) {
            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);
            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);
            Transfer(owner, addresses[i], normalizedAmount);
        }
    }
","    function decimals() constant public returns (uint8 _decimals) {
        return decimals;
    }
","0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:distributeAirdrop(address[],uint256)",0x3b1f334c7003d55591cbbff548ffb522b72f557c/Pharamore.sol:Pharamore:decimals(),5,5,1
"    function mintDSBCToken(address _to, uint256 _amount) internal { 
        require (balances[_to] + _amount > balances[_to]);      // Check for overflows
        require (totalRemainSupply > _amount);
        totalRemainSupply -= _amount;                           // Update total supply
        balances[_to] += _amount;                               // Set minted coins to target
        mintToken(_to, _amount);                                // Create Mint event       
        Transfer(0x0, _to, _amount);                            // Create Transfer event from 0x
    }  
","    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {      
        require (balances[_from] > _value);                // Throw if sender does not have enough balance     
        require (balances[_to] + _value > balances[_to]);  // Throw if overflow detected    
        require (_value <= allowances[_from][msg.sender]);  // Throw if you do not have allowance       
        balances[_from] -= _value;                          // Deduct senders balance    
        balances[_to] += _value;                            // Add recipient blaance         
        allowances[_from][msg.sender] -= _value;            // Deduct allowance for this address         
        Transfer(_from, _to, _value);                       // Raise Transfer event
        return true;     
    }         
","0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:mintDSBCToken(address,uint256)","0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6/DASABI_IO_Contract.sol:DASABI_IO_Contract:transferFrom(address,address,uint256)",4,5,1
"    function tokensByUsdTx(string _txId) public constant returns (uint256) {
        return _tokensByTx(Currency.USD, _txId);
    }
","    function wavesId() public constant returns (uint8) {
        return uint8(Currency.WAVES);
    }
",0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:tokensByUsdTx(string),0x6b86047c30f88de33848f2d314e52a2c15c01662/Deployer.sol:CommonBsPresale:wavesId(),5,5,1
"    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(0, datasource, args);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[5],uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string[])",5,5,1
"    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        bytes memory args = stra2cbor(argN);
        return oraclize.queryN.value(price)(timestamp, datasource, args);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[5],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,string[])",5,5,1
"  	modifier underMaxAmount {
    	require(max_amount == 0 || this.balance <= max_amount);
    	_;
  	}
","	function set_sale_address(address _sale) onlyOwner {
		require(_sale != 0x0);
		sale = _sale;
	}
",0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:underMaxAmount(),0x07af5712489601f23df5321afaf7c0f787eac076/Contract.sol:Contract:set_sale_address(address),5,5,1
"	function	getPOOL_edit_34	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_34	;						
	}									
","	function	getPOOL_edit_28	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_28	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_34(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_28(),5,5,1
"  modifier addIfNotExist(address holder) {
    if(!balances[holder].exist)
      holders.push(holder);
    _;
  }
","  modifier inReleaseState(bool _released) {
    require(_released == released);
    _;
  }
",0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SilentNotaryToken:addIfNotExist(address),0x2df8286c9396f52e17DFeE75d2E41E52609CF897/SilentNotaryToken.sol:SilentNotaryToken:inReleaseState(bool),5,5,1
"    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b/MobileAppCoin.sol:MobileAppCoin:getTokenBalance(address,address)",0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b/MobileAppCoin.sol:MobileAppCoin:onlyOwner(),3,1,1
"    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(string,string,string,uint256)","0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,string[4])",5,5,1
"    function tokenFreezing (address freezAccount, bool isFrozen) onlyAdmin public{
        if(!users[freezAccount].isset){
            users[freezAccount] = User(false, false, 0, true);
        }
        users[freezAccount].frozen = isFrozen;
        emit FrozenFunds(freezAccount, isFrozen);
    }
","    function transfer(address _to, uint256 _value) unbanned unfrozen public returns (bool success)  {
        if(!users[msg.sender].isset){
            users[msg.sender] = User(false, false, 0, true);
        }
        if(!users[_to].isset){
            users[_to] = User(false, false, 0, true);
        }
        if(!hasKey(msg.sender)){
            balancesKeys.push(msg.sender);
        }
        if(!hasKey(_to)){
            balancesKeys.push(_to);
        }
        if(users[msg.sender].balance < _value || users[_to].balance + _value < users[_to].balance){
            revert();
        }

        users[msg.sender].balance -= _value;
        users[_to].balance += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
","0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:tokenFreezing(address,bool)","0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:transfer(address,uint256)",5,5,1
"    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
","    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setProof(bytes1),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[5],uint256)",4,4,1
"    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {
        return data.mint(tokenOwner, tokens, lockAccount);
    }
","    function symbol() public view returns (string) {
        return data.symbol;
    }
","0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:mint(address,uint256,bool)",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:symbol(),5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {return false;}
    }
","    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
","0x8b3154c4097d14ddbc3935b2c04d124ea2a5dedc/Fetish.sol:StandardToken:transferFrom(address,address,uint256)",0x8b3154c4097d14ddbc3935b2c04d124ea2a5dedc/Fetish.sol:StandardToken:balanceOf(address),4,4,1
"        function participantDetails(uint orderInPyramid) view public returns(address Address, uint Payout) {
                if (orderInPyramid <= participants.length) {
                        Address = participants[orderInPyramid].etherAddress;
                        Payout = participants[orderInPyramid].payout;
                }
        }
","        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
",0x04eb05e09ef4b9efdebbad449307c70d06f58b3e/Dynamic1_5x.sol:Dynamic1_5x:participantDetails(uint256),0x04eb05e09ef4b9efdebbad449307c70d06f58b3e/Dynamic1_5x.sol:Dynamic1_5x:onlyOwner(),5,5,1
"	function	setData_9	(	string	newData_9	)	public	onlyOwner	{		
		inData_9	=	newData_9	;						
	}										
","	function	getData_8	()	public	constant	returns	(	string	)	{	
		return	inData_8	;							
	}										
",0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:setData_9(string),0x0ab52c585e2dd2826a9d6876af1e5499e7286d12/LLV_v31_5.sol:LLV_v31_5:getData_8(),5,5,1
"  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x2ef37c2b6679de8b6944e22dc9bbf01083007ce9/Fanship.sol:StandardToken:increaseApproval(address,uint256)","0x2ef37c2b6679de8b6944e22dc9bbf01083007ce9/Fanship.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function setFee(uint _fee) owner_only {
        fee = _fee;
    }
","    function setResolver(Resolver _resolver) owner_only {
        resolver = _resolver;
    }
",0x4b855725bb816b7e2b3e67bcffe0436b407675ae/SimpleRegistrar.sol:SimpleRegistrar:setFee(uint256),0x4b855725bb816b7e2b3e67bcffe0436b407675ae/SimpleRegistrar.sol:SimpleRegistrar:setResolver(Resolver),5,5,1
"    function setAssetsCertified(uint256 _total) public onlyAuditor whenRedemptionPaused {
        uint256 totalSupply_ = rocketStorage.getUint(keccak256(""token.totalSupply""));
        require(_total >= totalSupply_);
        rocketStorage.setUint(keccak256(""issuable.assetsCertified""), _total);
        emit CertificationUpdated(msg.sender, _total);
    }
","    function releaseAssets(uint256 _units) public onlyDepository {
        uint256 totalSupply_ = rocketStorage.getUint(keccak256(""token.totalSupply""));
        uint256 total_ = assetsOnDeposit().sub(_units);
        require(total_ >= totalSupply_);
        rocketStorage.setUint(keccak256(""issuable.assetsOnDeposit""), total_);
        emit AssetsUpdated(msg.sender, total_);
    }
",0x2f5cdc81a729b750f3b733cb95660e788441c71e/LD2Zero.sol:Issuable:setAssetsCertified(uint256),0x2f5cdc81a729b750f3b733cb95660e788441c71e/LD2Zero.sol:Issuable:releaseAssets(uint256),5,5,1
"    modifier confirmed(uint transactionId, address owner) {
        require(confirmations[transactionId][owner]);
        _;
    }
","    modifier ownerDoesNotExist(address owner) {
        require(!isOwner[owner]);
        _;
    }
","0x4a32b05f949d54146ee5db1a0d1f554f9f67d9c0/PresaleFinalizeAgent.sol:RNTMultiSigWallet:confirmed(uint256,address)",0x4a32b05f949d54146ee5db1a0d1f554f9f67d9c0/PresaleFinalizeAgent.sol:RNTMultiSigWallet:ownerDoesNotExist(address),5,5,1
"    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {
        return oraclize.setConfig(config);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_setConfig(bytes32),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)",4,4,1
"  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x0d6b7184fe73365cb21bf044b5d415446c26d904/BuckyCoin.sol:StandardToken:decreaseApproval(address,uint256)","0x0d6b7184fe73365cb21bf044b5d415446c26d904/BuckyCoin.sol:StandardToken:increaseApproval(address,uint256)",3,3,1
"  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }
","  modifier whenNotPaused() {
    require(!paused);
    _;
  }
",0x6e3fec7cafe50fa6d25c29807377df1cd63a19a3/MenglaToken.sol:Pausable:pause(),0x6e3fec7cafe50fa6d25c29807377df1cd63a19a3/MenglaToken.sol:Pausable:whenNotPaused(),4,4,1
"    function addLock(address _addr) public onlyOwner returns (bool success){
        require(_addr!=msg.sender);
        locked[_addr]=true;
        return true;
    }
","    function enableTransfer(bool _enable) public onlyOwner{
        transferEnabled=_enable;
    }
",0x3ac6cb00f5a44712022a51fbace4c7497f56ee31/MESH.sol:Controlled:addLock(address),0x3ac6cb00f5a44712022a51fbace4c7497f56ee31/MESH.sol:Controlled:enableTransfer(bool),5,5,1
"  function symbol() public constant returns (string _symbol) {
      return symbol;
  }
","  function name() public constant returns (string _name) {
      return name;
  }
",0x5A12D5295A8DbB88c76324ca6fd505b1E4e6ad8E/TD.sol:TD:symbol(),0x5A12D5295A8DbB88c76324ca6fd505b1E4e6ad8E/TD.sol:TD:name(),5,5,1
"    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) public constant returns(uint) {
        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
        return orderFills[user][hash];
    }
","    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {
        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
        if (!(
            (orders[user][hash] || ecrecover(keccak256(""\x19Ethereum Signed Message:
32"", hash),v,r,s) == user) &&
            block.number <= expires
        )) return 0;
        uint available1 = safeSub(amountGet, orderFills[user][hash]);
        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;
        if (available1 < available2) return available1;
        return available2;
    }
","0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:amountFilled(address,uint256,address,uint256,uint256,uint256,address)","0x3b7cec8d8bae6342e38b33616000a2600599bedd/GenevExch.sol:GenevExch:availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)",5,5,1
"    function tokenByIndex(uint256 _index) external view returns (uint256) {
        require(_index < tokens.length);
        // Sanity check. This could be removed in the future.
        assert(idToIndex[tokens[_index]] == _index);
        return tokens[_index];
    }
","    function _burn(address _owner, uint256 _tokenId) internal {
        super._burn(_owner, _tokenId);
        assert(tokens.length > 0);

        uint256 tokenIndex = idToIndex[_tokenId];
        // Sanity check. This could be removed in the future.
        assert(tokens[tokenIndex] == _tokenId);
        uint256 lastTokenIndex = tokens.length - 1;
        uint256 lastToken = tokens[lastTokenIndex];

        tokens[tokenIndex] = lastToken;

        tokens.length--;
        // Consider adding a conditional check for the last token in order to save GAS.
        idToIndex[lastToken] = tokenIndex;
        idToIndex[_tokenId] = 0;
    }
",0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFTokenEnumerable:tokenByIndex(uint256),"0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFTokenEnumerable:_burn(address,uint256)",5,5,1
"  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
                          returns (bool)
  {
    uint256 _newAllowed;
    bool err;

    if(_increase) {
      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);
      require(!err);

      self.allowed[msg.sender][_spender] = _newAllowed;
    } else {
      if (_valueChange > self.allowed[msg.sender][_spender]) {
        self.allowed[msg.sender][_spender] = 0;
      } else {
        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;
        self.allowed[msg.sender][_spender] = _newAllowed;
      }
    }

    Approval(msg.sender, _spender, _newAllowed);
    return true;
  }
","  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool) {
    bool err;
    uint256 balance;

    (err,balance) = self.balances[msg.sender].minus(_value);
    require(!err);
    self.balances[msg.sender] = balance;
    //It's not possible to overflow token supply
    self.balances[_to] = self.balances[_to] + _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }
","0x6e5d3e9ce88a0fba4e096e2eb8d2b3dc54685dd2/RBITToken.sol:TokenLib:approveChange(TokenLib:TokenStorage,address,uint256,bool)","0x6e5d3e9ce88a0fba4e096e2eb8d2b3dc54685dd2/RBITToken.sol:TokenLib:transfer(TokenLib:TokenStorage,address,uint256)",5,5,1
"  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }
","  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
",0x3b6d80b6db62f51e2899b8ca7257c690670122d4/FloraFicTokenCrowdsale.sol:Crowdsale:_getTokenAmount(uint256),0x3b6d80b6db62f51e2899b8ca7257c690670122d4/FloraFicTokenCrowdsale.sol:Crowdsale:_forwardFunds(),4,4,1
"    function updateMarriageLicenceImageIPFShash(bytes _marriageLicenceImageIPFShash) public{
        require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address);
        marriageLicenceImageIPFShash = _marriageLicenceImageIPFShash;
    }
","    function updatePartner2_vows(string _partner2_vows) public {
        require((msg.sender == owner || msg.sender == partner2_address) && (bytes(partner2_vows).length == 0));
        partner2_vows = _partner2_vows;
    }
",0x4b8ede3ef8eb0fe5c869949048c0a0806ca2d6ae/SmartVows.sol:SmartVows:updateMarriageLicenceImageIPFShash(bytes),0x4b8ede3ef8eb0fe5c869949048c0a0806ca2d6ae/SmartVows.sol:SmartVows:updatePartner2_vows(string),5,5,1
"    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string[5])",5,5,1
"	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}
","	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}
",0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:getNextRegionId(),0x02dc5c6317cb81fc1ba5fd7fcb773f5a42deb700/BdpCalculator.sol:BdpDataStorage:BdpDataStorage(bytes8),5,5,1
"  function calcRefill(string _paySystem, uint256 _value) public view returns(uint256) {
    uint256 _totalComission;
    _totalComission = refillPaySystemInfo[_paySystem].stat + (_value / 100 ) * refillPaySystemInfo[_paySystem].perc;

    return _totalComission;
  }
","  function getTransferStat() public view returns (uint256) {
    return transferInfo.stat;
  }
","0x0ab6e894c973932b64974bf9e91e93332e51a98c/EvaCurrency.sol:ComissionList:calcRefill(string,uint256)",0x0ab6e894c973932b64974bf9e91e93332e51a98c/EvaCurrency.sol:ComissionList:getTransferStat(),5,5,1
"  function burn(address _from, uint256 _unitAmount) onlyOwner public {
    require(_unitAmount > 0
            && balanceOf(_from) >= _unitAmount);

    balances[_from] = SafeMath.sub(balances[_from], _unitAmount);
    totalSupply = SafeMath.sub(totalSupply, _unitAmount);
    Burn(_from, _unitAmount);
  }
","  function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {
    require(_unitAmount > 0);

    totalSupply = SafeMath.add(totalSupply, _unitAmount);
    balances[_to] = SafeMath.add(balances[_to], _unitAmount);
    Mint(_to, _unitAmount);
    Transfer(address(0), _to, _unitAmount);
    return true;
  }
","0x4c54e5ee228b1c917980687a7e54876c340fed7f/Seiyuu.sol:Seiyuu:burn(address,uint256)","0x4c54e5ee228b1c917980687a7e54876c340fed7f/Seiyuu.sol:Seiyuu:mint(address,uint256)",5,5,1
"    function thankYou(address _a) public onlyPart1 returns(bool)
    {
        thank_you[_a] = true;
        emit Transfer(_a, address(this), num * 1 ether);
        return true;
    }
","    function allowance(address _owner, address _spender) public view returns (uint256) {
        return num;
     }
",0x0c8931423583d9c1ff126d424e34656947876649/HelpMeTokenPart7.sol:HelpMeTokenPart7:thankYou(address),"0x0c8931423583d9c1ff126d424e34656947876649/HelpMeTokenPart7.sol:HelpMeTokenPart7:allowance(address,address)",4,5,1
"    function EthereumPrivate() public {
        totalSupply = 960000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;           // Give the creator all initial tokens
        name = 'Ethereum Private';                      // Set the name for display purposes
        symbol = 'ETHP';                                // Set the symbol for display purposes
    }
","    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
",0x6d358ad6eca1461f092659797e8dceb2d5150fa6/EthereumPrivate.sol:EthereumPrivate:EthereumPrivate(),"0x6d358ad6eca1461f092659797e8dceb2d5150fa6/EthereumPrivate.sol:EthereumPrivate:burnFrom(address,uint256)",5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x4ccc3759eb48faf1c6cfadad2619e7038db6b212/SuperEdge.sol:SafeMath:div(uint256,uint256)","0x4ccc3759eb48faf1c6cfadad2619e7038db6b212/SuperEdge.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _args, uint _gaslimit)
    payable
    returns (bytes32 _id) {
        return queryN(_timestamp, _datasource, _args, _gaslimit);
    }
","    function withdrawFunds(address _addr)
    onlyadmin {
        _addr.send(this.balance);
    }
","0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:queryN_withGasLimit(uint256,string,bytes,uint256)",0x6f28b146804dba2d6f944c03528a8fdbc673df2c/Oraclize.sol:Oraclize:withdrawFunds(address),5,5,1
"    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }
","    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }
","0x0c178237d47172440c5792526c4952a279fdadf1/TPCToken.sol:SafeMath:max64(uint64,uint64)","0x0c178237d47172440c5792526c4952a279fdadf1/TPCToken.sol:SafeMath:max256(uint256,uint256)",4,4,1
"  function setFreeTransferAllowed(bool _isFreeTransferAllowed) public {
    require(owner != address(0));
    require(msg.sender == owner);

    isFreeTransferAllowed = _isFreeTransferAllowed;
  }
","  function setPaused(bool _pause) public {
    require(owner != address(0));
    require(msg.sender == owner);

    isPaused = _pause;
  }
",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:setFreeTransferAllowed(bool),0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:setPaused(bool),5,5,1
"  function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) {
    require(_to != address(0));
    require(_to != address(this));
    require(_value <= balances[_sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[_sender] = balances[_sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(_sender, _to, _value);
    return true;
  }
","  function transfer(address _to, uint256 _value) public returns (bool) {
	return transferFunction(msg.sender, _to, _value);
  }
","0x4d829f8c92a6691c56300d020c9e0db984cfe2ba/CoinCrowdToken.sol:BasicToken:transferFunction(address,address,uint256)","0x4d829f8c92a6691c56300d020c9e0db984cfe2ba/CoinCrowdToken.sol:BasicToken:transfer(address,uint256)",5,5,1
"  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }
","0x2ea91a843aeea778e40e70623612cc720a6f751e/CPToken.sol:PausableToken:decreaseApproval(address,uint256)","0x2ea91a843aeea778e40e70623612cc720a6f751e/CPToken.sol:PausableToken:increaseApproval(address,uint256)",5,5,1
"    function sub(uint256 a, uint256 b) internal returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","    function add(uint256 a, uint256 b) internal returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","0x4C5651c4f59B3E92E67d993b7B969F9aF861380f/FaradTokenSwap.sol:SafeMath:sub(uint256,uint256)","0x4C5651c4f59B3E92E67d993b7B969F9aF861380f/FaradTokenSwap.sol:SafeMath:add(uint256,uint256)",4,4,1
"    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);


        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }
","    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }
","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:transfer(address,uint256)","0x7fcf5138d0189731e5ce28f0d5842007f9dfc901/CLIP.sol:CLIP:transfer(address,uint256,bytes)",5,5,1
"	function	getCmd_control	()	public	constant	returns	(	uint256	)	{
		return	Cmd_control	;						
	}									
","	modifier	onlyOwner	() {							
		require(msg.sender ==		owner	);					
		_;								
	}									
",0x2cab4249d5afa743244dc4b8429962e4a182187b/DTCC_ILOW_8.sol:DTCC_ILOW_8:getCmd_control(),0x2cab4249d5afa743244dc4b8429962e4a182187b/DTCC_ILOW_8.sol:DTCC_ILOW_8:onlyOwner(),5,5,1
"  function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
","  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    clearApprovalAndTransfer(msg.sender, _to, _tokenId);
  }
","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:clearApproval(address,uint256)","0x1b5242794288b45831ce069c9934a29b89af0197/CryptoSagaCard.sol:ERC721Token:transfer(address,uint256)",5,5,1
"  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
","0x05cda2f1e70b01072038c3a62f8aa30cf9d4d509/TOKENMOM.sol:StandardToken:increaseApproval(address,uint256)","0x05cda2f1e70b01072038c3a62f8aa30cf9d4d509/TOKENMOM.sol:StandardToken:decreaseApproval(address,uint256)",5,5,1
"    function hasEnded() public view returns (bool) {
        return now > endTime || stage == Stages.OfferingEnded;
    }
","    function endOfferingImpl() internal {
        endTime = now;
        stage = Stages.OfferingEnded;
        OfferingCloses(endTime, weiRaised);
    }
",0x4d8fc1453a0f359e99c9675954e656d80d996fbf/BeeToken.sol:BeeTokenOffering:hasEnded(),0x4d8fc1453a0f359e99c9675954e656d80d996fbf/BeeToken.sol:BeeTokenOffering:endOfferingImpl(),5,5,1
"    function setCouldTrade(uint256 amountInWeiDecimalIs18) onlyOwner returns (bool success) {
        couldTrade = true;
        require(balanceOf[msg.sender] >= amountInWeiDecimalIs18);
        require(balanceOf[this] + amountInWeiDecimalIs18 >= amountInWeiDecimalIs18);
        balanceOf[msg.sender] -= amountInWeiDecimalIs18;
        balanceOf[this] += amountInWeiDecimalIs18;
        Transfer(msg.sender, this, amountInWeiDecimalIs18);
        return true;
    }
","    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
",0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:EXToken:setCouldTrade(uint256),"0x4b5f6927f0Cabe1468DF36E949Ea48c3e2C4aD13/EXToken.sol:EXToken:setPrices(uint256,uint256)",5,5,1
"  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.increaseApproval(_spender, _addedValue);
  }
","  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:PausableToken:increaseApproval(address,uint256)","0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:PausableToken:decreaseApproval(address,uint256)",5,5,1
"  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
","0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:SafeMath:sub(uint256,uint256)","0x5eec85dc63dd62bdb492ac1012b71201396945d0/CrowdsaleToken.sol:SafeMath:mul(uint256,uint256)",4,4,1
"	function	getPOOL_edit_3	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_3	;						
	}									
","	function	getPOOL_edit_21	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_21	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_3(),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_21(),4,4,1
"	function	setPOOL_edit_25	(	string	newPOOL_edit_25	)	public	onlyOwner	{	
		inPOOL_edit_25	=	newPOOL_edit_25	;					
	}									
","	function	getPOOL_edit_20	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_20	;						
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_25(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:getPOOL_edit_20(),5,5,1
"    function hatchCoins(address ref) public{
        require(initialized);
        if(referrals[msg.sender] == 0 && referrals[msg.sender] != msg.sender){
            referrals[msg.sender] = ref;
        }
        uint256 coinsUsed = getMyCoins();
        uint256 newStrippers = SafeMath.div(coinsUsed,COINS_TO_HATCH_1STRIPPERS);
        hatcheryStrippers[msg.sender] = SafeMath.add(hatcheryStrippers[msg.sender],newStrippers);
        claimedCoins[msg.sender] = 0;
        lastHatch[msg.sender] = now;
        claimedCoins[referrals[msg.sender]] = SafeMath.add(claimedCoins[referrals[msg.sender]],SafeMath.div(coinsUsed,5));
        marketCoins = SafeMath.add(marketCoins,SafeMath.div(coinsUsed,10));
    }
","    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
",0x6ded330704d6b4734de6dc82b609765006dde197/CryptoStrippers.sol:CryptoStrippers:hatchCoins(address),"0x6ded330704d6b4734de6dc82b609765006dde197/CryptoStrippers.sol:CryptoStrippers:min(uint256,uint256)",4,4,1
"    function tokenFallback(address _from, uint256 _value, bytes _data)
      external
      onlyTokenContract
      returns (bool) {
        require(initialized);
        require(!_isContract(_from));
        require(_value >= 1 finney); // 0.001 ELXR token

        uint256 ElyxrBalance = tokenContract.myTokens();

        uint256 eggsBought=calculateEggBuy(_value, SafeMath.sub(ElyxrBalance, _value));
        eggsBought=SafeMath.sub(eggsBought,devFee(eggsBought));
        reinvest();
        tokenContract.transfer(ceoAddress, devFee(_value));
        claimedEggs[_from]=SafeMath.add(claimedEggs[_from],eggsBought);

        return true;
    }
","    function getBalance() public view returns(uint256){
        return tokenContract.myTokens();
    }
","0x3bc06304959cb2cfec0c8073eb6f31b466ce3f17/ElyxrShrimpFarmer.sol:ElyxrShrimpFarmer:tokenFallback(address,uint256,bytes)",0x3bc06304959cb2cfec0c8073eb6f31b466ce3f17/ElyxrShrimpFarmer.sol:ElyxrShrimpFarmer:getBalance(),5,5,1
"    function contains(intSet storage self, int other) returns (bool) {
        return self.memberExists[other];
    }
","    function remove(addressSet storage self, address other) {
        if (self.memberExists[other])  {
            self.memberExists[other] = false;
            uint index = self.memberIndex[other];
            // change index of last value to index of other 
            self.memberIndex[self.members[self.members.length - 1]] = index;
            // copy last value over other and decrement length
            self.members[index] = self.members[self.members.length - 1];
            self.members.length--;
        }
    }
","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:contains(Sets:intSet,int256)","0x7Aef44E5e6930F8799559aFB046Ccd8692044f86/Prover.sol:Sets:remove(Sets:addressSet,address)",5,5,1
"    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](1);
        dynargs[0] = args[0];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[1])","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string[4],uint256)",5,5,1
"  function withdrawToken(address token, uint amount) {
    if (token==0) throw;
    if (tokens[token][msg.sender] < amount) throw;
    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);
    if (!Token(token).transfer(msg.sender, amount)) throw;
    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);
  }
","  function balanceOf(address token, address user) constant returns (uint) {
    return tokens[token][user];
  }
","0x2b44d68555899dbc1ab0892e7330476183dbc932/Ethmall.sol:Ethmall:withdrawToken(address,uint256)","0x2b44d68555899dbc1ab0892e7330476183dbc932/Ethmall.sol:Ethmall:balanceOf(address,address)",5,5,1
"  function claim_bounty(){
    // Short circuit to save gas if the contract has already bought tokens.
    if (bought_tokens) return;
    // Disallow buying into the crowdsale if kill switch is active.
    if (kill_switch) throw;
    // Record that the contract has bought the tokens.
    bought_tokens = true;
    // Record the time the contract bought the tokens.
    time_bought = now + 1 days;
    // Transfer all the funds (less the bounty) to the ZBR crowdsale contract
    // to buy tokens.  Throws if the crowdsale hasn't started yet or has
    // already completed, preventing loss of funds.
    token.proxyPayment.value(this.balance - bounty)(address(this));
    // Send the caller their bounty for buying tokens for the contract.
    if(this.balance > ETH_to_end)
    {
        msg.sender.transfer(bounty);
    }
    else {
        time_bought = now +  1 days * 9;
        if(this.balance > ETH_to_end) {
          msg.sender.transfer(bounty);
        }
      }
  }
","  function activate_kill_switch() {
    // Only allow the developer to activate the kill switch.
    if (msg.sender != developer_address) throw;
    // Irreversibly activate the kill switch.
    kill_switch = true;
  }
",0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:claim_bounty(),0x4a9d54e391812c54da8bc57ddfa32dfe13ac3d0f/ZiberToken.sol:ZiberToken:activate_kill_switch(),4,4,1
"	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImagePartsCount(_imageId);
	}
","	function getImageCurrentRegionId(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageCurrentRegionId(_imageId);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getImagePartsCount(uint256),0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:getImageCurrentRegionId(uint256),5,5,1
"	function	setData_13	(	string	newData_13	)	public	onlyOwner	{	
		inData_13	=	newData_13	;					
	}									
","	function	getData_25	()	public	constant	returns	(	string	)	{
		return	inData_25	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:setData_13(string),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_25(),5,5,1
"    function getConBal() onlyOwner public constant returns  (uint)            // Get  Balance 
    {
        return this.balance;
    }    
","  function transfer(address _to, uint256 _value)  public
      {
          _transfer(msg.sender, _to, _value);
      }
",0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:getConBal(),"0x07E040D474a584cD2E7e4A819fA18420BeB5Eb4f/Ethereum_Cash_Pro_Coin.sol:Ethereum_Cash_Pro_Coin:transfer(address,uint256)",5,5,1
"    function totalSupply() public constant returns (uint) {
        if (deprecated) {
            return StandardToken(upgradedAddress).totalSupply();
        } else {
            return _totalSupply;
        }
    }
","    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        if (deprecated) {
            return StandardToken(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    }
",0x0e98db51010dd1ade14dd3fb164e218805fdba1b/TetherToken.sol:TetherToken:totalSupply(),"0x0e98db51010dd1ade14dd3fb164e218805fdba1b/TetherToken.sol:TetherToken:allowance(address,address)",5,5,1
"    function _hashToAscii(bytes32 hash) private pure returns (bytes) {
        bytes memory s = new bytes(64);
        for (uint i = 0; i < 32; i++) {
            byte  b = hash[i];
            byte hi = byte(uint8(b) / 16);
            byte lo = byte(uint8(b) - 16 * uint8(hi));
            s[2*i] = _char(hi);
            s[2*i+1] = _char(lo);
        }
        return s;
    }
","    function generateMessageToSign(
        address destination,
        uint256 value
    )
        public view returns (bytes32)
    {
        require(destination != address(this), ""2"");
        bytes32 message = keccak256(
            abi.encodePacked(
                spendNonce,
                this,
                value,
                destination
            )
        );
        return message;
    }
",0x1bb1e5486c3c8213665f9e306bd0aa764f04bd29/MultiSig2of3.sol:MultiSig2of3:_hashToAscii(bytes32),"0x1bb1e5486c3c8213665f9e306bd0aa764f04bd29/MultiSig2of3.sol:MultiSig2of3:generateMessageToSign(address,uint256)",5,5,1
"  function addApproval(address _spender, uint _addedValue)
  onlyPayloadSize(2 * 32)
  returns (bool success) {
      uint oldValue = allowed[msg.sender][_spender];
      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);
      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
      return true;
  }
","  function subApproval(address _spender, uint _subtractedValue)
  onlyPayloadSize(2 * 32)
  returns (bool success) {

      uint oldVal = allowed[msg.sender][_spender];

      if (_subtractedValue > oldVal) {
          allowed[msg.sender][_spender] = 0;
      } else {
          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);
      }
      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
      return true;
  }
","0x7e0b06a487b0060d447ea0bb8415b5cc6d7bd1d8/CrowdSaleTRH.sol:StandardToken:addApproval(address,uint256)","0x7e0b06a487b0060d447ea0bb8415b5cc6d7bd1d8/CrowdSaleTRH.sol:StandardToken:subApproval(address,uint256)",5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
","0x1bb5744d22297075487edbf9dc3f89d2e04ebce0/NewYearToken.sol:NewYearToken:transferFrom(address,address,uint256)","0x1bb5744d22297075487edbf9dc3f89d2e04ebce0/NewYearToken.sol:NewYearToken:allowance(address,address)",3,3,1
"	function burnFrom(address _from, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {
		if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {
			balances[_from] -= _value;
			allowed[_from][msg.sender] -= _value;
			_totalPatronSupply -= _value;
			Burn(_from, _value);
			return true;
		}
		else {throw;}
	}
","	function fillBidByAddress (address _contract) onlyBy (owner)
		{
			Interface c = Interface(_contract);
			c.fillBid();
		}
","0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:burnFrom(address,uint256)",0x5f68698245e8c8949450e68b8bd8acef37faae7d/Registrar.sol:Registrar:fillBidByAddress(address),5,5,1
"    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
","    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;

        tokenExchangeRate = _tokenExchangeRate;
    }
",0x5d65d971895edc438f465c17db6992698a52318d/NebulasToken.sol:NebulasToken:transferETH(),0x5d65d971895edc438f465c17db6992698a52318d/NebulasToken.sol:NebulasToken:setTokenExchangeRate(uint256),5,5,1
"  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
","  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transferFrom(_from, _to, _value);
  }
","0x2dd32d429bb8f301831409b4eb96746f9fb1a35b/LCH.sol:PausableToken:decreaseApproval(address,uint256)","0x2dd32d429bb8f301831409b4eb96746f9fb1a35b/LCH.sol:PausableToken:transferFrom(address,address,uint256)",2,2,1
"    function isPendingCabal(address _account)
    external view
    returns (bool)
    {
        return accounts[_account].membership & PENDING_CABAL != 0;
    }
","    function isPendingProposal(address _proposal)
    external view
    returns (bool)
    {
        return accounts[_proposal].membership & PENDING_PROPOSAL != 0;
    }
",0x000000002bb43c83ece652d161ad0fa862129a2c/AccountRegistry.sol:AccountRegistry:isPendingCabal(address),0x000000002bb43c83ece652d161ad0fa862129a2c/AccountRegistry.sol:AccountRegistry:isPendingProposal(address),5,5,1
"	function getLastRegionId() view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getLastRegionId();
	}
","	function getRegionCurrentPixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionCurrentPixelPrice(_regionId);
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getLastRegionId(),0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpControllerHelper:getRegionCurrentPixelPrice(uint256),5,5,1
"    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {
        require(targets.length > 0 && targets.length == unixTimes.length);

        for(uint j = 0; j < targets.length; j++){
            require(unlockUnixTime[targets[j]] < unixTimes[j]);
            unlockUnixTime[targets[j]] = unixTimes[j];
            LockedFunds(targets[j], unixTimes[j]);
        }
    }
","    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }
","0x8acd341e4c0f1c329ae33cb4eaac39e3c1f2c210/INMCOIN.sol:INMCOIN:lockupAccounts(address[],uint256[])",0x8acd341e4c0f1c329ae33cb4eaac39e3c1f2c210/INMCOIN.sol:INMCOIN:totalSupply(),5,5,1
"    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }
","    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
        bool sigok;

        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);

        bytes memory appkey1_pubkey = new bytes(64);
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);

        bytes memory tosign2 = new bytes(1+65+32);
        tosign2[0] = 1; //role
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);
        bytes memory CODEHASH = hex""fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c"";
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);

        if (sigok == false) return false;


        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
        bytes memory LEDGERKEY = hex""7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4"";

        bytes memory tosign3 = new bytes(1+65);
        tosign3[0] = 0xFE;
        copyBytes(proof, 3, 65, tosign3, 1);

        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
        copyBytes(proof, 3+65, sig3.length, sig3, 0);

        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);

        return sigok;
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:parseAddr(string),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)",5,5,1
"    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
        bool sigok;
        address signer;

        bytes32 sigr;
        bytes32 sigs;

        bytes memory sigr_ = new bytes(32);
        uint offset = 4+(uint(dersig[3]) - 0x20);
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
        bytes memory sigs_ = new bytes(32);
        offset += 32 + 2;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);

        assembly {
            sigr := mload(add(sigr_, 32))
            sigs := mload(add(sigs_, 32))
        }


        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
        if (address(sha3(pubkey)) == signer) return true;
        else {
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
            return (address(sha3(pubkey)) == signer);
        }
    }
","    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:verifySig(bytes32,bytes,bytes)","0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(string,string[4],uint256)",4,4,1
"    function add(uint256 a, uint256 b) internal returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
","    function sub(uint256 a, uint256 b) internal returns (uint256) {
        assert(b <= a);
        return a - b;
    }
","0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:SafeMath:add(uint256,uint256)","0x3eec78485181da25a0b7c47db9a51849481df859/Scrinium.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    modifier afterStart() {
        require(now >= startTime);
        _;
    }
","    modifier isClosed() {
        require(crowdsaleClosed);
        _;
    }
",0x0E915b35cC269b2DfC8BbD8E4A88Ed4884a53EfC/CrowdSale.sol:CrowdSale:afterStart(),0x0E915b35cC269b2DfC8BbD8E4A88Ed4884a53EfC/CrowdSale.sol:CrowdSale:isClosed(),5,5,1
"	function	setPI_edit_2	(	string	newPI_edit_2	)	public	onlyOwner	{	
		inPI_edit_2	=	newPI_edit_2	;					
	}									
","	function	setPI_edit_26	(	string	newPI_edit_26	)	public	onlyOwner	{	
		inPI_edit_26	=	newPI_edit_26	;					
	}									
",0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_2(string),0x8c1fdbdc6639923965b23d4d010245dcaf8f1cdb/PI_EDIT_1.sol:PI_EDIT_1:setPI_edit_26(string),5,5,1
"  function add(Role storage role, address addr)
    internal
  {
    role.bearer[addr] = true;
  }
","  function check(Role storage role, address addr)
    view
    internal
  {
    require(has(role, addr));
  }
","0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:Roles:add(Roles:Role,address)","0x7ad012fd817f8f5296805cbdc74e3a49c4affe5c/VeraCrowdsale.sol:Roles:check(Roles:Role,address)",5,5,1
"    modifier canOperate(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);
        _;
    }
","    modifier validNFToken(uint256 _tokenId) {
        require(idToOwner[_tokenId] != address(0));
        _;
    }
",0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:canOperate(uint256),0x0e6e19549a89c9bec84b5b632cd1674f8e066d06/EtheremonAdventureItem.sol:NFToken:validNFToken(uint256),4,4,1
"    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](2);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,bytes[2],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string,string,uint256)",5,5,1
"		function	getID_control	()	public	constant	returns	(	uint256	)	{
			return	ID_control	;						
		}									
","		function	setID_control	(	uint256	newID_control	)	public	onlyOwner	{	
			ID_control	=	newID_control	;					
		}									
",0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:getID_control(),0x07de430cca732a193403ee19656f5b0ba5db9c0c/CCH_TEL_AVIV_01.sol:CCH_TEL_AVIV_01:setID_control(uint256),5,5,1
"  function getTokenByIndex (address _owner, uint index) constant public returns (uint64) {
      //returns the angel number of the index-th item in that addresses angel list. 
         IPetCardData petCardData = IPetCardData(petCardDataContract);
        return uint64(petCardData.getPetByIndex(_owner, index));
        
  }
","  function transfer(address _to, uint256 _tokenId) public {
      
        IPetCardData petCardData = IPetCardData(petCardDataContract);
       address owner;
         (,,,,,,,,,owner) = petCardData.getPet(_tokenId);
      
       if ((seraphims[msg.sender] == true)  || (owner == msg.sender))
       {
         petCardData.transferPet(owner,_to, uint64 (_tokenId)) ;
         Transfer(owner, _to, _tokenId);
         MarketplaceTransfer(owner,  _to, _tokenId, msg.sender);
           
       }
      else {revert();}
  }
","0x5ee9bc8a2b2baa393706ba3f3268135663a626a1/PetWrapper721.sol:PetWrapper721:getTokenByIndex(address,uint256)","0x5ee9bc8a2b2baa393706ba3f3268135663a626a1/PetWrapper721.sol:PetWrapper721:transfer(address,uint256)",5,5,1
"    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,string,string)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)",5,5,1
"  function _burn(address _owner, uint256 _tokenId) internal {
    super._burn(_owner, _tokenId);

    // Clear metadata (if any)
    if (bytes(tokenURIs[_tokenId]).length != 0) {
      delete tokenURIs[_tokenId];
    }

    // Reorg all tokens array
    uint256 tokenIndex = allTokensIndex[_tokenId];
    uint256 lastTokenIndex = allTokens.length.sub(1);
    uint256 lastToken = allTokens[lastTokenIndex];

    allTokens[tokenIndex] = lastToken;
    allTokens[lastTokenIndex] = 0;

    allTokens.length--;
    allTokensIndex[_tokenId] = 0;
    allTokensIndex[lastToken] = tokenIndex;
  }
","  function _setTokenURI(uint256 _tokenId, string _uri) internal {
    require(exists(_tokenId));
    tokenURIs[_tokenId] = _uri;
  }
","0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721Token:_burn(address,uint256)","0x3a81d175f3dfd76e5013a57772929ed85f7d6380/CryptovoxelsProperty.sol:ERC721Token:_setTokenURI(uint256,string)",5,5,1
"    constructor() public {

        symbol = ""HVA""; 

        name = ""HVA SHARE"";

        decimals = 0;
  
        _totalSupply = 200000000 * 10**uint(decimals);

        balances[owner] = _totalSupply;

        emit Transfer(address(0), owner, _totalSupply);

    }
","    function balanceOf(address tokenOwner) public view returns (uint balance) {

        return balances[tokenOwner];

    }
",0x0df610d4229bcd5e149eec3e806a9afe74f5d63f/HVAToken.sol:HVAToken:constructor(),0x0df610d4229bcd5e149eec3e806a9afe74f5d63f/HVAToken.sol:HVAToken:balanceOf(address),5,5,1
"	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i < _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}
","	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}
",0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpPriceStorage:appendPricePoints(uint64[]),0x6c0a11e254b666b107abe5ecf5003b53bf362eb0/BdpCalculator.sol:BdpPriceStorage:setForwardPurchaseFeesTo(address),4,4,1
"  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    assert(token.transferFrom(from, to, value));
  }
","  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
    assert(token.transfer(to, value));
  }
","0x1c4a279df3bc4d6bbaebec3a95f1d3c8bd2afe0b/DNTXToken.sol:SafeERC20:safeTransferFrom(ERC20,address,address,uint256)","0x1c4a279df3bc4d6bbaebec3a95f1d3c8bd2afe0b/DNTXToken.sol:SafeERC20:safeTransfer(ERC20Basic,address,uint256)",4,4,1
"    modifier transactionExists(uint transactionId) {
        if (transactions[transactionId].destination == 0)
            throw;
        _;
    }
","    function getTransactionIds(uint from, uint to, bool pending, bool executed)
        public
        constant
        returns (uint[] _transactionIds)
    {
        uint[] memory transactionIdsTemp = new uint[](transactionCount);
        uint count = 0;
        uint i;
        for (i=0; i<transactionCount; i++)
            if (   pending && !transactions[i].executed
                || executed && transactions[i].executed)
            {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        _transactionIds = new uint[](to - from);
        for (i=from; i<to; i++)
            _transactionIds[i - from] = transactionIdsTemp[i];
    }
",0x3fd9aba22521d9ee3202a43bb132816a17973d43/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:transactionExists(uint256),"0x3fd9aba22521d9ee3202a43bb132816a17973d43/MultiSigWalletWithDailyLimit.sol:MultiSigWallet:getTransactionIds(uint256,uint256,bool,bool)",4,5,1
"  function buyTokens() public payable returns(uint tokenAmount) {

    uint _tokenAmount;
    uint multiplier = (10 ** decimals);
    uint weiAmount = msg.value;

    require(isCrowdsaleOpen);
    //require(whitelistedAddress[msg.sender]);

    require(weiAmount >= minETH);
    require(weiAmount <= maxETH);

    _tokenAmount =  safeMul(weiAmount,multiplier) / pricePerToken;

    require(_tokenAmount > 0);

    //safe sub will automatically handle overflows
    tokensForPublicSale = safeSub(tokensForPublicSale, _tokenAmount);
    onSaleTokens = safeSub(onSaleTokens, _tokenAmount);
    balances[contractAddress] = safeSub(balances[contractAddress],_tokenAmount);
    //assign tokens
    balances[msg.sender] = safeAdd(balances[msg.sender], _tokenAmount);

    //send money to the owner
    require(owner.send(weiAmount));

    return _tokenAmount;

  }
","  function sendTokensToOwner(uint _tokens) onlyOwner returns (bool ok){
      require(balances[contractAddress] >= _tokens);
      balances[contractAddress] = safeSub(balances[contractAddress],_tokens);
      balances[owner] = safeAdd(balances[owner],_tokens);
      return true;
  }
",0x5c751a3a3375a97463a4b5f000c3f700802e903a/DMToken.sol:DMToken:buyTokens(),0x5c751a3a3375a97463a4b5f000c3f700802e903a/DMToken.sol:DMToken:sendTokensToOwner(uint256),5,5,1
"    function tokensUnsold() public view returns(uint) {
        return token.TOTALSUPPLY().sub(token.totalSupply());
    }
","    function getRateAndCheckCap() public view returns (uint) {
        
        require(now>SALE_START);
        
        if ((now<SALE0_END) && (tokensRaised < SALE0_CAP))
            return SALE0_RATE;
        
        if ((now<SALE1_END) && (tokensRaised < SALE1_CAP))
            return SALE1_RATE;
        
        if ((now<SALE2_END) && (tokensRaised < SALE2_CAP))
            return SALE2_RATE;
        
        revert();
    }
",0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:REDTTokenSale:tokensUnsold(),0x2a5727f106758ccf0b9cb0c962b2895b8c0f4913/REDTToken.sol:REDTTokenSale:getRateAndCheckCap(),4,4,1
"    function buy() payable public {
        uint amount = msg.value / buyPrice;
        _transfer(this, msg.sender, amount);
    }
","    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
",0x07c832778f2b54ff373b0a59d848b3fbc4939f34/AdvancedTokenGTH.sol:AdvancedTokenGTH:buy(),"0x07c832778f2b54ff373b0a59d848b3fbc4939f34/AdvancedTokenGTH.sol:AdvancedTokenGTH:freezeAccount(address,bool)",3,3,1
"    function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {
        require( _recipients.length > 0 && _recipients.length == _values.length);

        uint total = 0;
        for(uint i = 0; i < _values.length; i++){
            total = total.add(_values[i]);
        }
        require(total <= balances[msg.sender]);

        uint64 _now = uint64(now);
        for(uint j = 0; j < _recipients.length; j++){
            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);
            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));
            Transfer(msg.sender, _recipients[j], _values[j]);
        }

        balances[msg.sender] = balances[msg.sender].sub(total);
        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));

        return true;
    }
","    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {
        require(_to != address(0));

        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // require (_value <= _allowance);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        if(transferIns[_from].length > 0) delete transferIns[_from];
        uint64 _now = uint64(now);
        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));
        transferIns[_to].push(transferInStruct(uint128(_value),_now));
        return true;
    }
","0x6e332e1142957045bcd47f37f003c939691f0c80/VIPCHAINToken.sol:VIPCHAINToken:batchTransfer(address[],uint256[])","0x6e332e1142957045bcd47f37f003c939691f0c80/VIPCHAINToken.sol:VIPCHAINToken:transferFrom(address,address,uint256)",5,5,1
"	function	getPOOL_edit_27	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_27	;						
	}									
","	function	getPOOL_edit_22	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_22	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_27(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_22(),5,5,0
"  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
","  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
","0x8a7b7b9b2f7d0c63f66171721339705a6188a7d5/EtherDoge.sol:StandardToken:transferFrom(address,address,uint256)","0x8a7b7b9b2f7d0c63f66171721339705a6188a7d5/EtherDoge.sol:StandardToken:allowance(address,address)",4,4,1
"    function decreaseApproval (address _owner, address _spender, uint _subtractedValue)
    onlyController
    returns (bool success) {
        uint oldValue = allowance[_owner][_spender];
        if (_subtractedValue > oldValue) {
            allowance[_owner][_spender] = 0;
        } else {
            allowance[_owner][_spender] = safeSub(oldValue, _subtractedValue);
        }
        return true;
    }
","    function burn(address _owner, uint _amount) onlyController {
        balanceOf[_owner] = safeSub(balanceOf[_owner], _amount);
        totalSupply = safeSub(totalSupply, _amount);
    }
","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Ledger:decreaseApproval(address,address,uint256)","0x6f444af44be5c398f57a2016d191e01ffd8f6931/Controller.sol:Ledger:burn(address,uint256)",5,5,1
"    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](3);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        return oraclize_query(timestamp, datasource, dynargs);
    }
","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(string,string[4],uint256)","0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[3])",4,4,1
"	function approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)
		{
			approvedFactories[_factoryContractAddress] = _approved;
		}
","	function registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly
		{
		if (SHA256HashRegister[_SHA256Hash] == 0x0) {
		   	SHA256HashRegister[_SHA256Hash] = _contract;
			approvedContracts[_contract] = true;
			cantSetReferrer[_artist] = true;
			artworkRegister[_contract].SHA256Hash = _SHA256Hash;
			artworkRegister[_contract].editionSize = _editionSize;
			artworkRegister[_contract].title = _title;
			artworkRegister[_contract].fileLink = _fileLink;
			artworkRegister[_contract].ownerCommission = _ownerCommission;
			artworkRegister[_contract].artist = _artist;
			artworkRegister[_contract].factory = msg.sender;
			artworkRegister[_contract].isIndexed = _indexed;
			artworkRegister[_contract].isOuroboros = _ouroboros;
			artworkIndex[artworkCount] = _contract;
			artistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;
			artistsArtworkCount[_artist]++;
			artworksFactory[_contract] = msg.sender;
			NewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);
			artworkCount++;
			}
			else {throw;}
		}
","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:approveFactoryContract(address,bool)","0x5cc6940d930001b1e1d29725cbfd68afe479e968/Registrar.sol:Registrar:registerArtwork(address,bytes32,uint256,string,string,uint256,address,bool,bool)",5,5,1
"    function mint(address _to, uint256 _amount, address _owner) internal returns (bool) {
        require(_to != address(0));
        require(_amount <= balances[_owner]);

        balances[_to] = balances[_to].add(_amount);
        balances[_owner] = balances[_owner].sub(_amount);
        Transfer(_owner, _to, _amount);
        return true;
    }
","    function startSale() public onlyOwner {
        saleToken = true;
    }
","0x6cfba3c7b4c944bdc9442c91d67d35d7c27fa430/OrphanToken.sol:OrphanToken:mint(address,uint256,address)",0x6cfba3c7b4c944bdc9442c91d67d35d7c27fa430/OrphanToken.sol:OrphanToken:startSale(),5,5,1
"	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}
","	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}
",0x7af66d707d8477ed9f246d29021112f9b588fcf6/BdpEntryPoint.sol:BdpContracts:getBdpController(address[16]),0x7af66d707d8477ed9f246d29021112f9b588fcf6/BdpEntryPoint.sol:BdpContracts:getBdpPriceStorage(address[16]),5,5,1
"    function cancelSubscriptionOffer(uint offerId) public returns (bool) {
        Subscription storage offer = subscriptions[offerId];
        assert (_isOffer(offer));
        assert (offer.transferTo == msg.sender || owner == msg.sender); //only service provider or platform owner is allowed to cancel the offer
        if (offer.expireOn>now){
            offer.expireOn = now;
            OfferCanceled(offerId, msg.sender);
            return true;
        }
        if (isContract(msg.sender)) { return false; }
        else { throw; }
    }
","    function _isOffer(Subscription storage sub) internal constant returns (bool){
        return sub.transferFrom == 0 && sub.transferTo != 0;
    }
",0x7a7bd6aead42b852fa7949c1e167bad5eff78415/SubscriptionModuleImpl.sol:SubscriptionModuleImpl:cancelSubscriptionOffer(uint256),0x7a7bd6aead42b852fa7949c1e167bad5eff78415/SubscriptionModuleImpl.sol:SubscriptionModuleImpl:_isOffer(SubscriptionBase:Subscription),5,5,1
"    function getRoundMaxNumberOfBets(uint id) constant returns(uint) {
        return rounds[id].maxNumberOfBets;
    }
","    function getRoundBlockNumber(uint id) constant returns(uint) {
        return rounds[id].blockNumber;
    }
",0x3c563651318b6b2cf555207a1e611bb577fff446/Lotthereum.sol:Lotthereum:getRoundMaxNumberOfBets(uint256),0x3c563651318b6b2cf555207a1e611bb577fff446/Lotthereum.sol:Lotthereum:getRoundBlockNumber(uint256),4,4,1
"	function	setPOOL_edit_7	(	string	newPOOL_edit_7	)	public	onlyOwner	{	
		inPOOL_edit_7	=	newPOOL_edit_7	;					
	}									
","	function	setPOOL_edit_34	(	string	newPOOL_edit_34	)	public	onlyOwner	{	
		inPOOL_edit_34	=	newPOOL_edit_34	;					
	}									
",0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_7(string),0x4afbcb0c7bbe2140f2b570a3bebf96f9883c3403/POOL_EDIT_2.sol:POOL_EDIT_2:setPOOL_edit_34(string),5,5,1
"    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
","    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
",0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_getPrice(string),"0x5dfdc8168c8cf48cd174fad3f8881289929b1f94/Dice.sol:usingOraclize:oraclize_query(uint256,string,string,string)",4,4,1
"    function EtchToken() {
        maxTotalSupply = 10**25; // 10 Mil.
        totalInitialSupply = 10**24; // 1 Mil.

        chainStartTime = now;
        chainStartBlockNumber = block.number;

        balances[msg.sender] = totalInitialSupply;
        totalSupply = totalInitialSupply;
    }
","    function mint() canPoSMint returns (bool) {
        if(balances[msg.sender] <= 0) return false;
        if(transferIns[msg.sender].length <= 0) return false;

        uint reward = getProofOfStakeReward(msg.sender);
        if(reward <= 0) return false;

        totalSupply = totalSupply.add(reward);
        balances[msg.sender] = balances[msg.sender].add(reward);
        delete transferIns[msg.sender];
        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));

        Mint(msg.sender, reward);
        return true;
    }
",0x4e55bc3943a24e46a935359e8522c66e504821ad/EtchToken.sol:EtchToken:EtchToken(),0x4e55bc3943a24e46a935359e8522c66e504821ad/EtchToken.sol:EtchToken:mint(),4,4,0
"  function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
","  function approvedFor(uint256 _tokenId) public view returns (address) {
    return tokenApprovals[_tokenId];
  }
",0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:takeOwnership(uint256),0x6a190eef45f589373a463afb3b90493e696c45e2/Tokenizator.sol:ERC721Token:approvedFor(uint256),4,5,1
"    function getRoundMinAmountByBet(uint id) constant returns(uint) {
        return rounds[id].minAmountByBet;
    }
","    function getRoundBetAmount(uint roundId, uint betId) constant returns(uint) {
        return bets[roundId][betId].amount;
    }
",0x3c563651318b6b2cf555207a1e611bb577fff446/Lotthereum.sol:Lotthereum:getRoundMinAmountByBet(uint256),"0x3c563651318b6b2cf555207a1e611bb577fff446/Lotthereum.sol:Lotthereum:getRoundBetAmount(uint256,uint256)",5,5,1
"	function	getData_28	()	public	constant	returns	(	string	)	{
		return	inData_28	;						
	}									
","	function	getData_22	()	public	constant	returns	(	string	)	{
		return	inData_22	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_28(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_22(),5,5,1
"	function	getPOOL_edit_17	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_17	;						
	}									
","	function	setPOOL_edit_23	(	string	newPOOL_edit_23	)	public	onlyOwner	{	
		inPOOL_edit_23	=	newPOOL_edit_23	;					
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_17(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:setPOOL_edit_23(string),5,5,1
"    function acupuncturecoin(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
","    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
","0x8a95e5488153724d5bfd37a17b0608c8d7d31202/acupuncturecoin.sol:acupuncturecoin:acupuncturecoin(uint256,string,string)","0x8a95e5488153724d5bfd37a17b0608c8d7d31202/acupuncturecoin.sol:acupuncturecoin:approveAndCall(address,uint256,bytes)",2,2,0
"		function	getData_19	()	public	constant	returns	(	string	)	{
			return	inData_19	;						
		}									
","		function	getData_24	()	public	constant	returns	(	string	)	{
			return	inData_24	;						
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_19(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_24(),5,5,1
"    modifier onlyAdmin {
        if(!(msg.sender == admin1)) {
            revert();
        }
        _;
    }
","    function hasKey(address key) private constant returns (bool){
        for(uint256 i=0;i<balancesKeys.length;i++){
            address value = balancesKeys[i];
            if(value == key){
                return true;
            }
        }
        return false;
    }
",0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:onlyAdmin(),0x5fce27e9b9545938c8e8c5b6c5676fb45205b999/Redemption.sol:Redemption:hasKey(address),4,5,1
"    function transfer(address _to, uint _value) 
    onlyPayloadSize(2 * 32) 
    public
    returns (bool success)
    {
        require(_to != address(0));
        if (balances[msg.sender] >= _value && _value > 0) {
            uint codeLength;
            bytes memory empty;
            assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
            }

            balances[msg.sender] = safeSub(balances[msg.sender], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            if(codeLength>0) {
                ContractReceiver receiver = ContractReceiver(_to);
                receiver.tokenFallback(msg.sender, _value, empty);
            }
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }

    }
","    function transfer(address _to, uint _value, bytes _data)
    onlyPayloadSize(2 * 32) 
    public
    returns (bool success) 
    {
        require(_to != address(0));
        if (balances[msg.sender] >= _value && _value > 0) {
            // Standard function transfer similar to ERC20 transfer with no _data .
            // Added due to backwards compatibility reasons .
            uint codeLength;

            assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
            }
            balances[msg.sender] = safeSub(balances[msg.sender], _value);
            balances[_to] = safeAdd(balances[_to], _value);
            if(codeLength>0) {
                ContractReceiver receiver = ContractReceiver(_to);
                receiver.tokenFallback(msg.sender, _value, _data);
            }
            emit Transfer(msg.sender, _to, _value, _data);
            return true;
        }else{return false;}

    }
","0x7b7b239e7fc2b4680f5cf469ecb968bd94bb38aa/CoSoundToken.sol:StandardToken:transfer(address,uint256)","0x7b7b239e7fc2b4680f5cf469ecb968bd94bb38aa/CoSoundToken.sol:StandardToken:transfer(address,uint256,bytes)",4,4,0
"    function GetGift()
    public
    payable
    {
        if(reciver==msg.sender&&now>unlockTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
","    function SetGiftTime(uint _unixTime)
    public
    {
        if(msg.sender==sender)
        {
            unlockTime = _unixTime;
        }
    }
",0x6f905E47d3e6A9Cc286b8250181Ee5A0441Acc81/PRESENT_1_ETH.sol:PRESENT_1_ETH:GetGift(),0x6f905E47d3e6A9Cc286b8250181Ee5A0441Acc81/PRESENT_1_ETH.sol:PRESENT_1_ETH:SetGiftTime(uint256),4,4,1
"    function minter() public view returns (address) {
        return data.minter;
    }
","    function decimals() public view returns (uint8) {
        return data.decimals;
    }
",0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:minter(),0x04d01b6145bc9db925ec1e80bc85f936a961210e/BTTSToken.sol:BTTSToken:decimals(),4,4,1
"    function div(uint a, uint b) internal pure returns (uint) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
","    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c >= a);
        return c;
    }
","0x3a92b0fa21043e14a021821ba9371a8ed01ec5dc/SharderToken.sol:SafeMath:div(uint256,uint256)","0x3a92b0fa21043e14a021821ba9371a8ed01ec5dc/SharderToken.sol:SafeMath:add(uint256,uint256)",5,5,1
"    function buyKnowledge() external payable{
        require(initialized);
        uint256 knowledgeBought = calculateKnowledgeBuy(msg.value,SafeMath.sub(this.balance,msg.value));
        claimedKnowledge[msg.sender] = SafeMath.add(claimedKnowledge[msg.sender],knowledgeBought);
    }
","    function getKnowledgeSinceLastUse(address adr) public view returns(uint256){
        uint256 secondsPassed = min(KNOWLEDGE_TO_GET_1FRANKLIN,SafeMath.sub(now,lastUse[adr]));
        return SafeMath.mul(secondsPassed,hatcheryFranklin[adr]);
    }
",0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:buyKnowledge(),0x0bf5fd285f0c6c323564293ed5d6b64d90d50c4f/FranklinFarmer.sol:FranklinFarmer:getKnowledgeSinceLastUse(address),5,5,1
"    function burnFrom(address _from, uint256 _value) returns (bool) 
    {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }
","    function burn(uint _value) returns (bool)
    {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }
","0x4c5e45cc4dd47c8e8c9ea4698025652b6728621e/EDMToken.sol:EDMToken:burnFrom(address,uint256)",0x4c5e45cc4dd47c8e8c9ea4698025652b6728621e/EDMToken.sol:EDMToken:burn(uint256),5,5,1
"		function	getData_31	()	public	constant	returns	(	string	)	{
			return	inData_31	;						
		}									
","		function	setData_7	(	string	newData_7	)	public	onlyOwner	{	
			inData_7	=	newData_7	;					
		}									
",0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:getData_31(),0x7e36c703eca838934bb562da29c1422852ccf5e3/BIPOOH_DAO_32_a.sol:BIPOOH_DAO_32_a:setData_7(string),5,5,0
"    function ba2cbor(bytes[] arr) internal pure returns (bytes) {
            uint arrlen = arr.length;

            // get correct cbor output length
            uint outputlen = 0;
            bytes[] memory elemArray = new bytes[](arrlen);
            for (uint i = 0; i < arrlen; i++) {
                elemArray[i] = (bytes(arr[i]));
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
            }
            uint ctr = 0;
            uint cborlen = arrlen + 0x80;
            outputlen += byte(cborlen).length;
            bytes memory res = new bytes(outputlen);

            while (byte(cborlen).length > ctr) {
                res[ctr] = byte(cborlen)[ctr];
                ctr++;
            }
            for (i = 0; i < arrlen; i++) {
                res[ctr] = 0x5F;
                ctr++;
                for (uint x = 0; x < elemArray[i].length; x++) {
                    // if there's a bug with larger strings, this may be the culprit
                    if (x % 23 == 0) {
                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
                        elemcborlen += 0x40;
                        uint lctr = ctr;
                        while (byte(elemcborlen).length > ctr - lctr) {
                            res[ctr] = byte(elemcborlen)[ctr - lctr];
                            ctr++;
                        }
                    }
                    res[ctr] = elemArray[i][x];
                    ctr++;
                }
                res[ctr] = 0xFF;
                ctr++;
            }
            return res;
        }
","    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        bytes memory args = ba2cbor(argN);
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:ba2cbor(bytes[]),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:oraclize_query(uint256,string,bytes[],uint256)",4,5,1
"    constructor() public {
        symbol = ""TSRN"";
        name = ""TESSRNET"";
        decimals = 8;
        _totalSupply = 100000000000000;
        balances[0xDE012Fee8754BA1DF8077E1B6216a945Ec4285D7] = _totalSupply;
        emit Transfer(address(0), 0xDE012Fee8754BA1DF8077E1B6216a945Ec4285D7, _totalSupply);
    }
","    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }
",0x5f24ed71ac6ddea5aa2dee7b521b98763520c6ed/TessrnetToken.sol:TessrnetToken:constructor(),"0x5f24ed71ac6ddea5aa2dee7b521b98763520c6ed/TessrnetToken.sol:TessrnetToken:approveAndCall(address,uint256,bytes)",4,4,0
"    function approve(address _spender, uint256 _value) public {
        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }
","    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
","0x0ee6071bc209c19161f6d17f8597d762b4d30806/CFL.sol:StandardToken:approve(address,uint256)","0x0ee6071bc209c19161f6d17f8597d762b4d30806/CFL.sol:StandardToken:allowance(address,address)",4,4,1
"	function	getData_19	()	public	constant	returns	(	string	)	{
		return	inData_19	;						
	}									
","	function	getData_9	()	public	constant	returns	(	string	)	{
		return	inData_9	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_19(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_9(),5,5,1
"	function	getData_32	()	public	constant	returns	(	string	)	{
		return	inData_32	;						
	}									
","	function	getData_13	()	public	constant	returns	(	string	)	{
		return	inData_13	;						
	}									
",0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_32(),0x7ed0d751664298f66e3bdfd9451588fd397afe11/Yuzhuralzoloto_2.sol:Yuzhuralzoloto_2:getData_13(),5,5,0
"  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }
","  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }
","0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:PausableToken:transfer(address,uint256)","0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a/WobToken.sol:PausableToken:transferFrom(address,address,uint256)",5,5,1
"    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {
        if (balanceOf(msg.sender) < _value) revert();
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
","    function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {
        require(SmartContract_Allowed[_to]);
		
		if (balanceOf(msg.sender) < _value) revert();
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
","0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:transferToAddress(address,uint256,bytes)","0x6d66439c9cc75b69f9a40e82f34445081b8e929a/TokenRK50Z.sol:TokenRK50Z:transferToContract(address,uint256,bytes)",5,5,1
"    function changeAdmin(address newAdmin) public onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
","    function transferFrom(address _from, address _to, uint _value) validDestination(_to) public returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
",0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:WbtToken:changeAdmin(address),"0x1ef62a7adba8c6e1903a1723f208f88636cd5470/WbtToken.sol:WbtToken:transferFrom(address,address,uint256)",4,4,1
"    modifier coupon(string code){
        oraclize = OraclizeI(OAR.getAddress());
        oraclize.useCoupon(code);
        _;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs);
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:coupon(string),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[4])",5,5,1
"  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
","  modifier whenPaused() {
    require(paused);
    _;
  }
",0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7/UAPToken.sol:Pausable:unpause(),0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7/UAPToken.sol:Pausable:whenPaused(),4,4,1
"    function DYLC_ERC20Token() public {
        owner = 0xA9802C071dD0D9fC470A06a487a2DB3D938a7b02;
        balanceOf[owner] = DEVELOPER_RESERVED;
    }
","    modifier onlyOwner() {
      require(msg.sender == owner);
      _;
    }
",0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5/DYLC_ERC20Token.sol:DYLC_ERC20Token:DYLC_ERC20Token(),0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5/DYLC_ERC20Token.sol:DYLC_ERC20Token:onlyOwner(),5,5,1
"	function	getPOOL_edit_15	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_15	;						
	}									
","	function	getPOOL_edit_19	()	public	constant	returns	(	string	)	{
		return	inPOOL_edit_19	;						
	}									
",0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_15(),0x8c7c095c9af40872484e9f9949e543706a3280ae/POOL_EDIT_1.sol:POOL_EDIT_1:getPOOL_edit_19(),5,5,0
"    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
","    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](1);
        dynargs[0] = args[0];
        return oraclize_query(datasource, dynargs, gaslimit);
    }
","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(uint256,string,string,string,uint256)","0x1fd76bc4e080e5f11703528961b2e515296c1c04/FlightDelayPayout.sol:usingOraclize:oraclize_query(string,bytes[1],uint256)",5,5,1
"    function accountLocked(address tokenOwner) public view returns (bool) {
        return data.accountLocked[tokenOwner];
    }
","    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return data.allowed[tokenOwner][spender];
    }
",0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:accountLocked(address),"0x4ac00f287f36a6aad655281fe1ca6798c9cb727b/BTTSToken.sol:BTTSToken:allowance(address,address)",5,5,1
"    modifier tokenIsDeployed() {
        require(isTokenDeployed == true);
        _;
    }
","    modifier onlyPublic() {
        require(msg.sender != founderMultiSigAddress);
        _;
    }
",0x2f665527b0a8b3710adcde917220de7d6b68d67d/BiQCrowdFund.sol:BiQCrowdFund:tokenIsDeployed(),0x2f665527b0a8b3710adcde917220de7d6b68d67d/BiQCrowdFund.sol:BiQCrowdFund:onlyPublic(),4,4,1
"    function totalSupply() public constant returns (uint) {

        return _totalSupply  - balances[address(0)];

    }
","    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }
",0x4a4293817ab21469b2430e8d5e169d9904233af3/MGUToken.sol:MGUToken:totalSupply(),"0x4a4293817ab21469b2430e8d5e169d9904233af3/MGUToken.sol:MGUToken:approve(address,uint256)",4,4,1
"	function finalise()
		only_owner
		public
	{
		locked = false;
		owner = 0;
		phaseStart = now;
	}
","	function transfer(address _to, uint256 _value)
		when_owns(msg.sender, _value)
		when_liquid
		returns (bool)
	{
		Transfer(msg.sender, _to, _value);
		accounts[msg.sender].balance -= _value;
		accounts[_to].balance += _value;

		return true;
	}
",0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:finalise(),"0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce/AmberToken.sol:AmberToken:transfer(address,uint256)",4,4,1
"  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x6a3777eb316ed485dd399628e8c0711eb8f5b0db/M2B.sol:SafeMath:add(uint256,uint256)","0x6a3777eb316ed485dd399628e8c0711eb8f5b0db/M2B.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
            oraclize_setNetworkName(""eth_mainnet"");
            return true;
        }
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
            oraclize_setNetworkName(""eth_ropsten3"");
            return true;
        }
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
            oraclize_setNetworkName(""eth_kovan"");
            return true;
        }
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
            oraclize_setNetworkName(""eth_rinkeby"");
            return true;
        }
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
            return true;
        }
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
            return true;
        }
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
            return true;
        }
        return false;
    }
","    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
        bytes[] memory dynargs = new bytes[](4);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);
    }
",0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_setNetwork(uint8),"0x480ec0cd951e42c626cf8db18e5ed99da076e074/CCCoin.sol:usingOraclize:oraclize_query(uint256,string,bytes[4],uint256)",5,5,1
"    function omsairam18() public {
        symbol = ""OMSAIRAM"";
        name = ""OMSAIRAM 2018 Token"";
        decimals = 18;
        endDate = now + 30 weeks;

    }
","    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }
",0x4e73b59501ecfdb75f5ffafa6d58c75c9fcc6ab0/omsairam18.sol:omsairam18:omsairam18(),"0x4e73b59501ecfdb75f5ffafa6d58c75c9fcc6ab0/omsairam18.sol:omsairam18:transfer(address,uint256)",5,5,1
"    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){

        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;
        bytes memory keyhash = new bytes(32);
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);
        if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false;

        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);

        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;

        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.
        // This is to verify that the computed args match with the ones specified in the query.
        bytes memory commitmentSlice1 = new bytes(8+1+32);
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);

        bytes memory sessionPubkey = new bytes(64);
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);

        bytes32 sessionPubkeyHash = sha256(sessionPubkey);
        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match
            delete oraclize_randomDS_args[queryId];
        } else return false;


        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)
        bytes memory tosign1 = new bytes(32+8+1+32);
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;

        // verify if sessionPubkeyHash was verified already, if not.. let's do it!
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);
        }

        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];
    }
","    function oraclize_getNetworkName() internal returns (string) {
        return oraclize_network_name;
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_getNetworkName(),4,4,1
"  function addToWhitelist(address _beneficiary) public onlyBy(kycAdmin) {
    whitelist[_beneficiary] = true;
    emit AddToWhitelist(_beneficiary);
  }
","  function setTokenNAVMicroUSD(uint256 _price) external onlyBy(navAdmin) {
    tokenNAVMicroUSD = _price;
  }
",0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:addToWhitelist(address),0x3f9f66570cb7b65d99474a13d6a4d83ed8c84b34/PentacoreCrowdsale.sol:PentacoreToken:setTokenNAVMicroUSD(uint256),5,5,1
"    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {
        oraclize_randomDS_args[queryId] = commitment;
    }
","    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_randomDS_setCommitment(bytes32,bytes32)","0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string)",4,4,1
"	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}
","	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) && _width > 0 && _height > 0 && _partsCount > 0 && _imageDescriptor > 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}
",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:deleteImage(uint256),"0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:createImage(address,uint256,uint16,uint16,uint16,uint16)",5,5,1
"	function calculateRegionSalePixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpCalculator.calculateRegionSalePixelPrice(contracts, _regionId);
	}
","	function setImageOwner(uint256 _imageId, address _owner) public {
		BdpImage.setImageOwner(contracts, _imageId, _owner);
	}
",0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:calculateRegionSalePixelPrice(uint256),"0x3f66500c624d423063ee3a15df6f49cd5098d927/BdpControllerHelper.sol:BdpControllerHelper:setImageOwner(uint256,address)",5,5,1
"  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
","  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x1ce95ce5aebe5beb20d69c308cd0e21797873c38/Crowdsale.sol:SafeMath:add(uint256,uint256)","0x1ce95ce5aebe5beb20d69c308cd0e21797873c38/Crowdsale.sol:SafeMath:sub(uint256,uint256)",4,4,1
"    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }
","    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
","0x3da034753B42Bda1BcFA682f29685E2fd6729016/VoipToken.sol:VoipToken:adminClaimAirdropMultiple(address[],uint256)",0x3da034753B42Bda1BcFA682f29685E2fd6729016/VoipToken.sol:VoipToken:onlyOwner(),5,5,1
"  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
","  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
","0x3e419b0401339df3564edfa3686d7f99354f134d/NANASHITOKEN.sol:SafeMath:div(uint256,uint256)","0x3e419b0401339df3564edfa3686d7f99354f134d/NANASHITOKEN.sol:SafeMath:mul(uint256,uint256)",4,4,1
"	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}
","	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}
","0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:setImageDescriptor(uint256,uint16)",0x2b48d0f08d4db22fba7259bc67e6c920509813b9/BdpControllerHelper.sol:BdpImageStorage:getImagePartsCount(uint256),5,5,1
"  function power(uint256 a,uint256 b) internal constant returns (uint256){
      return mul(a,10**b);
  }
","  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
","0x5cde5338fdf2002dc04691617c66ef307acbdbca/FinalTestToken.sol:SafeMath:power(uint256,uint256)","0x5cde5338fdf2002dc04691617c66ef307acbdbca/FinalTestToken.sol:SafeMath:sub(uint256,uint256)",4,4,1
"  function presalePurchase(address[] presales, address _presaleAddress) internal {
    RakugoPresale rakugoPresale = RakugoPresale(_presaleAddress);
    for (uint i = 0; i < presales.length; i++) {
        address presalePurchaseAddress = presales[i];
        uint256 contributionAmmount = 0;//presale contributions tracked differently than main sale
        uint256 presalePurchaseTokens = rakugoPresale.balanceOf(presalePurchaseAddress);
        contribute(presalePurchaseAddress, presalePurchaseAddress, contributionAmmount, presalePurchaseTokens);
    }
  }
","  function finalization() internal {
    token.finishMinting();
  }
","0x5E9483Af5aF106625ABB08dE51E0d3037d04c3E0/RakugoToken.sol:RakugoCrowdsale:presalePurchase(address[],address)",0x5E9483Af5aF106625ABB08dE51E0d3037d04c3E0/RakugoToken.sol:RakugoCrowdsale:finalization(),5,5,1
"    function getLastContract() constant returns (address) {
        var sender_contracts = getContractsOf[msg.sender];
        return sender_contracts[sender_contracts.length - 1];
    }
","    function setBeneficiary(address _beneficiary) onlyOwner
    { beneficiary = _beneficiary; }
",0x7b52427cec68182C74d0b5f9Dec57ddD8f727DE9/BuilderTokenEmission.sol:Builder:getLastContract(),0x7b52427cec68182C74d0b5f9Dec57ddD8f727DE9/BuilderTokenEmission.sol:Builder:setBeneficiary(address),5,5,1
"    function uint2str(uint i) internal pure returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
","    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (sig.length != 65)
          return (false, 0);

        // The signature format is a compact form of:
        //   {bytes32 r}{bytes32 s}{uint8 v}
        // Compact means, uint8 is not padded to 32 bytes.
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))

            // Here we are loading the last 32 bytes. We exploit the fact that
            // 'mload' will pad with zeroes if we overread.
            // There is no 'mload8' to do this, but that would be nicer.
            v := byte(0, mload(add(sig, 96)))

            // Alternative solution:
            // 'byte' is not working due to the Solidity parser, so lets
            // use the second best option, 'and'
            // v := and(mload(add(sig, 65)), 255)
        }

        // albeit non-transactional signatures are not specified by the YP, one would expect it
        // to match the YP range of [27, 28]
        //
        // geth uses [0, 1] and some clients have followed. This might change, see:
        //  https://github.com/ethereum/go-ethereum/issues/2053
        if (v < 27)
          v += 27;

        if (v != 27 && v != 28)
            return (false, 0);

        return safer_ecrecover(hash, v, r, s);
    }
",0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:uint2str(uint256),"0x379c4c01484de6cdd3e685f63c702e45e3c574fd/Etherlympics.sol:usingOraclize:ecrecovery(bytes32,bytes)",4,4,1
"    function oraclize_useCoupon(string code) oraclizeAPI internal {
        oraclize.useCoupon(code);
    }
","    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
        string[] memory dynargs = new string[](5);
        dynargs[0] = args[0];
        dynargs[1] = args[1];
        dynargs[2] = args[2];
        dynargs[3] = args[3];
        dynargs[4] = args[4];
        return oraclize_query(datasource, dynargs);
    }
",0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_useCoupon(string),"0x45c58bbd535b8661110ef5296e6987573d0c8276/Etheraffle.sol:usingOraclize:oraclize_query(string,string[5])",5,5,1
"    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
","    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
","0x1bd96b3c300e1e3d0cf4e5e1c0bb4312a53f8419/FHCoin.sol:StandardToken:transferFrom(address,address,uint256)","0x1bd96b3c300e1e3d0cf4e5e1c0bb4312a53f8419/FHCoin.sol:StandardToken:allowance(address,address)",3,3,1
"    constructor() public {
        pauseOperator = msg.sender;
    }
","    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
",0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:constructor(),"0x4aa31350abd22345150f1b9f4e48e76a3bbb65f0/ICOTH.sol:PauseBurnableERC827Token:increaseApproval(address,uint256)",5,5,1
"    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
","    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
","0x4bC53ead2aE82e0c723ee8E3D7BAcfB1faFEA1cE/GUESS_AND_GET_A_PRIZE.sol:GUESS_AND_GET_A_PRIZE:NewQuestion(string,bytes32)",0x4bC53ead2aE82e0c723ee8E3D7BAcfB1faFEA1cE/GUESS_AND_GET_A_PRIZE.sol:GUESS_AND_GET_A_PRIZE:StopGame(),5,5,1
"    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
        
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
","    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
","0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b/MobileAppCoin.sol:MobileAppCoin:distr(address,uint256)",0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b/MobileAppCoin.sol:MobileAppCoin:canDistr(),5,5,1
"  function seed_eth() public payable only_admin() {
    require(!eth_is_seeded);
    require(msg.value == eth_seed_amount);
    set_eth_as_seeded();
    deposit_eth(); 
  }
","  function withdraw_token(uint256 _amount) public only_admin() {
    transfer_tokens_from_contract(admin, _amount);
  }
",0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:seed_eth(),0x1d72a51dd9ae994cd313a3ef687d15f115ab122b/TokenLiquidityMarket.sol:TokenLiquidityMarket:withdraw_token(uint256),5,5,1
"    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
","    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
","0x06e2272f1bb306a92c92d978a4df139578c83c91/CryptoDime.sol:SafeMath:safeDiv(uint256,uint256)","0x06e2272f1bb306a92c92d978a4df139578c83c91/CryptoDime.sol:SafeMath:safeMul(uint256,uint256)",4,4,1
